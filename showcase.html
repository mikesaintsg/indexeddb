<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IndexedDB Showcase</title>
  <script type="module" crossorigin>(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))r(n);new MutationObserver(n=>{for(const a of n)if(a.type==="childList")for(const o of a.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function t(n){const a={};return n.integrity&&(a.integrity=n.integrity),n.referrerPolicy&&(a.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?a.credentials="include":n.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function r(n){if(n.ep)return;n.ep=!0;const a=t(n);fetch(n.href,a)}})();const B=[{id:"u1",name:"Alice Johnson",email:"alice@example.com",age:28,status:"active",role:"admin",tags:["developer","leader"],createdAt:Date.now()-864e5*30},{id:"u2",name:"Bob Smith",email:"bob@example.com",age:35,status:"active",role:"user",tags:["developer"],createdAt:Date.now()-864e5*20},{id:"u3",name:"Carol White",email:"carol@example.com",age:42,status:"inactive",role:"user",tags:["designer"],createdAt:Date.now()-864e5*15},{id:"u4",name:"David Brown",email:"david@example.com",age:25,status:"active",role:"guest",tags:["intern"],createdAt:Date.now()-864e5*10},{id:"u5",name:"Eva Green",email:"eva@example.com",age:31,status:"active",role:"user",tags:["developer","tester"],createdAt:Date.now()-864e5*5}],K=[{id:"p1",title:"Getting Started with IndexedDB",content:"IndexedDB is a powerful browser API...",authorId:"u1",published:!0,views:1200,createdAt:Date.now()-864e5*10},{id:"p2",title:"Advanced Queries",content:"Learn how to use the query builder...",authorId:"u1",published:!0,views:800,createdAt:Date.now()-864e5*8},{id:"p3",title:"Draft: New Features",content:"This post is still being written...",authorId:"u2",published:!1,views:50,createdAt:Date.now()-864e5*5},{id:"p4",title:"Cross-Tab Sync",content:"Keep data synchronized across tabs...",authorId:"u2",published:!0,views:500,createdAt:Date.now()-864e5*3},{id:"p5",title:"Error Handling Best Practices",content:"How to handle errors properly...",authorId:"u5",published:!0,views:300,createdAt:Date.now()-864e5}],H=[{id:"s1",key:"theme",value:"dark",updatedAt:Date.now()-36e5},{id:"s2",key:"language",value:"en",updatedAt:Date.now()-72e5},{id:"s3",key:"notifications",value:"enabled",updatedAt:Date.now()}];class f extends Error{code;cause;constructor(e,t,r){super(t),this.name="DatabaseError",this.code=e,this.cause=r,Object.setPrototypeOf(this,new.target.prototype)}}class w extends f{storeName;key;constructor(e,t){const r=P(t);super("NOT_FOUND",`Record not found in "${e}" with key: ${r}`),this.name="NotFoundError",this.storeName=e,this.key=t}}class S extends f{storeName;key;constructor(e,t,r){const n=P(t);super("CONSTRAINT_ERROR",`Key already exists in "${e}": ${n}`,r),this.name="ConstraintError",this.storeName=e,this.key=t}}class W extends f{constructor(e){super("QUOTA_EXCEEDED","Storage quota exceeded",e),this.name="QuotaExceededError"}}class b extends f{constructor(e,t,r){super(e,t,r),this.name="TransactionError"}}class I extends f{constructor(e,t,r){super(e,t,r),this.name="UpgradeError"}}class Q extends f{constructor(e,t){super("OPEN_FAILED",e,t),this.name="OpenError"}}class J extends f{constructor(e,t){super("DATA_ERROR",e,t),this.name="DataError"}}class z extends f{constructor(e,t){super("READ_ONLY",e,t),this.name="ReadOnlyError"}}class Y extends f{constructor(e,t){super("VERSION_ERROR",e,t),this.name="VersionError"}}class A extends f{constructor(e,t){super("INVALID_STATE",e,t),this.name="InvalidStateError"}}class X extends f{constructor(e,t){super("TIMEOUT",e,t),this.name="TimeoutError"}}function y(s,e){if(!s)return new f("UNKNOWN_ERROR","Unknown error occurred");const t=e?.storeName??"",r=e?.key??"";switch(s.name){case"ConstraintError":return new S(t,r,s);case"QuotaExceededError":return new W(s);case"TransactionInactiveError":return new b("TRANSACTION_INACTIVE",s.message||"Transaction is not active",s);case"AbortError":return new b("TRANSACTION_ABORTED",s.message||"Transaction was aborted",s);case"VersionError":return new Y(s.message||"Version error",s);case"DataError":return new J(s.message||"Data error",s);case"InvalidStateError":return new A(s.message||"Invalid state",s);case"ReadOnlyError":return new z(s.message||"Attempted write in read-only transaction",s);case"NotFoundError":return new f("NOT_FOUND",s.message||"Object store or index not found",s);case"TimeoutError":return new X(s.message||"Operation timed out",s);default:return new f("UNKNOWN_ERROR",s.message||`Unknown error: ${s.name}`,s)}}function Z(s){return s instanceof f}function k(s){return s instanceof w}function O(s){return s instanceof S}function ee(s,e){return s instanceof f&&s.code===e}function P(s){return typeof s=="string"?`"${s}"`:typeof s=="number"?String(s):s instanceof Date?s.toISOString():Array.isArray(s)?`[${s.map(P).join(", ")}]`:s instanceof ArrayBuffer||ArrayBuffer.isView(s)?"[Binary Data]":String(s)}const F="id",_=!1,N={DATABASE_NOT_OPEN:"Database connection is not open",DATABASE_CLOSED:"Database connection has been closed",STORE_NOT_FOUND:s=>`Object store "${s}" not found`,INDEX_NOT_FOUND:s=>`Index "${s}" not found`,TRANSACTION_INACTIVE:"Transaction is no longer active",TRANSACTION_MODE_MISMATCH:"Operation requires readwrite transaction",INVALID_KEY:"Invalid key type for this operation",NATIVE_ACCESS_NO_TRANSACTION:"Native store access requires active transaction",UPGRADE_BLOCKED:"Database upgrade blocked by other connections",UPGRADE_FAILED:"Database upgrade failed",OPEN_FAILED:"Failed to open database"};function q(s){return new Promise((e,t)=>{s.oncomplete=()=>e(),s.onerror=()=>{t(y(s.error))},s.onabort=()=>{t(new b("TRANSACTION_ABORTED",s.error?.message??"Transaction was aborted",s.error))}})}function V(s){if(s==null)return!1;const e=typeof s;return e==="number"?!Number.isNaN(s):e==="string"?!0:s instanceof Date?!Number.isNaN(s.getTime()):s instanceof ArrayBuffer||ArrayBuffer.isView(s)?!0:Array.isArray(s)?s.every(V):!1}function R(s){return Array.isArray(s)?s:[s]}function te(s){return typeof s=="number"&&Number.isInteger(s)&&s>0}function re(s){if(!te(s))throw new Error(`Database version must be a positive integer, got: ${String(s)}`)}function se(s){if(s.length===0)throw new Error("Database name must be a non-empty string")}function g(s){return s===void 0?"next":s==="previous"?"prev":s==="previousunique"?"prevunique":s}function L(s){return s==="prev"?"previous":s==="prevunique"?"previousunique":s}class v{#t;#e;constructor(e,t){this.#t=e,this.#e=t}get native(){return this.#t}getKey(){return this.#t.key}getPrimaryKey(){return this.#t.primaryKey}getValue(){return this.#t.value}getDirection(){return L(this.#t.direction)}async continue(e){return new Promise((t,r)=>{this.#e.onsuccess=()=>{const n=this.#e.result;t(n?new v(n,this.#e):null)},this.#e.onerror=()=>r(y(this.#e.error)),e!==void 0?this.#t.continue(e):this.#t.continue()})}async continuePrimaryKey(e,t){return new Promise((r,n)=>{this.#e.onsuccess=()=>{const a=this.#e.result;r(a?new v(a,this.#e):null)},this.#e.onerror=()=>n(y(this.#e.error)),this.#t.continuePrimaryKey(e,t)})}async advance(e){return new Promise((t,r)=>{this.#e.onsuccess=()=>{const n=this.#e.result;t(n?new v(n,this.#e):null)},this.#e.onerror=()=>r(y(this.#e.error)),this.#t.advance(e)})}async update(e){return new Promise((t,r)=>{const n=this.#t.update(e);n.onsuccess=()=>t(n.result),n.onerror=()=>r(y(n.error))})}async delete(){return new Promise((e,t)=>{const r=this.#t.delete();r.onsuccess=()=>e(),r.onerror=()=>t(y(r.error))})}}class E{#t;#e;constructor(e,t){this.#t=e,this.#e=t}get native(){return this.#t}getKey(){return this.#t.key}getPrimaryKey(){return this.#t.primaryKey}getDirection(){return L(this.#t.direction)}async continue(e){return new Promise((t,r)=>{this.#e.onsuccess=()=>{const n=this.#e.result;t(n?new E(n,this.#e):null)},this.#e.onerror=()=>r(y(this.#e.error)),e!==void 0?this.#t.continue(e):this.#t.continue()})}async continuePrimaryKey(e,t){return new Promise((r,n)=>{this.#e.onsuccess=()=>{const a=this.#e.result;r(a?new E(a,this.#e):null)},this.#e.onerror=()=>n(y(this.#e.error)),this.#t.continuePrimaryKey(e,t)})}async advance(e){return new Promise((t,r)=>{this.#e.onsuccess=()=>{const n=this.#e.result;t(n?new E(n,this.#e):null)},this.#e.onerror=()=>r(y(this.#e.error)),this.#t.advance(e)})}}function ne(){return{keyPath:null,range:null,anyOfValues:null,filters:[],direction:"ascending",limitCount:null,offsetCount:0}}class m{#t;#e;constructor(e,t){this.#t=e,this.#e=t??ne()}where(e){return new ae(this.#t,{...this.#e,keyPath:e})}filter(e){return new m(this.#t,{...this.#e,filters:[...this.#e.filters,e]})}orderBy(e){return new m(this.#t,{...this.#e,direction:e})}limit(e){return new m(this.#t,{...this.#e,limitCount:e})}offset(e){return new m(this.#t,{...this.#e,offsetCount:e})}async toArray(){const e=[];for await(const t of this.iterate())e.push(t);return e}async first(){const t=await new m(this.#t,{...this.#e,limitCount:1}).iterate().next();return t.done?void 0:t.value}async count(){if(this.#e.filters.length===0&&this.#e.anyOfValues===null){const n=(await this.#t.ensureOpen()).transaction([this.#t.storeName],"readonly").objectStore(this.#t.storeName),o=this.#r(n).count(this.#e.range??void 0);return this.#o(o)}let e=0;for await(const t of this.iterate())e++;return e}async keys(){const e=[],n=(await this.#t.ensureOpen()).transaction([this.#t.storeName],"readonly").objectStore(this.#t.storeName),a=this.#r(n),o=g(this.#e.direction==="ascending"?"next":"previous");if(this.#e.anyOfValues!==null){const p=await this.#i(n);return this.#u(p)}const i=a.openKeyCursor(this.#e.range??void 0,o);let c=0,d=0,h=await this.#o(i);for(;h;){if(c<this.#e.offsetCount){c++,h.continue(),h=await this.#o(i);continue}if(this.#e.limitCount!==null&&d>=this.#e.limitCount)break;if(this.#e.filters.length>0){const p=n.get(h.primaryKey),C=await this.#o(p);C!==void 0&&this.#n(C)&&(e.push(h.primaryKey),d++)}else e.push(h.primaryKey),d++;h.continue(),h=await this.#o(i)}return e}async*iterate(){const r=(await this.#t.ensureOpen()).transaction([this.#t.storeName],"readonly").objectStore(this.#t.storeName);if(this.#e.anyOfValues!==null){const h=await this.#s(r),p=this.#u(h);for(const C of p)yield C;return}const n=this.#r(r),a=g(this.#e.direction==="ascending"?"next":"previous"),o=n.openCursor(this.#e.range??void 0,a);let i=0,c=0,d=await this.#o(o);for(;d;){const h=d.value;if(!this.#n(h)){d.continue(),d=await this.#o(o);continue}if(i<this.#e.offsetCount){i++,d.continue(),d=await this.#o(o);continue}if(this.#e.limitCount!==null&&c>=this.#e.limitCount)break;yield h,c++,d.continue(),d=await this.#o(o)}}#r(e){const t=this.#e.keyPath;if(t===null||t===this.#t.primaryKeyPath)return e;if(this.#t.indexNames.includes(t))return e.index(t);for(const r of this.#t.indexNames)try{const n=e.index(r);if(n.keyPath===t)return n}catch{}return e}#n(e){for(const t of this.#e.filters)if(!t(e))return!1;return!0}async#s(e){if(this.#e.anyOfValues===null)return[];const t=this.#e.keyPath,r=new Map,n=this.#e.anyOfValues.map(async o=>{let i=[];if(t===null||t===this.#t.primaryKeyPath){const c=await this.#o(e.get(o));i=c?[c]:[]}else if(this.#t.indexNames.includes(t)){const c=e.index(t);i=await this.#o(c.getAll(o))}else for(const c of this.#t.indexNames)try{const d=e.index(c);if(d.keyPath===t){i=await this.#o(d.getAll(o));break}}catch{}for(const c of i)if(this.#n(c)){const d=this.#a(c);d!==void 0&&r.set(this.#c(d),c)}});await Promise.all(n);const a=Array.from(r.values());return this.#e.direction==="descending"&&a.reverse(),a}async#i(e){if(this.#e.anyOfValues===null)return[];const t=this.#e.keyPath,r=new Set,n=[],a=this.#e.anyOfValues.map(async o=>{let i;if(t===null||t===this.#t.primaryKeyPath)i=await this.#o(e.count(o))>0?[o]:[];else if(this.#t.indexNames.includes(t)){const c=e.index(t);i=await this.#o(c.getAllKeys(o))}else i=[];for(const c of i){const d=this.#c(c);r.has(d)||(r.add(d),n.push(c))}});return await Promise.all(a),this.#e.direction==="descending"&&n.reverse(),n}#a(e){const t=this.#t.primaryKeyPath;if(!(t===null||typeof e!="object"||e===null))return e[t]}#u(e){let t=e;return this.#e.offsetCount>0&&(t=t.slice(this.#e.offsetCount)),this.#e.limitCount!==null&&(t=t.slice(0,this.#e.limitCount)),t}#o(e){return new Promise((t,r)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>r(y(e.error,{storeName:this.#t.storeName}))})}#c(e){return typeof e=="string"?e:typeof e=="number"?`n:${e}`:e instanceof Date?`d:${e.getTime()}`:e instanceof ArrayBuffer?`b:${Array.from(new Uint8Array(e)).join(",")}`:ArrayBuffer.isView(e)?`b:${Array.from(new Uint8Array(e.buffer)).join(",")}`:Array.isArray(e)?`a:${JSON.stringify(e)}`:JSON.stringify(e)}}class ae{#t;#e;constructor(e,t){this.#t=e,this.#e=t}equals(e){return V(e)?new m(this.#t,{...this.#e,range:IDBKeyRange.only(e)}):this.#r(e,t=>t===e)}#r(e,t){const r=this.#e.keyPath,n=a=>{if(r===null||typeof a!="object"||a===null)return!1;const o=a[r];return t(o)};return new m(this.#t,{...this.#e,keyPath:null,filters:[...this.#e.filters,n]})}greaterThan(e){return new m(this.#t,{...this.#e,range:IDBKeyRange.lowerBound(e,!0)})}greaterThanOrEqual(e){return new m(this.#t,{...this.#e,range:IDBKeyRange.lowerBound(e,!1)})}lessThan(e){return new m(this.#t,{...this.#e,range:IDBKeyRange.upperBound(e,!0)})}lessThanOrEqual(e){return new m(this.#t,{...this.#e,range:IDBKeyRange.upperBound(e,!1)})}between(e,t,r){return new m(this.#t,{...this.#e,range:IDBKeyRange.bound(e,t,r?.lowerOpen??!1,r?.upperOpen??!1)})}startsWith(e){return new m(this.#t,{...this.#e,range:IDBKeyRange.bound(e,e+"ï¿¿",!1,!1)})}anyOf(e){return new m(this.#t,{...this.#e,anyOfValues:e})}}class M{#t;#e;#r;#n;constructor(e,t,r,n){this.#t=e,this.#e=t,this.#r=r,this.#n=n}get native(){throw new Error("Index.native requires active transaction. Use openCursor() or iterate().")}getName(){return this.#e}getKeyPath(){return this.#r.keyPath}isUnique(){return this.#r.unique??!1}isMultiEntry(){return this.#r.multiEntry??!1}async get(e){const a=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return Array.isArray(e)?await Promise.all(e.map(o=>this.#s(a.get(o)))):this.#s(a.get(e))}async resolve(e){const a=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);if(Array.isArray(e))return await Promise.all(e.map(async i=>{const c=await this.#s(a.get(i));if(c===void 0)throw new w(this.#t,i);return c}));const o=await this.#s(a.get(e));if(o===void 0)throw new w(this.#t,e);return o}async getKey(e){const a=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return this.#s(a.getKey(e))}async all(e,t){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return this.#s(o.getAll(e??void 0,t))}async keys(e,t){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return this.#s(o.getAllKeys(e??void 0,t))}async count(e){const a=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return this.#s(a.count(e))}query(){return new m({storeName:this.#t,primaryKeyPath:null,indexNames:[this.#e],ensureOpen:this.#n})}async*iterate(e){const a=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e),o=g(e?.direction),i=a.openCursor(e?.query??null,o);let c=await this.#s(i);for(;c;){yield c.value;const d=new Promise(h=>{i.onsuccess=()=>h(i.result)});c.continue(),c=await d}}async*iterateKeys(e){const a=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e),o=g(e?.direction),i=a.openKeyCursor(e?.query??null,o);let c=await this.#s(i);for(;c;){yield c.key;const d=new Promise(h=>{i.onsuccess=()=>h(i.result)});c.continue(),c=await d}}async openCursor(e){const a=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e),o=g(e?.direction),i=a.openCursor(e?.query??null,o),c=await this.#s(i);return c?new v(c,i):null}async openKeyCursor(e){const a=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e),o=g(e?.direction),i=a.openKeyCursor(e?.query??null,o),c=await this.#s(i);return c?new E(c,i):null}#s(e){return new Promise((t,r)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>r(y(e.error,{storeName:this.#t}))})}}class oe{#t;#e;#r;#n=new Set;constructor(e,t,r){this.#t=e,this.#e=t,this.#r=r}get native(){throw new Error(N.NATIVE_ACCESS_NO_TRANSACTION)}getName(){return this.#e}getKeyPath(){return this.#r.keyPath===void 0?F:this.#r.keyPath}getIndexNames(){return(this.#r.indexes??[]).map(e=>e.name)}hasAutoIncrement(){return this.#r.autoIncrement??_}async get(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);return Array.isArray(e)?await Promise.all(e.map(a=>this.#s(n.get(a)))):this.#s(n.get(e))}async resolve(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);if(Array.isArray(e))return await Promise.all(e.map(async o=>{const i=await this.#s(n.get(o));if(i===void 0)throw new w(this.#e,o);return i}));const a=await this.#s(n.get(e));if(a===void 0)throw new w(this.#e,e);return a}async has(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);return Array.isArray(e)?await Promise.all(e.map(async o=>await this.#s(n.count(o))>0)):await this.#s(n.count(e))>0}async set(e,t){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readwrite"),a=n.objectStore(this.#e);if(Array.isArray(e)){const i=await Promise.all(e.map(c=>this.#s(a.put(c))));return await this.#i(n),this.#a("set",i),i}const o=await this.#s(a.put(e,t));return await this.#i(n),this.#a("set",[o]),o}async add(e,t){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readwrite"),a=n.objectStore(this.#e);if(Array.isArray(e)){const i=await Promise.all(e.map(c=>this.#s(a.add(c))));return await this.#i(n),this.#a("add",i),i}const o=await this.#s(a.add(e,t));return await this.#i(n),this.#a("add",[o]),o}async remove(e){const r=(await this.#t.ensureOpen()).transaction([this.#e],"readwrite"),n=r.objectStore(this.#e);if(Array.isArray(e)){await Promise.all(e.map(a=>this.#s(n.delete(a)))),await this.#i(r),this.#a("remove",e.map(a=>a));return}await this.#s(n.delete(e)),await this.#i(r),this.#a("remove",[e])}async all(e,t){const a=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);return this.#s(a.getAll(e??void 0,t))}async keys(e,t){const a=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);return this.#s(a.getAllKeys(e??void 0,t))}async clear(){const t=(await this.#t.ensureOpen()).transaction([this.#e],"readwrite"),r=t.objectStore(this.#e);await this.#s(r.clear()),await this.#i(t),this.#a("clear",[])}async count(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);return this.#s(n.count(e))}index(e){const r=(this.#r.indexes??[]).find(n=>n.name===e);if(!r)throw new Error(`Index "${e}" not found on store "${this.#e}"`);return new M(this.#e,e,r,()=>this.#t.ensureOpen())}query(){const e=this.getKeyPath();return new m({storeName:this.#e,primaryKeyPath:typeof e=="string"?e:null,indexNames:this.getIndexNames(),ensureOpen:()=>this.#t.ensureOpen()})}async*iterate(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e),a=g(e?.direction),o=n.openCursor(e?.query??null,a);let i=await this.#s(o);for(;i;){yield i.value;const c=new Promise(d=>{o.onsuccess=()=>d(o.result)});i.continue(),i=await c}}async*iterateKeys(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e),a=g(e?.direction),o=n.openKeyCursor(e?.query??null,a);let i=await this.#s(o);for(;i;){yield i.key;const c=new Promise(d=>{o.onsuccess=()=>d(o.result)});i.continue(),i=await c}}async openCursor(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e),a=g(e?.direction),o=n.openCursor(e?.query??null,a),i=await this.#s(o);return i?new v(i,o):null}async openKeyCursor(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e),a=g(e?.direction),o=n.openKeyCursor(e?.query??null,a),i=await this.#s(o);return i?new E(i,o):null}onChange(e){return this.#n.add(e),()=>this.#n.delete(e)}#s(e){return new Promise((t,r)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>r(y(e.error,{storeName:this.#e}))})}#i(e){return new Promise((t,r)=>{e.oncomplete=()=>t(),e.onerror=()=>r(y(e.error)),e.onabort=()=>r(y(e.error))})}#a(e,t){const r={storeName:this.#e,type:e,keys:t,source:"local"};for(const n of this.#n)try{n(r)}catch{}this.#t.emitChange(r)}emitRemoteChange(e){for(const t of this.#n)try{t(e)}catch{}}}class ie{#t;#e;constructor(e,t){this.#t=e,this.#e=t}get native(){return this.#t}async get(e){return Array.isArray(e)?Promise.all(e.map(t=>this.#r(this.#t.get(t)))):this.#r(this.#t.get(e))}async resolve(e){if(Array.isArray(e))return Promise.all(e.map(async r=>{const n=await this.#r(this.#t.get(r));if(n===void 0)throw new w(this.#e,r);return n}));const t=await this.#r(this.#t.get(e));if(t===void 0)throw new w(this.#e,e);return t}async set(e,t){return Array.isArray(e)?Promise.all(e.map(r=>this.#r(this.#t.put(r)))):this.#r(this.#t.put(e,t))}async add(e,t){return Array.isArray(e)?Promise.all(e.map(r=>this.#r(this.#t.add(r)))):this.#r(this.#t.add(e,t))}async remove(e){if(Array.isArray(e)){await Promise.all(e.map(t=>this.#r(this.#t.delete(t))));return}await this.#r(this.#t.delete(e))}async all(e,t){return this.#r(this.#t.getAll(e??void 0,t))}async keys(e,t){return this.#r(this.#t.getAllKeys(e??void 0,t))}async clear(){await this.#r(this.#t.clear())}async count(e){return this.#r(this.#t.count(e))}index(e){if(!this.#t.indexNames.contains(e))throw new Error(`Index "${e}" not found on store "${this.#e}"`);const t=this.#t.index(e),r={name:t.name,keyPath:t.keyPath,unique:t.unique,multiEntry:t.multiEntry},n=this.#t.transaction.db;return new M(this.#e,e,r,()=>Promise.resolve(n))}async openCursor(e){const t=g(e?.direction),r=this.#t.openCursor(e?.query??null,t),n=await this.#r(r);return n?new v(n,r):null}async openKeyCursor(e){const t=g(e?.direction),r=this.#t.openKeyCursor(e?.query??null,t),n=await this.#r(r);return n?new E(n,r):null}#r(e){return new Promise((t,r)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>r(y(e.error,{storeName:this.#e}))})}}class U{#t;#e;#r=!0;#n=!1;constructor(e){this.#t=e,this.#e=Array.from(e.objectStoreNames),e.oncomplete=()=>{this.#r=!1,this.#n=!0},e.onabort=()=>{this.#r=!1,this.#n=!0},e.onerror=()=>{this.#r=!1,this.#n=!0}}get native(){return this.#t}getMode(){return this.#t.mode}getStoreNames(){return this.#e}isActive(){return this.#r}isFinished(){return this.#n}store(e){if(!this.#e.includes(e))throw new b("INVALID_STATE",`Store "${e}" is not in transaction scope. Scoped stores: ${this.#e.join(", ")}`);if(!this.#r)throw new b("TRANSACTION_INACTIVE","Transaction is no longer active");const t=this.#t.objectStore(e);return new ie(t,e)}abort(){if(this.#n)throw new b("INVALID_STATE","Cannot abort: transaction already finished");this.#t.abort(),this.#r=!1,this.#n=!0}commit(){if(this.#n)throw new b("INVALID_STATE","Cannot commit: transaction already finished");typeof this.#t.commit=="function"&&this.#t.commit()}}class ce{#t;#e;#r;#n;#s;#i;#a=null;#u=null;#o=!1;#c=null;#d=new Set;#h=new Set;#m=new Set;#l=new Set;#y=new Map;constructor(e){se(e.name),re(e.version),this.#t=e.name,this.#e=e.version,this.#r=e.stores,this.#n=e.migrations??[],this.#s=e.onBlocked,this.#i=e.crossTabSync!==!1,this.#i&&typeof BroadcastChannel<"u"&&(this.#c=new BroadcastChannel(`idb:${e.name}`),this.#c.onmessage=t=>{this.#g(t.data)}),this.#t=e.name,this.#e=e.version,this.#r=e.stores,this.#n=e.migrations??[],this.#s=e.onBlocked,e.onChange&&this.#d.add(e.onChange),e.onError&&this.#h.add(e.onError),e.onVersionChange&&this.#m.add(e.onVersionChange),e.onClose&&this.#l.add(e.onClose)}get native(){if(!this.#a)throw new A(N.DATABASE_NOT_OPEN);return this.#a}getName(){return this.#t}getVersion(){return this.#e}getStoreNames(){return this.#a?Array.from(this.#a.objectStoreNames):Object.keys(this.#r)}isOpen(){return this.#a!==null&&!this.#o}store(e){if(!(e in this.#r))throw new A(N.STORE_NOT_FOUND(e));let t=this.#y.get(e);return t||(t=new oe(this,e,this.#r[e]),this.#y.set(e,t)),t}async read(e,t){const r=await this.ensureOpen(),n=R(e),a=r.transaction([...n],"readonly"),o=new U(a);try{await t(o),await q(a)}catch(i){if(o.isActive())try{o.abort()}catch{}throw i}}async write(e,t,r){const n=await this.ensureOpen(),a=R(e),o=r?.durability?{durability:r.durability}:void 0,i=[...a],c=o?n.transaction(i,"readwrite",o):n.transaction(i,"readwrite"),d=new U(c);try{await t(d),await q(c)}catch(h){if(d.isActive())try{d.abort()}catch{}throw h}}close(){this.#c&&(this.#c.close(),this.#c=null),this.#a&&(this.#a.close(),this.#a=null),this.#o=!0,this.#u=null;for(const e of this.#l)try{e()}catch{}}async drop(){return this.close(),new Promise((e,t)=>{const r=indexedDB.deleteDatabase(this.#t);r.onsuccess=()=>e(),r.onerror=()=>t(y(r.error)),r.onblocked=()=>{}})}onChange(e){return this.#d.add(e),()=>this.#d.delete(e)}onError(e){return this.#h.add(e),()=>this.#h.delete(e)}onVersionChange(e){return this.#m.add(e),()=>this.#m.delete(e)}onClose(e){return this.#l.add(e),()=>this.#l.delete(e)}async ensureOpen(){if(this.#o)throw new A(N.DATABASE_CLOSED);if(this.#a)return this.#a;if(this.#u)return this.#u;this.#u=this.#w();try{return this.#a=await this.#u,this.#a}catch(e){throw this.#u=null,e}}emitChange(e){for(const t of this.#d)try{t(e)}catch(r){this.#f(r instanceof Error?r:new Error(String(r)))}if(e.source==="local"&&this.#c)try{this.#c.postMessage(e)}catch{}}#g(e){const t={...e,source:"remote"};for(const n of this.#d)try{n(t)}catch(a){this.#f(a instanceof Error?a:new Error(String(a)))}const r=this.#y.get(e.storeName);r&&r.emitRemoteChange(t)}async#w(){return new Promise((e,t)=>{const r=indexedDB.open(this.#t,this.#e);r.onerror=()=>{t(new Q(`Failed to open database "${this.#t}"`,r.error))},r.onsuccess=()=>{const n=r.result;this.#p(n),e(n)},r.onupgradeneeded=n=>{const a=r.result,o=r.transaction;if(!o){t(new I("UPGRADE_FAILED","No transaction available during upgrade"));return}try{this.#b(a,o,n.oldVersion,n.newVersion??this.#e)}catch(i){o.abort(),t(i instanceof I?i:new I("UPGRADE_FAILED",i instanceof Error?i.message:"Upgrade failed",i))}},r.onblocked=n=>{this.#s&&this.#s({oldVersion:n.oldVersion,newVersion:n.newVersion??this.#e})}})}#p(e){e.onversionchange=t=>{for(const r of this.#m)try{r({oldVersion:t.oldVersion,newVersion:t.newVersion})}catch{}},e.onclose=()=>{this.#a=null,this.#o=!0;for(const t of this.#l)try{t()}catch{}},e.onerror=t=>{const n=t.target?.error??new Error("Unknown database error");this.#f(n instanceof Error?n:new Error(String(n)))}}#b(e,t,r,n){for(const[o,i]of Object.entries(this.#r))e.objectStoreNames.contains(o)||this.#x(e,o,i);const a=this.#n.filter(o=>o.version>r&&o.version<=n).sort((o,i)=>o.version-i.version);for(const o of a)o.migrate({database:e,transaction:t,oldVersion:r,newVersion:n})}#x(e,t,r){const n=r.keyPath===void 0?F:r.keyPath,o={autoIncrement:r.autoIncrement??_};n!==null&&(o.keyPath=n);const i=e.createObjectStore(t,o);for(const c of r.indexes??[])this.#v(i,c)}#v(e,t){e.createIndex(t.name,t.keyPath,{unique:t.unique??!1,multiEntry:t.multiEntry??!1})}#f(e){for(const t of this.#h)try{t(e)}catch{}}}function ue(s){return new ce(s)}function de(){return ue({name:"showcase-db",version:1,stores:{users:{indexes:[{name:"byEmail",keyPath:"email",unique:!0},{name:"byStatus",keyPath:"status"},{name:"byRole",keyPath:"role"},{name:"byAge",keyPath:"age"},{name:"byTags",keyPath:"tags",multiEntry:!0},{name:"byCreatedAt",keyPath:"createdAt"}]},posts:{indexes:[{name:"byAuthor",keyPath:"authorId"},{name:"byPublished",keyPath:"published"},{name:"byViews",keyPath:"views"},{name:"byCreatedAt",keyPath:"createdAt"}]},settings:{indexes:[{name:"byKey",keyPath:"key",unique:!0},{name:"byUpdatedAt",keyPath:"updatedAt"}]}},crossTabSync:!0})}async function le(s){const e=s.store("users"),t=await e.get("u1"),r=await e.get("nonexistent"),n=["u1","u2","nonexistent"],a=await e.get(n);return{success:!0,message:"get() returns undefined for missing records",data:{single:t?.name??"undefined",missing:r===void 0?"undefined (as expected)":"found",batch:a.map(o=>o?.name??"undefined")},code:`
// Single key lookup - returns T | undefined
const user = await store.get('u1')
if (user) {
  console.log(user.name)  // Safe to access
}

// Missing key returns undefined (no error)
const missing = await store.get('nonexistent')  // undefined

// Batch lookup - some may be undefined
const users = await store.get(['u1', 'u2', 'nonexistent'])
// users[2] is undefined
`.trim()}}async function he(s){const e=s.store("users");let t="";const r=await e.resolve("u1");try{await e.resolve("nonexistent")}catch(n){k(n)&&(t=`NotFoundError: Key "${JSON.stringify(n.key)}" not found in "${n.storeName}"`)}return{success:!0,message:"resolve() throws NotFoundError for missing records",data:{found:r.name,error:t},code:`
// resolve() throws if record doesn't exist
try {
  const user = await store.resolve('u1')
  console.log(user.name)  // Guaranteed to exist
} catch (error) {
  if (error instanceof NotFoundError) {
    console.log(\`Key \${error.key} not found in \${error.storeName}\`)
  }
}

// Batch resolve - throws if ANY is missing
const users = await store.resolve(['u1', 'u2', 'u3'])
`.trim()}}async function me(s){const e=s.store("users"),t=await e.set({id:"demo-user",name:"Demo User",email:"demo@example.com",age:30,status:"active",role:"user",tags:["demo"],createdAt:Date.now()});await e.set({id:"demo-user",name:"Demo User (Updated)",email:"demo@example.com",age:31,status:"active",role:"user",tags:["demo","updated"],createdAt:Date.now()});const r=await e.set([...B]);return await e.remove("demo-user"),{success:!0,message:"set() upserts records (insert or update)",data:{singleKey:t,batchKeys:r},code:`
// Single record - insert or update (upsert)
const key = await store.set({ id: 'u1', name: 'Alice', ... })

// Update existing record (same key)
await store.set({ id: 'u1', name: 'Alice (Updated)', ... })

// Batch set - single transaction, atomic
const keys = await store.set([user1, user2, user3])
`.trim()}}async function ye(s){const e=s.store("users");let t="";const r={id:"new-user",name:"New User",email:"new@example.com",age:25,status:"active",role:"guest",tags:["new"],createdAt:Date.now()},n=await e.add(r);try{await e.add(r)}catch(a){O(a)&&(t=`ConstraintError: Key "${JSON.stringify(a.key)}" already exists`)}return await e.remove("new-user"),{success:!0,message:"add() throws ConstraintError if key exists",data:{addedKey:n,duplicateError:t},code:`
// add() inserts only - throws if key exists
try {
  await store.add({ id: 'u1', name: 'Alice' })
} catch (error) {
  if (error instanceof ConstraintError) {
    console.log('User already exists, updating instead')
    await store.set({ id: 'u1', name: 'Alice' })
  }
}

// Batch add - fails if ANY key exists
await store.add([user1, user2, user3])
`.trim()}}async function fe(s){const e=s.store("users");await e.set({id:"to-delete",name:"To Delete",email:"delete@example.com",age:0,status:"inactive",role:"guest",tags:[],createdAt:Date.now()});const t=await e.count();await e.remove("to-delete"),await e.remove("nonexistent");const r=await e.count();return{success:!0,message:"remove() silently succeeds for missing keys",data:{beforeCount:t,afterCount:r,difference:t-r},code:`
// Single key remove
await store.remove('u1')

// Removing nonexistent key - no error
await store.remove('nonexistent')  // Silently succeeds

// Batch remove
await store.remove(['u1', 'u2', 'u3'])
`.trim()}}async function ge(s){const e=s.store("users"),t=await e.has("u1"),r=await e.has("nonexistent"),n=await e.has(["u1","u2","nonexistent"]);return{success:!0,message:"has() checks if records exist",data:{exists:t,missing:r,batchChecks:n},code:`
// Single key existence check
const exists = await store.has('u1')  // true

// Missing key
const missing = await store.has('nonexistent')  // false

// Batch check
const checks = await store.has(['u1', 'u2', 'nonexistent'])
// [true, true, false]
`.trim()}}async function we(s){const e=s.store("users"),t=await e.all(),r=await e.all(null,3),n=await e.keys(),a=await e.count();return{success:!0,message:"Bulk operations: all(), keys(), count()",data:{allCount:t.length,first3Names:r.map(o=>o.name),allKeys:n,count:a},code:`
// Get all records
const allUsers = await store.all()

// Get all with limit
const first3 = await store.all(null, 3)

// With key range
const range = IDBKeyRange.bound('a', 'z')
const subset = await store.all(range)

// Get all keys
const allKeys = await store.keys()

// Count records
const count = await store.count()

// Clear all records (dangerous!)
// await store.clear()
`.trim()}}function pe(s){const e=s.store("users");return{success:!0,message:"Store accessor methods",data:{name:e.getName(),keyPath:e.getKeyPath(),indexNames:e.getIndexNames(),autoIncrement:e.hasAutoIncrement()},code:`
const store = db.store('users')

store.getName()           // 'users'
store.getKeyPath()        // 'id'
store.getIndexNames()     // ['byEmail', 'byStatus', ...]
store.hasAutoIncrement()  // false
`.trim()}}function be(s){const e=s.store("users"),t=e.index("byEmail"),r=e.index("byStatus"),n=e.index("byTags");return{success:!0,message:"Index accessor methods",data:{emailIndex:{name:t.getName(),keyPath:t.getKeyPath(),unique:t.isUnique(),multiEntry:t.isMultiEntry()},statusIndex:{name:r.getName(),keyPath:r.getKeyPath(),unique:r.isUnique(),multiEntry:r.isMultiEntry()},tagsIndex:{name:n.getName(),keyPath:n.getKeyPath(),unique:n.isUnique(),multiEntry:n.isMultiEntry()}},code:`
const emailIndex = store.index('byEmail')

emailIndex.getName()      // 'byEmail'
emailIndex.getKeyPath()   // 'email'
emailIndex.isUnique()     // true
emailIndex.isMultiEntry() // false

// Multi-entry index for arrays
const tagsIndex = store.index('byTags')
tagsIndex.isMultiEntry()  // true
`.trim()}}async function xe(s){const t=s.store("users").index("byEmail"),r=await t.get("alice@example.com"),n=await t.get("nonexistent@example.com");let a="";try{await t.resolve("nonexistent@example.com")}catch{a="NotFoundError thrown as expected"}const o=await t.getKey("alice@example.com");return{success:!0,message:"Index lookup operations",data:{userByEmail:r?.name??"not found",missing:n===void 0?"undefined (correct)":"found",resolveError:a,primaryKey:o},code:`
const emailIndex = store.index('byEmail')

// Get by index key (returns first match)
const user = await emailIndex.get('alice@example.com')

// Returns undefined for missing
const missing = await emailIndex.get('nonexistent@example.com')  // undefined

// resolve throws for missing
const user = await emailIndex.resolve('alice@example.com')  // Throws if not found

// Get primary key for an index key
const primaryKey = await emailIndex.getKey('alice@example.com')  // 'u1'
`.trim()}}async function ve(s){const t=s.store("users").index("byStatus"),r=await t.all(IDBKeyRange.only("active")),n=await t.all(IDBKeyRange.only("inactive")),a=await t.count("active"),o=await t.count("inactive");return{success:!0,message:"Non-unique index queries",data:{activeUsers:r.map(i=>i.name),inactiveUsers:n.map(i=>i.name),activeCount:a,inactiveCount:o},code:`
const statusIndex = store.index('byStatus')

// Get all matching a specific value
const activeUsers = await statusIndex.all(IDBKeyRange.only('active'))

// Count records with specific index value
const activeCount = await statusIndex.count('active')
const inactiveCount = await statusIndex.count('inactive')
`.trim()}}async function Ee(s){const t=s.store("users").index("byTags"),r=await t.all(IDBKeyRange.only("developer")),n=await t.all(IDBKeyRange.only("designer"));return{success:!0,message:"Multi-entry index for arrays",data:{developersCount:r.length,developers:r.map(a=>({name:a.name,tags:a.tags})),designersCount:n.length,designers:n.map(a=>({name:a.name,tags:a.tags}))},code:`
// Multi-entry index indexes each array element separately
// User: { tags: ['developer', 'leader'] }
// Creates index entries for both 'developer' AND 'leader'

const tagsIndex = store.index('byTags')  // multiEntry: true

// Find all users with 'developer' tag
const developers = await tagsIndex.all(IDBKeyRange.only('developer'))

// Find all users with 'designer' tag
const designers = await tagsIndex.all(IDBKeyRange.only('designer'))
`.trim()}}async function Ce(s){const t=s.store("users").index("byAge"),r=await t.all(IDBKeyRange.lowerBound(30)),n=await t.all(IDBKeyRange.upperBound(30,!0)),a=await t.all(IDBKeyRange.bound(25,35));return{success:!0,message:"Index range queries",data:{over30:r.map(o=>({name:o.name,age:o.age})),under30:n.map(o=>({name:o.name,age:o.age})),between25And35:a.map(o=>({name:o.name,age:o.age}))},code:`
const ageIndex = store.index('byAge')

// Users over 30
const over30 = await ageIndex.all(IDBKeyRange.lowerBound(30))

// Users under 30 (exclusive)
const under30 = await ageIndex.all(IDBKeyRange.upperBound(30, true))

// Users between 25 and 35 (inclusive)
const between25And35 = await ageIndex.all(IDBKeyRange.bound(25, 35))
`.trim()}}function Ae(s){const r=s.store("users").index("byEmail").native;return{success:!0,message:"Native IDBIndex access",data:{nativeName:r.name,nativeKeyPath:r.keyPath,nativeUnique:r.unique,nativeMultiEntry:r.multiEntry},code:`
const emailIndex = store.index('byEmail')

// Access native IDBIndex for advanced operations
const nativeIndex = emailIndex.native

// Use native APIs
nativeIndex.name        // 'byEmail'
nativeIndex.keyPath     // 'email'
nativeIndex.unique      // true
nativeIndex.multiEntry  // false
`.trim()}}async function Ne(s){const e=s.store("users"),t=await e.query().where("byStatus").equals("active").toArray(),r=await e.query().where("byRole").equals("admin").toArray();return{success:!0,message:"where().equals() - Fast indexed queries",data:{activeUsers:t.map(n=>n.name),admins:r.map(n=>n.name)},code:`
// Fast indexed query using where().equals()
const activeUsers = await store.query()
  .where('byStatus').equals('active')
  .toArray()

// Query by role
const admins = await store.query()
  .where('byRole').equals('admin')
  .toArray()

// Note: Uses IDBKeyRange.only() internally for performance
`.trim()}}async function De(s){const e=s.store("users"),t=await e.query().where("byAge").greaterThan(30).toArray(),r=await e.query().where("byAge").lessThanOrEqual(30).toArray(),n=await e.query().where("byAge").between(25,35).toArray(),a=await e.query().where("byAge").between(25,35,{lowerOpen:!0,upperOpen:!0}).toArray();return{success:!0,message:"Comparison queries: greaterThan, lessThan, between",data:{over30:t.map(o=>({name:o.name,age:o.age})),under30:r.map(o=>({name:o.name,age:o.age})),between25And35:n.map(o=>({name:o.name,age:o.age})),between25And35Exclusive:a.map(o=>({name:o.name,age:o.age}))},code:`
// Greater than (exclusive)
const over30 = await store.query()
  .where('byAge').greaterThan(30)
  .toArray()

// Less than or equal (inclusive)
const under30 = await store.query()
  .where('byAge').lessThanOrEqual(30)
  .toArray()

// Between (inclusive by default)
const between = await store.query()
  .where('byAge').between(25, 35)
  .toArray()

// With exclusivity options
const betweenExclusive = await store.query()
  .where('byAge').between(25, 35, { lowerOpen: true, upperOpen: true })
  .toArray()
`.trim()}}async function Ie(s){return{success:!0,message:"startsWith() - String prefix queries",data:{aEmails:(await s.store("users").query().where("byEmail").startsWith("a").toArray()).map(r=>({name:r.name,email:r.email}))},code:`
// String prefix query
const aEmails = await store.query()
  .where('byEmail').startsWith('a')  // 'alice@...', 'adam@...', etc.
  .toArray()

// Uses IDBKeyRange.bound(prefix, prefix + '\\uffff')
`.trim()}}async function Te(s){return{success:!0,message:"anyOf() - Multiple value queries",data:{adminOrUser:(await s.store("users").query().where("byRole").anyOf(["admin","user"]).toArray()).map(r=>({name:r.name,role:r.role}))},code:`
// Find records matching any of multiple values
const adminOrUser = await store.query()
  .where('byRole').anyOf(['admin', 'user'])
  .toArray()

// Executes parallel queries and merges results
// Results are deduplicated by primary key
`.trim()}}async function Se(s){const e=s.store("users"),t=await e.query().filter(a=>a.email.endsWith("@example.com")).toArray(),r=await e.query().filter(a=>a.age>=30&&a.status==="active").toArray(),n=await e.query().filter(a=>/^[A-D]/.test(a.name)).toArray();return{success:!0,message:"filter() - Flexible post-cursor filtering",data:{gmailUsers:t.map(a=>a.email),activeAdults:r.map(a=>({name:a.name,age:a.age})),namePattern:n.map(a=>a.name)},code:`
// Filter for conditions that can't use indexes
const gmailUsers = await store.query()
  .filter(u => u.email.endsWith('@gmail.com'))
  .toArray()

// Complex conditions
const activeAdults = await store.query()
  .filter(u => u.age >= 30 && u.status === 'active')
  .toArray()

// Regex matching
const pattern = await store.query()
  .filter(u => /^J.*n$/.test(u.name))
  .toArray()
`.trim()}}async function ke(s){return{success:!0,message:"Combining where() and filter() for optimal performance",data:{activeWithE:(await s.store("users").query().where("byStatus").equals("active").filter(r=>r.name.includes("a")).toArray()).map(r=>r.name)},code:`
// Best practice: narrow with index first, then filter
const results = await store.query()
  .where('byStatus').equals('active')  // Fast: uses index
  .filter(u => u.email.endsWith('@gmail.com'))  // Then: post-filter
  .toArray()

// This is more efficient than filtering all records
`.trim()}}async function Oe(s){const e=s.store("users"),t=await e.query().where("byAge").greaterThanOrEqual(0).orderBy("ascending").toArray(),r=await e.query().where("byAge").greaterThanOrEqual(0).orderBy("descending").toArray(),n=await e.query().limit(2).offset(0).toArray(),a=await e.query().limit(2).offset(2).toArray();return{success:!0,message:"orderBy() and limit/offset pagination",data:{ascending:t.map(o=>({name:o.name,age:o.age})),descending:r.map(o=>({name:o.name,age:o.age})),page1:n.map(o=>o.name),page2:a.map(o=>o.name)},code:`
// Ascending order (default)
const ascending = await store.query()
  .where('byAge').greaterThanOrEqual(0)
  .orderBy('ascending')
  .toArray()

// Descending order
const descending = await store.query()
  .orderBy('descending')
  .toArray()

// Pagination
const page1 = await store.query().limit(10).offset(0).toArray()
const page2 = await store.query().limit(10).offset(10).toArray()
`.trim()}}async function Pe(s){const e=s.store("users"),t=await e.query().where("byStatus").equals("active").toArray(),r=await e.query().where("byStatus").equals("active").first(),n=await e.query().where("byStatus").equals("active").count(),a=await e.query().where("byStatus").equals("active").keys();return{success:!0,message:"Terminal operations: toArray, first, count, keys",data:{allCount:t.length,first:r?.name??"none",count:n,keys:a},code:`
// Get all matching records
const records = await query.toArray()

// Get first match only (more efficient)
const first = await query.first()

// Count matches (without loading data)
const count = await query.count()

// Get keys only (more efficient than full records)
const keys = await query.keys()

// Memory-efficient iteration
for await (const record of query.iterate()) {
  processRecord(record)
  if (done) break  // Early termination supported
}
`.trim()}}async function qe(s){const e=s.store("users"),t=[];for await(const n of e.query().where("byStatus").equals("active").iterate())t.push(n.name);let r;for await(const n of e.query().iterate())if(n.status==="active"){r=n.name;break}return{success:!0,message:"iterate() - Memory-efficient async generator",data:{iteratedNames:t,firstActive:r},code:`
// Memory-efficient iteration
for await (const user of store.query().iterate()) {
  processUser(user)
  if (done) break  // Clean early termination
}

// Only one record in memory at a time
// Great for large datasets
`.trim()}}async function Re(s){const e=s.store("posts"),t=await e.query().where("byPublished").equals(!0).toArray(),r=await e.query().where("byPublished").equals(!1).toArray();return{success:!0,message:"Boolean queries - Automatic fallback to filter",data:{publishedPosts:t.map(n=>n.title),draftPosts:r.map(n=>n.title)},code:`
// Boolean values are NOT valid IndexedDB keys
// The library automatically handles this

const published = await store.query()
  .where('byPublished').equals(true)  // Works! Falls back to filter
  .toArray()

// This is equivalent to:
const published = await store.query()
  .filter(post => post.published === true)
  .toArray()

// For better performance, consider storing as 0/1 instead
`.trim()}}async function Ue(s){let e=0,t=0,r="";return await s.read(["users","posts"],async n=>{const a=await n.store("users").all(),o=await n.store("posts").all();e=a.length,t=o.length,r=a[0]?.name??"none"}),{success:!0,message:"db.read() - Consistent reads across stores",data:{userCount:e,postCount:t,firstUser:r},code:`
// Read transaction - consistent view
await db.read(['users', 'posts'], async (tx) => {
  const users = await tx.store('users').all()
  const posts = await tx.store('posts').all()
  // Both reads see the same snapshot
})

// Single store reads can use store directly
const user = await db.store('users').get('u1')
`.trim()}}async function Be(s){await s.store("posts").set([...K]);let e="",t="";return await s.write(["users","posts"],async r=>{const n=await r.store("users").resolve("u1");t=n.name;const a={id:"tx-post",title:"Transaction Demo Post",content:"Created in a transaction",authorId:n.id,published:!0,views:0,createdAt:Date.now()};await r.store("posts").set(a),e=a.id}),await s.store("posts").remove("tx-post"),{success:!0,message:"db.write() - Atomic multi-store modifications",data:{createdPostId:e,authorName:t},code:`
// Write transaction - atomic modifications
await db.write(['users', 'posts'], async (tx) => {
  const user = await tx.store('users').resolve('u1')

  await tx.store('posts').set({
    id: crypto.randomUUID(),
    title: 'New Post',
    authorId: user.id,
    // ...
  })

  // Transaction commits on success
  // Aborts on any error (all changes rolled back)
})
`.trim()}}async function Ke(s){return await s.write(["settings"],async e=>{await e.store("settings").set({id:"durability-test",key:"test",value:"relaxed",updatedAt:Date.now()})},{durability:"relaxed"}),await s.store("settings").remove("durability-test"),{success:!0,message:"Transaction durability options",data:{durabilityLevels:["default","strict","relaxed"]},code:`
// Durability options control when transaction is considered complete

// 'default' - OS/browser default behavior
await db.write(['logs'], async (tx) => {
  await tx.store('logs').set(entry)
})

// 'strict' - Wait for data to be flushed to disk
await db.write(['critical'], async (tx) => {
  await tx.store('critical').set(data)
}, { durability: 'strict' })

// 'relaxed' - May return before data is flushed (faster)
await db.write(['logs'], async (tx) => {
  await tx.store('logs').set(entry)
}, { durability: 'relaxed' })
`.trim()}}async function Fe(s){let e="",t=[],r=!1;return await s.read(["users","posts"],n=>{e=n.getMode(),t=n.getStoreNames(),r=n.isActive()}),{success:!0,message:"Transaction accessor methods",data:{mode:e,storeNames:t,isActive:r},code:`
await db.read(['users', 'posts'], async (tx) => {
  tx.getMode()         // 'readonly' | 'readwrite'
  tx.getStoreNames()   // ['users', 'posts']
  tx.isActive()        // true (while in operation)
  tx.isFinished()      // false (until complete/abort)
})
`.trim()}}async function _e(s){const e=await s.store("settings").count();let t=!1;try{await s.write(["settings"],async n=>{await n.store("settings").set({id:"abort-test",key:"abort",value:"should be rolled back",updatedAt:Date.now()}),n.abort()})}catch{t=!0}const r=await s.store("settings").count();return{success:!0,message:"Transaction abort - rolls back all changes",data:{beforeCount:e,afterCount:r,errorCaught:t,recordsAdded:r-e},code:`
await db.write(['users'], async (tx) => {
  await tx.store('users').set(user1)
  await tx.store('users').set(user2)

  if (someCondition) {
    tx.abort()  // Roll back ALL changes
  }
})

// Also aborts on any thrown error:
await db.write(['users'], async (tx) => {
  await tx.store('users').set(user)
  throw new Error('Something went wrong')
  // Transaction is automatically aborted
})
`.trim()}}async function Ve(s){let e="";return await s.read(["users"],t=>{e=t.native.mode}),{success:!0,message:"Native IDBTransaction access",data:{nativeMode:e},code:`
await db.write(['users'], async (tx) => {
  // Access native IDBTransaction
  const nativeTx = tx.native

  // Use native APIs when needed
  nativeTx.mode           // 'readonly' | 'readwrite'
  nativeTx.objectStoreNames  // DOMStringList
  nativeTx.db             // IDBDatabase
})
`.trim()}}async function Le(s){const e=s.store("users"),t=[];for await(const n of e.iterate())t.push(n.name);const r=[];for await(const n of e.iterate({direction:"previous"}))r.push(n.name);return{success:!0,message:"iterate() - Memory-efficient async generator",data:{names:t,reversedNames:r},code:`
// Simple iteration
for await (const user of store.iterate()) {
  console.log(user.name)
}

// With options
for await (const user of store.iterate({
  direction: 'previous',  // Reverse order
  query: IDBKeyRange.bound('a', 'm')  // Filter by key range
})) {
  console.log(user.name)
}

// Early termination is clean
for await (const user of store.iterate()) {
  if (found) break  // Resources properly cleaned up
}
`.trim()}}async function Me(s){const e=s.store("users"),t=[];for await(const r of e.iterateKeys())t.push(JSON.stringify(r));return{success:!0,message:"iterateKeys() - Efficient key-only iteration",data:{keys:t},code:`
// Key-only iteration - more efficient than full records
for await (const key of store.iterateKeys()) {
  console.log(key)
}

// Use when you only need keys, not full records
// Doesn't load record data = less memory, faster
`.trim()}}async function je(s){const e=s.store("users"),t=[];let r=await e.openCursor();for(;r;)t.push({key:r.getKey(),name:r.getValue().name}),r=await r.continue();return{success:!0,message:"openCursor() - Manual cursor control",data:{recordCount:t.length,records:t},code:`
// Manual cursor for full control
let cursor = await store.openCursor()

while (cursor) {
  const key = cursor.getKey()
  const primaryKey = cursor.getPrimaryKey()
  const value = cursor.getValue()
  const direction = cursor.getDirection()

  console.log(\`\${key}: \${value.name}\`)

  cursor = await cursor.continue()
}
`.trim()}}async function $e(s){await s.store("users").set({id:"cursor-test-1",name:"Cursor Test User 1",email:"cursor1@test.com",age:99,status:"inactive",role:"guest",tags:["test"],createdAt:Date.now()}),await s.store("users").set({id:"cursor-test-2",name:"Cursor Test User 2",email:"cursor2@test.com",age:98,status:"inactive",role:"guest",tags:["test"],createdAt:Date.now()});let e=0,t=0;return await s.write(["users"],async r=>{let n=await r.store("users").openCursor();for(;n;){const a=n.getValue();a.id==="cursor-test-1"?(await n.update({...a,name:"Updated via Cursor"}),e++):a.id==="cursor-test-2"&&(await n.delete(),t++),n=await n.continue()}}),await s.store("users").remove("cursor-test-1"),{success:!0,message:"Cursor mutation - Update and delete during iteration",data:{updated:e,deleted:t},code:`
// Use write transaction for cursor mutations
await db.write(['users'], async (tx) => {
  let cursor = await tx.store('users').openCursor()

  while (cursor) {
    const user = cursor.getValue()

    if (user.status === 'inactive') {
      // Delete during iteration
      await cursor.delete()
    } else if (user.needsUpdate) {
      // Update during iteration
      await cursor.update({ ...user, updatedAt: Date.now() })
    }

    cursor = await cursor.continue()
  }
})
`.trim()}}async function Ge(s){const e=s.store("users"),t=[];let r=await e.openCursor();r&&(t.push(r.getValue().name),r=await r.continue(),r&&t.push(r.getValue().name));const n=[];return r=await e.openCursor(),r&&(n.push(r.getValue().name),r=await r.advance(2),r&&n.push(`(after skip 2) ${r.getValue().name}`)),{success:!0,message:"Cursor navigation methods",data:{continued:t,advanced:n},code:`
let cursor = await store.openCursor()

// Continue to next record
cursor = await cursor.continue()

// Continue to specific key
cursor = await cursor.continue('u5')

// Skip N records
cursor = await cursor.advance(5)

// For index cursors: continue to specific primary key
// cursor = await cursor.continuePrimaryKey(indexKey, primaryKey)
`.trim()}}async function He(s){const e=s.store("users"),t=[];for await(const n of e.iterate({direction:"next"}))t.push(n.name);const r=[];for await(const n of e.iterate({direction:"previous"}))r.push(n.name);return{success:!0,message:"Cursor directions",data:{forward:t,backward:r,directions:["next","nextunique","previous","previousunique"]},code:`
// Direction options:
// 'next'           - Ascending, include duplicates (default)
// 'nextunique'     - Ascending, skip duplicates
// 'previous'       - Descending, include duplicates
// 'previousunique' - Descending, skip duplicates

for await (const user of store.iterate({ direction: 'previous' })) {
  console.log(user.name)  // Reverse order
}
`.trim()}}async function We(s){const e=s.store("users"),t=[];let r=await e.openKeyCursor();for(;r;)t.push(JSON.stringify(r.getKey())),r=await r.continue();return{success:!0,message:"Key cursor - Efficient key-only access",data:{keys:t},code:`
// Key cursor doesn't load record values
// More efficient when you only need keys

let keyCursor = await store.openKeyCursor()

while (keyCursor) {
  const key = keyCursor.getKey()
  const primaryKey = keyCursor.getPrimaryKey()
  const direction = keyCursor.getDirection()

  console.log(key)

  keyCursor = await keyCursor.continue()
}
`.trim()}}async function Qe(s){const t=s.store("users").index("byStatus"),r=[];for await(const n of t.iterate({query:IDBKeyRange.only("active")}))r.push({indexKey:"active",primaryKey:n.id,name:n.name});return{success:!0,message:"Index cursors - Iterate through index",data:{activeUsers:r},code:`
const statusIndex = store.index('byStatus')

// Iterate through index
for await (const user of statusIndex.iterate({
  query: IDBKeyRange.only('active')
})) {
  console.log(user.name)
}

// Manual index cursor
let cursor = await statusIndex.openCursor()
while (cursor) {
  // cursor.getKey() returns index key
  // cursor.getPrimaryKey() returns primary key
  // cursor.getValue() returns full record
  cursor = await cursor.continue()
}
`.trim()}}const x=[];async function Je(s){x.length=0;const e=[],t=s.onChange(r=>{x.push({...r,timestamp:Date.now()})});return e.push(t),await s.store("settings").set({id:"event-test",key:"test",value:"trigger-change",updatedAt:Date.now()}),await s.store("settings").remove("event-test"),await new Promise(r=>setTimeout(r,50)),e.forEach(r=>r()),{success:!0,message:"db.onChange() - Database-level change events",data:{events:x.map(r=>({storeName:r.storeName,type:r.type,keys:r.keys,source:r.source}))},code:`
// Subscribe to all changes across all stores
const unsubscribe = db.onChange((event) => {
  console.log(\`\${event.storeName}: \${event.type}\`, event.keys)

  if (event.source === 'remote') {
    // Change from another tab
    refreshUI()
  }
})

// Event structure:
// {
//   storeName: string,      // Store that changed
//   type: 'set' | 'add' | 'remove' | 'clear',
//   keys: ValidKey[],       // Affected keys
//   source: 'local' | 'remote'  // Origin
// }

// Cleanup when done
unsubscribe()
`.trim()}}async function ze(s){x.length=0;const e=[],t=s.store("settings").onChange(r=>{x.push({...r,timestamp:Date.now()})});return e.push(t),await s.store("settings").set({id:"store-event-test",key:"test",value:"store-level",updatedAt:Date.now()}),await s.store("users").set({id:"no-trigger",name:"No Trigger",email:"no@trigger.com",age:0,status:"inactive",role:"guest",tags:[],createdAt:Date.now()}),await new Promise(r=>setTimeout(r,50)),await s.store("settings").remove("store-event-test"),await s.store("users").remove("no-trigger"),e.forEach(r=>r()),{success:!0,message:"store.onChange() - Store-level change events",data:{settingsEvents:x.length,events:x.map(r=>({type:r.type,keys:r.keys}))},code:`
// Subscribe to specific store changes only
const unsubscribe = db.store('users').onChange((event) => {
  if (event.type === 'set') {
    invalidateCache(event.keys)
  }
})

// Only triggers for changes to this store
// More efficient than database-level when targeting one store

unsubscribe()
`.trim()}}function Ye(s){return{success:!0,message:"Cross-tab synchronization via BroadcastChannel",data:{crossTabSyncEnabled:!0,howToTest:"Open this page in another tab and make changes"},code:`
// Cross-tab sync is enabled by default
const db = createDatabase<AppSchema>({
  name: 'myApp',
  version: 1,
  stores: { users: {} },
  crossTabSync: true  // Default: true
})

// Changes in Tab 1
await db.store('users').set({ id: 'u1', name: 'Alice' })

// Tab 2 receives change event with source: 'remote'
db.onChange((event) => {
  if (event.source === 'remote') {
    console.log('Another tab made changes:', event)
    refreshUI()
  }
})

// Disable if not needed (saves resources)
const db = createDatabase({
  // ...
  crossTabSync: false
})
`.trim()}}function Xe(s){const e=[];return s.onError(r=>{e.push(r.message)})(),{success:!0,message:"db.onError() - Error event handling",data:{subscribedToErrors:!0,note:"Errors are captured for logging/analytics"},code:`
// Subscribe to error events
const unsubscribe = db.onError((error) => {
  console.error('Database error:', error)
  reportToAnalytics(error)
})

// Useful for:
// - Centralized error logging
// - Analytics
// - User notifications
// - Error recovery strategies

unsubscribe()
`.trim()}}function Ze(s){let e=!1;return s.onVersionChange(()=>{e=!0})(),{success:!0,message:"db.onVersionChange() - Handle version upgrades",data:{subscribedToVersionChange:!0,versionChangeReceived:e},code:`
// Triggered when another tab wants to upgrade the database
const unsubscribe = db.onVersionChange((event) => {
  console.log(\`Upgrade requested: v\${event.oldVersion} -> v\${event.newVersion}\`)

  // Typically close connection to allow upgrade
  showNotification('Updating app, please wait...')
  db.close()
})

// Important for:
// - Graceful handling of database upgrades
// - User communication during upgrades
// - Preventing upgrade blocking

unsubscribe()
`.trim()}}function et(s){let e=!1;return s.onClose(()=>{e=!0})(),{success:!0,message:"db.onClose() - Handle connection close",data:{subscribedToClose:!0,closeReceived:e},code:`
// Triggered when database connection closes
const unsubscribe = db.onClose(() => {
  console.log('Database connection closed')

  // Reconnect or show offline message
  showOfflineMessage()
})

// Useful for:
// - Cleanup resources
// - Show offline indicators
// - Reconnection logic

unsubscribe()
`.trim()}}function tt(){return{success:!0,message:"Event hooks in database options",data:{availableHooks:["onChange","onError","onBlocked","onVersionChange","onClose"]},code:`
// Set up event handlers at creation time
const db = createDatabase<AppSchema>({
  name: 'myApp',
  version: 1,
  stores: { users: {} },

  // Event hooks
  onChange: (event) => {
    console.log('Change:', event)
    syncToUI()
  },

  onError: (error) => {
    console.error('Error:', error)
    reportError(error)
  },

  onBlocked: () => {
    console.warn('Upgrade blocked by other tabs')
    showCloseTabsMessage()
  },

  onVersionChange: (event) => {
    console.log('Version change:', event)
    prepareForUpgrade()
  },

  onClose: () => {
    console.log('Connection closed')
    showOfflineStatus()
  }
})
`.trim()}}async function rt(s){const e=s.store("users");let t=null;try{await e.resolve("nonexistent-user")}catch(r){r instanceof w&&(t={name:r.name,code:r.code,key:JSON.stringify(r.key),storeName:r.storeName})}return{success:!0,message:"NotFoundError - Thrown by resolve() for missing records",data:{errorDetails:t},code:`
try {
  const user = await store.resolve('nonexistent')
} catch (error) {
  if (error instanceof NotFoundError) {
    console.log(\`Key: \${error.key}\`)
    console.log(\`Store: \${error.storeName}\`)
    console.log(\`Code: \${error.code}\`)  // 'NOT_FOUND'
  }
}

// NotFoundError properties:
// - code: 'NOT_FOUND'
// - key: ValidKey - The missing key
// - storeName: string - The store name
`.trim()}}async function st(s){const e=s.store("users");let t=null;await e.set({id:"constraint-test",name:"Constraint Test",email:"constraint@test.com",age:30,status:"active",role:"user",tags:[],createdAt:Date.now()});try{await e.add({id:"constraint-test",name:"Duplicate",email:"dupe@test.com",age:25,status:"active",role:"user",tags:[],createdAt:Date.now()})}catch(r){r instanceof S&&(t={name:r.name,code:r.code,key:JSON.stringify(r.key)})}return await e.remove("constraint-test"),{success:!0,message:"ConstraintError - Thrown by add() for duplicate keys",data:{errorDetails:t},code:`
try {
  await store.add({ id: 'existing', name: 'Duplicate' })
} catch (error) {
  if (error instanceof ConstraintError) {
    console.log('Key already exists:', error.key)

    // Common pattern: fallback to set() for upsert
    await store.set({ id: 'existing', name: 'Updated' })
  }
}

// ConstraintError properties:
// - code: 'CONSTRAINT_ERROR'
// - key: ValidKey - The conflicting key
// - storeName: string - The store name
`.trim()}}function nt(){return{success:!0,message:"Error codes for different failure modes",data:{errorCodes:["NOT_FOUND","CONSTRAINT_ERROR","QUOTA_EXCEEDED","TRANSACTION_ABORTED","TRANSACTION_INACTIVE","OPEN_FAILED","UPGRADE_FAILED","UPGRADE_BLOCKED","DATA_ERROR","READ_ONLY","VERSION_ERROR","INVALID_STATE","TIMEOUT","UNKNOWN_ERROR"]},code:`
// All database errors have a code property
type DatabaseErrorCode =
  | 'OPEN_FAILED'           // Database failed to open
  | 'UPGRADE_FAILED'        // Migration or store creation failed
  | 'UPGRADE_BLOCKED'       // Other connections prevent upgrade
  | 'TRANSACTION_ABORTED'   // Transaction was aborted
  | 'TRANSACTION_INACTIVE'  // Operation on inactive transaction
  | 'CONSTRAINT_ERROR'      // Key/uniqueness constraint violated
  | 'QUOTA_EXCEEDED'        // Storage quota exceeded
  | 'NOT_FOUND'             // Record not found (resolve())
  | 'DATA_ERROR'            // Invalid data format
  | 'READ_ONLY'             // Write attempted on readonly transaction
  | 'VERSION_ERROR'         // Version conflict
  | 'INVALID_STATE'         // Database in invalid state
  | 'TIMEOUT'               // Operation timed out
  | 'UNKNOWN_ERROR'         // Unrecognized error
`.trim()}}async function at(s){const e=s.store("users");let t=!1,r=!1,n=!1,a=!1;try{await e.resolve("nonexistent")}catch(o){t=k(o),n=Z(o),a=ee(o,"NOT_FOUND")}await e.set({id:"guard-test",name:"Guard Test",email:"guard@test.com",age:30,status:"active",role:"user",tags:[],createdAt:Date.now()});try{await e.add({id:"guard-test",name:"Duplicate",email:"dupe@test.com",age:25,status:"active",role:"user",tags:[],createdAt:Date.now()})}catch(o){r=O(o)}return await e.remove("guard-test"),{success:!0,message:"Type guards for safe error handling",data:{isNotFoundError:t,isConstraintError:r,isDatabaseError:n,hasErrorCode:a},code:`
import {
  isDatabaseError,
  isNotFoundError,
  isConstraintError,
  isQuotaExceededError,
  isTransactionError,
  hasErrorCode
} from '@mikesaintsg/indexeddb'

try {
  await store.resolve('u1')
} catch (error) {
  if (isNotFoundError(error)) {
    // error is typed as NotFoundError
    console.log(error.key, error.storeName)
  } else if (isConstraintError(error)) {
    // error is typed as ConstraintError
    console.log(error.key)
  } else if (isDatabaseError(error)) {
    // error is typed as DatabaseError
    console.log(error.code, error.message)
  }

  // Check for specific error code
  if (hasErrorCode(error, 'QUOTA_EXCEEDED')) {
    showStorageFullMessage()
  }
}
`.trim()}}function ot(){return{success:!0,message:"Error class hierarchy",data:{hierarchy:["DatabaseError (base)","  ââ NotFoundError","  ââ ConstraintError","  ââ QuotaExceededError","  ââ TransactionError","  ââ UpgradeError","  ââ OpenError","  ââ DataError","  ââ ReadOnlyError","  ââ VersionError","  ââ InvalidStateError","  ââ TimeoutError"]},code:`
// Error class hierarchy:
// DatabaseError (base) â all database errors
//   ââ NotFoundError â resolve() when record missing
//   ââ ConstraintError â add() when key exists
//   ââ QuotaExceededError â storage quota exceeded
//   ââ TransactionError â transaction aborted or inactive
//   ââ UpgradeError â database upgrade failed or blocked
//   ââ OpenError â database failed to open
//   ââ DataError â invalid data format
//   ââ ReadOnlyError â write on readonly transaction
//   ââ VersionError â version conflict
//   ââ InvalidStateError â invalid database state
//   ââ TimeoutError â operation timed out

// All errors extend DatabaseError
if (error instanceof DatabaseError) {
  console.log(error.code)     // Error code
  console.log(error.message)  // Error message
  console.log(error.cause)    // Original error (if wrapped)
}
`.trim()}}async function it(s){const e=s.store("users"),t=[],r=await e.get("nonexistent");t.push(`get() returns: ${r===void 0?"undefined":"value"}`);try{await e.resolve("nonexistent")}catch(n){k(n)&&t.push("resolve() throws NotFoundError")}await e.set({id:"error-demo",name:"Demo",email:"demo@test.com",age:30,status:"active",role:"user",tags:[],createdAt:Date.now()});try{await e.add({id:"error-demo",name:"Duplicate",email:"dupe@test.com",age:25,status:"active",role:"user",tags:[],createdAt:Date.now()})}catch(n){O(n)&&t.push("add() throws ConstraintError")}return await e.remove("error-demo"),{success:!0,message:"Comprehensive error handling patterns",data:{results:t},code:`
// Comprehensive error handling pattern
async function safeOperation() {
  try {
    const user = await store.resolve('u1')
    await store.add(newRecord)
  } catch (error) {
    if (isNotFoundError(error)) {
      // Handle missing record
      return createDefault()
    }

    if (isConstraintError(error)) {
      // Handle duplicate key
      return store.set(record)  // Fallback to upsert
    }

    if (isQuotaExceededError(error)) {
      // Handle storage full
      await clearOldData()
      return retry()
    }

    if (isTransactionError(error)) {
      // Handle transaction failure
      await retry()
    }

    // Unknown error - rethrow
    throw error
  }
}
`.trim()}}let u,D="store";const T=[],j=[],$=[{id:"store",emoji:"ð¦",label:"Store Operations",description:"CRUD: get, resolve, set, add, remove, has, all, keys, count, clear"},{id:"index",emoji:"ð",label:"Index Operations",description:"Index queries, multi-entry indexes, unique constraints"},{id:"query",emoji:"ð",label:"Query Builder",description:"where, filter, orderBy, limit, offset, terminal operations"},{id:"transactions",emoji:"â¡",label:"Transactions",description:"read, write, durability, abort, multi-store atomic operations"},{id:"cursors",emoji:"â¡ï¸",label:"Cursors",description:"iterate, iterateKeys, openCursor, navigation, mutation"},{id:"events",emoji:"ð¡",label:"Events",description:"onChange, onError, cross-tab sync, version change"},{id:"errors",emoji:"â ï¸",label:"Error Handling",description:"Error classes, type guards, comprehensive patterns"}];function ct(s){switch(s){case"store":return[{id:"get",title:"get() - Optional Lookup",description:"Returns undefined for missing records",useCase:"ð E-commerce: Check if product exists in cart before displaying quantity",run:()=>le(u)},{id:"resolve",title:"resolve() - Required Lookup",description:"Throws NotFoundError for missing records",useCase:"ð¤ User Profile: Load authenticated user data - must exist or redirect to login",run:()=>he(u)},{id:"set",title:"set() - Upsert",description:"Insert or update records",useCase:"ð Note-taking App: Auto-save draft - create if new, update if exists",run:()=>me(u)},{id:"add",title:"add() - Insert Only",description:"Throws ConstraintError if key exists",useCase:"ð§ Email Client: Save new message with unique ID - fail if duplicate received",run:()=>ye(u)},{id:"remove",title:"remove() - Delete",description:"Silently succeeds for missing keys",useCase:"ðï¸ Task Manager: Delete completed tasks - no error if already deleted",run:()=>fe(u)},{id:"has",title:"has() - Existence Check",description:"Check if records exist",useCase:"ð Auth System: Check if session token is valid before API calls",run:()=>ge(u)},{id:"bulk",title:"Bulk Operations",description:"all(), keys(), count()",useCase:"ð Dashboard: Show total messages count in sidebar badge",run:()=>we(u)},{id:"accessors",title:"Store Accessors",description:"getName, getKeyPath, getIndexNames",useCase:"ð§ Dev Tools: Build dynamic query UI based on store schema",run:()=>pe(u)}];case"index":return[{id:"accessors",title:"Index Accessors",description:"getName, getKeyPath, isUnique, isMultiEntry",useCase:"ð§ Admin Panel: Auto-generate filter dropdowns from index configuration",run:()=>be(u)},{id:"lookup",title:"Index Lookup",description:"get, resolve, getKey by index",useCase:'ð§ Email App: Find user by email address for "Forgot Password" feature',run:()=>xe(u)},{id:"nonunique",title:"Non-Unique Index",description:"Query non-unique index values",useCase:'ð Project Board: List all tasks with status "In Progress"',run:()=>ve(u)},{id:"multientry",title:"Multi-Entry Index",description:"Index array elements separately",useCase:'ð·ï¸ Blog: Find all posts tagged with "JavaScript" from tags array',run:()=>Ee(u)},{id:"range",title:"Range Queries",description:"Numeric range queries on index",useCase:"ð Calendar: Find all events between two dates for week view",run:()=>Ce(u)},{id:"native",title:"Native Access",description:"Access native IDBIndex",useCase:"ð¬ Advanced: Use raw IndexedDB API for specialized operations",run:()=>Ae(u)}];case"query":return[{id:"equals",title:"where().equals()",description:"Fast indexed equality query",useCase:"ð§ Inbox: Show only unread emails using indexed status field",run:()=>Ne(u)},{id:"comparison",title:"Comparison Queries",description:"greaterThan, lessThan, between",useCase:"ð° Banking: Find all transactions above $100 this month",run:()=>De(u)},{id:"startswith",title:"startsWith()",description:"String prefix queries",useCase:"ð Autocomplete: Search contacts by name as user types",run:()=>Ie(u)},{id:"anyof",title:"anyOf()",description:"Multiple value queries",useCase:"ð Filter: Show tickets with priority High OR Critical",run:()=>Te(u)},{id:"filter",title:"filter()",description:"Post-cursor filtering",useCase:"ðµ Music: Find songs where artist name contains search term",run:()=>Se(u)},{id:"combined",title:"Combined Query",description:"where() + filter() for optimal performance",useCase:"ð Products: Active items (index) with price > $50 (filter)",run:()=>ke(u)},{id:"ordering",title:"Ordering & Pagination",description:"orderBy, limit, offset",useCase:"ð° News Feed: Show 10 most recent articles, load more on scroll",run:()=>Oe(u)},{id:"terminal",title:"Terminal Operations",description:"toArray, first, count, keys, iterate",useCase:"ð Analytics: Count active users without loading all records",run:()=>Pe(u)},{id:"iterate",title:"iterate()",description:"Memory-efficient async generator",useCase:"ð Export: Stream 100k records to CSV without memory overflow",run:()=>qe(u)},{id:"boolean",title:"Boolean Queries",description:"Automatic fallback for non-indexable types",useCase:"â Todos: Filter by completed=true (auto-handled by library)",run:()=>Re(u)}];case"transactions":return[{id:"read",title:"Read Transaction",description:"Consistent reads across stores",useCase:"ð§¾ Invoice: Load customer + order + items atomically for display",run:()=>Ue(u)},{id:"write",title:"Write Transaction",description:"Atomic multi-store modifications",useCase:"ð³ Checkout: Create order + decrement inventory + add payment atomically",run:()=>Be(u)},{id:"durability",title:"Durability Options",description:"default, strict, relaxed",useCase:"ð Logging: Use relaxed for high-frequency writes, strict for payments",run:()=>Ke(u)},{id:"accessors",title:"Transaction Accessors",description:"getMode, getStoreNames, isActive",useCase:"ð§ Debugging: Log transaction details for performance monitoring",run:()=>Fe(u)},{id:"abort",title:"Transaction Abort",description:"Roll back all changes",useCase:"â Validation: Abort order if inventory check fails mid-transaction",run:()=>_e(u)},{id:"native",title:"Native Access",description:"Access native IDBTransaction",useCase:"ð¬ Advanced: Direct IndexedDB access for complex operations",run:()=>Ve(u)}];case"cursors":return[{id:"iterate",title:"iterate()",description:"Async generator for records",useCase:"ð§ Email Cleanup: Process each email one-by-one to check for spam",run:()=>Le(u)},{id:"iteratekeys",title:"iterateKeys()",description:"Key-only iteration",useCase:"ð Validation: Check which IDs exist without loading full records",run:()=>Me(u)},{id:"manual",title:"Manual Cursor",description:"openCursor() for full control",useCase:"ð Analytics: Custom iteration with conditional early termination",run:()=>je(u)},{id:"mutation",title:"Cursor Mutation",description:"Update and delete during iteration",useCase:"ð§¹ Cleanup: Delete all expired sessions while iterating",run:()=>$e(u)},{id:"navigation",title:"Cursor Navigation",description:"continue, advance methods",useCase:'ð Pagination: Skip to specific record for "Jump to Page" feature',run:()=>Ge(u)},{id:"directions",title:"Cursor Directions",description:"next, previous, unique variants",useCase:"ð° Feed: Show newest posts first with reverse iteration",run:()=>He(u)},{id:"keycursor",title:"Key Cursor",description:"Efficient key-only cursor",useCase:"ð Index: Build list of all document IDs for search index",run:()=>We(u)},{id:"indexcursor",title:"Index Cursor",description:"Iterate through index",useCase:"ð¥ Groups: Iterate users by department for org chart",run:()=>Qe(u)}];case"events":return[{id:"dbchange",title:"Database onChange",description:"All store changes",useCase:"ð Real-time UI: Update dashboard whenever any data changes",run:()=>Je(u)},{id:"storechange",title:"Store onChange",description:"Specific store changes",useCase:"ð¬ Chat: Only listen for new messages in chat store",run:()=>ze(u)},{id:"crosstab",title:"Cross-Tab Sync",description:"BroadcastChannel synchronization",useCase:"ð Multi-tab: Logout from one tab signs out all open tabs",run:()=>Ye()},{id:"onerror",title:"onError",description:"Error event handling",useCase:"ð Monitoring: Send database errors to analytics service",run:()=>Xe(u)},{id:"versionchange",title:"onVersionChange",description:"Handle version upgrades",useCase:'â¬ï¸ App Update: Show "Please refresh" when new version deploys',run:()=>Ze(u)},{id:"onclose",title:"onClose",description:"Handle connection close",useCase:"ð Offline: Show offline indicator when DB connection lost",run:()=>et(u)},{id:"hooks",title:"Event Hooks",description:"Configure hooks at creation",useCase:"ð Bootstrap: Set up all event handlers during app initialization",run:()=>tt()}];case"errors":return[{id:"notfound",title:"NotFoundError",description:"resolve() for missing records",useCase:"ð Deep Link: Show 404 page when URL contains invalid record ID",run:()=>rt(u)},{id:"constraint",title:"ConstraintError",description:"add() for duplicate keys",useCase:'ð Registration: Show "Email already registered" error',run:()=>st(u)},{id:"codes",title:"Error Codes",description:"All error code enumeration",useCase:"ð Logging: Map error codes to user-friendly messages",run:()=>nt()},{id:"guards",title:"Type Guards",description:"Safe error type checking",useCase:"ð Branching: Different recovery actions based on error type",run:()=>at(u)},{id:"hierarchy",title:"Error Hierarchy",description:"Error class structure",useCase:"ð Documentation: Understand which errors to catch where",run:()=>ot()},{id:"comprehensive",title:"Comprehensive Handling",description:"Best practices pattern",useCase:"ðª Production: Robust error handling for mission-critical apps",run:()=>it(u)}]}}function l(s,e){const t=document.createElement(s);return e?.className&&(t.className=e.className),e?.textContent&&(t.textContent=e.textContent),e?.id&&(t.id=e.id),t}function ut(s){if(s===void 0)return"undefined";if(s===null)return"null";try{return JSON.stringify(s,null,2)}catch{return typeof s=="object"&&s!==null?"[Object]":typeof s=="string"?s:"[Unknown]"}}function G(){const s=document.getElementById("app");if(!s)return;s.innerHTML="";const e=l("div",{className:"container"}),t=l("header"),r=l("h1",{textContent:"ðï¸ IndexedDB Showcase"}),n=l("p",{textContent:"Comprehensive demonstration of ALL @mikesaintsg/indexeddb features"});t.append(r,n);const a=l("nav",{className:"tabs"});$.forEach(d=>{const h=l("button",{className:`tab ${D===d.id?"active":""}`,textContent:`${d.emoji} ${d.label}`});h.title=d.description,h.addEventListener("click",()=>{D=d.id,G()}),a.appendChild(h)});const o=l("main",{id:"content"});dt(o);const i=l("footer"),c=l("p");c.innerHTML="ð¡ <strong>Open this page in another tab</strong> to see cross-tab sync in action!",i.appendChild(c),e.append(t,a,o,i),s.appendChild(e)}function dt(s){const e=$.find(i=>i.id===D);if(!e)return;const t=l("section",{className:"card"}),r=l("h2",{textContent:`${e.emoji} ${e.label}`}),n=l("p",{className:"subtitle",textContent:e.description});t.append(r,n);const a=ct(D),o=l("div",{className:"examples-container"});a.forEach(i=>{const c=lt(i);o.appendChild(c)}),t.appendChild(o),s.appendChild(t)}function lt(s){const e=l("div",{className:"example-card"}),t=l("div",{className:"example-header"}),r=l("h3",{textContent:s.title}),n=l("p",{className:"example-desc",textContent:s.description}),a=l("p",{className:"example-usecase",textContent:s.useCase});t.append(r,n,a);const o=l("button",{className:"btn primary",textContent:"â¶ Run Example"}),i=l("div",{className:"example-result"});return i.style.display="none",o.addEventListener("click",()=>{ht(s,o,i)}),e.append(t,o,i),e}async function ht(s,e,t){e.disabled=!0,e.textContent="â³ Running...",t.style.display="block",t.innerHTML='<p class="loading">Running example...</p>';try{const r=await s.run();t.innerHTML="";const n=r.success?"success":"error",a=r.success?"â":"â",o=l("p",{className:`result-message ${n}`,textContent:`${a} ${r.message}`});if(t.appendChild(o),r.data!==void 0){const i=l("div",{className:"result-data"}),c=l("h4",{textContent:"ð Result Data"}),d=l("pre"),h=l("code",{textContent:ut(r.data)});d.appendChild(h),i.append(c,d),t.appendChild(i)}if(r.code){const i=l("div",{className:"result-code"}),c=l("h4",{textContent:"ð» Code Example"}),d=l("div",{className:"code-block"}),h=l("pre"),p=l("code",{textContent:r.code});h.appendChild(p),d.appendChild(h),i.append(c,d),t.appendChild(i)}}catch(r){t.innerHTML="";const n=l("p",{className:"result-message error",textContent:`â Error: ${r instanceof Error?r.message:String(r)}`});t.appendChild(n)}finally{e.disabled=!1,e.textContent="â¶ Run Example"}}async function mt(){u=de(),await u.store("users").count()===0&&(await u.store("users").set([...B]),await u.store("posts").set([...K]),await u.store("settings").set([...H]));const e=u.onChange(t=>{T.unshift({...t,timestamp:Date.now()}),T.length>100&&T.pop()});j.push(e)}mt().then(()=>{G()});window.addEventListener("beforeunload",()=>{j.forEach(s=>s())});</script>
  <style rel="stylesheet" crossorigin>*{box-sizing:border-box;margin:0;padding:0}:root{--primary: #4f46e5;--primary-hover: #4338ca;--danger: #dc2626;--danger-hover: #b91c1c;--warning: #f59e0b;--warning-hover: #d97706;--secondary: #6b7280;--secondary-hover: #4b5563;--success: #10b981;--bg: #f3f4f6;--card-bg: #ffffff;--text: #1f2937;--text-muted: #6b7280;--border: #e5e7eb;--radius: 8px;--shadow: 0 1px 3px rgba(0, 0, 0, .1);--shadow-lg: 0 4px 6px -1px rgba(0, 0, 0, .1)}body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,sans-serif;background:var(--bg);color:var(--text);line-height:1.5;min-height:100vh}.container{max-width:900px;margin:0 auto;padding:20px}header{text-align:center;margin-bottom:24px}header h1{font-size:2rem;margin-bottom:8px;color:var(--primary)}header p{color:var(--text-muted)}footer{text-align:center;margin-top:32px;padding:16px;color:var(--text-muted);font-size:.875rem;background:#e0e7ff;border-radius:var(--radius)}.tabs{display:flex;gap:8px;margin-bottom:20px;flex-wrap:wrap}.tab{padding:10px 20px;border:none;background:var(--card-bg);border-radius:var(--radius);cursor:pointer;font-size:.95rem;font-weight:500;transition:all .2s;box-shadow:var(--shadow)}.tab:hover{background:var(--border)}.tab.active{background:var(--primary);color:#fff}.card{background:var(--card-bg);border-radius:var(--radius);padding:24px;box-shadow:var(--shadow-lg)}.card h2{margin-bottom:4px;font-size:1.5rem}.card .subtitle{color:var(--text-muted);margin-bottom:20px;font-size:.875rem}.card code{background:#f1f5f9;padding:2px 6px;border-radius:4px;font-size:.85rem;color:var(--primary)}.form-row,.action-row{display:flex;gap:10px;margin-bottom:16px;flex-wrap:wrap}input[type=text],input[type=number],select{padding:10px 14px;border:1px solid var(--border);border-radius:var(--radius);font-size:.95rem;background:#fff;flex:1;min-width:120px}input[type=text]:focus,input[type=number]:focus,select:focus{outline:none;border-color:var(--primary);box-shadow:0 0 0 3px #4f46e51a}input[type=number]{width:80px;flex:none}.btn{padding:10px 18px;border:none;border-radius:var(--radius);font-size:.95rem;font-weight:500;cursor:pointer;transition:all .2s;white-space:nowrap}.btn.small{padding:6px 12px;font-size:.85rem}.btn.primary{background:var(--primary);color:#fff}.btn.primary:hover{background:var(--primary-hover)}.btn.secondary{background:var(--secondary);color:#fff}.btn.secondary:hover{background:var(--secondary-hover)}.btn.warning{background:var(--warning);color:#fff}.btn.warning:hover{background:var(--warning-hover)}.btn.danger{background:var(--danger);color:#fff}.btn.danger:hover{background:var(--danger-hover)}.filter-row{display:flex;gap:8px;margin-bottom:20px;flex-wrap:wrap;align-items:center}.filter-btn{padding:6px 14px;border:1px solid var(--border);background:#fff;border-radius:20px;cursor:pointer;font-size:.875rem;transition:all .2s}.filter-btn:hover{background:var(--border)}.filter-btn.active{background:var(--primary);color:#fff;border-color:var(--primary)}.todo-list{max-height:400px;overflow-y:auto;border:1px solid var(--border);border-radius:var(--radius)}.todo-item{display:flex;align-items:center;gap:12px;padding:12px 16px;border-bottom:1px solid var(--border);transition:background .2s}.todo-item:last-child{border-bottom:none}.todo-item:hover{background:#f9fafb}.todo-item.completed .todo-title{text-decoration:line-through;color:var(--text-muted)}.todo-toggle{width:20px;height:20px;cursor:pointer;flex-shrink:0}.priority{font-size:1rem;flex-shrink:0}.todo-title{flex:1;font-size:.95rem}.todo-date{font-size:.75rem;color:var(--text-muted);flex-shrink:0}.delete-btn{width:28px;height:28px;border:none;background:transparent;color:var(--text-muted);font-size:1.2rem;cursor:pointer;border-radius:50%;transition:all .2s;flex-shrink:0}.delete-btn:hover{background:var(--danger);color:#fff}.stats{display:flex;gap:24px;padding-top:16px;border-top:1px solid var(--border);margin-top:16px;font-size:.875rem;color:var(--text-muted)}.stats strong{color:var(--text)}.notes-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:16px;margin-top:16px}.note-card{padding:16px;border-radius:var(--radius);box-shadow:var(--shadow);transition:transform .2s,box-shadow .2s}.note-card:hover{transform:translateY(-2px);box-shadow:var(--shadow-lg)}.note-card h3{font-size:1rem;margin-bottom:8px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.note-card p{font-size:.875rem;color:#374151;margin-bottom:12px;max-height:60px;overflow:hidden}.note-footer{display:flex;justify-content:space-between;align-items:center;font-size:.75rem;color:var(--text-muted)}.delete-note-btn{width:24px;height:24px;border:none;background:#0000001a;border-radius:50%;cursor:pointer;font-size:1rem;line-height:1}.delete-note-btn:hover{background:var(--danger);color:#fff}.query-builder{background:#f8fafc;padding:20px;border-radius:var(--radius);margin-bottom:20px}.query-row{display:flex;align-items:center;gap:12px;margin-bottom:12px;flex-wrap:wrap}.query-row label{width:140px;font-weight:500;font-size:.875rem;flex-shrink:0}.query-row select{flex:none;width:180px}.query-results{min-height:100px;margin-bottom:20px}.query-results table{width:100%;border-collapse:collapse}.query-results th,.query-results td{padding:10px 12px;text-align:left;border-bottom:1px solid var(--border)}.query-results th{background:#f8fafc;font-weight:600;font-size:.875rem}.query-results td{font-size:.875rem}.query-results tr.completed td{color:var(--text-muted)}.result-count{margin-top:12px;font-size:.875rem;color:var(--text-muted)}.code-section h3{font-size:.95rem;margin-bottom:8px;color:var(--text-muted)}.code-block{background:#1e293b;color:#e2e8f0;padding:16px;border-radius:var(--radius);overflow-x:auto}.code-block pre{margin:0;font-family:Fira Code,Monaco,Consolas,monospace;font-size:.85rem;line-height:1.6}.info-box{background:#dbeafe;border:1px solid #93c5fd;padding:16px;border-radius:var(--radius);margin-bottom:20px}.info-box p{color:#1e40af;margin:0 0 8px}.info-box p:last-child{margin-bottom:0}.event-log{background:#1e293b;color:#e2e8f0;padding:16px;border-radius:var(--radius);max-height:400px;overflow-y:auto;font-family:Fira Code,Monaco,Consolas,monospace;font-size:.85rem}.event-list{list-style:none}.event-list li{padding:8px 12px;border-bottom:1px solid #334155;display:flex;gap:12px;align-items:center}.event-list li:last-child{border-bottom:none}.event-list li.local{border-left:3px solid #3b82f6}.event-list li.remote{border-left:3px solid #f59e0b;background:#f59e0b1a}.event-time{color:#94a3b8;font-size:.75rem}.event-source{font-weight:600;font-size:.75rem;padding:2px 6px;border-radius:4px}.event-list li.local .event-source{background:#3b82f6;color:#fff}.event-list li.remote .event-source{background:#f59e0b;color:#fff}.event-type{color:#22c55e}.event-store{color:#a78bfa}.event-keys{color:#94a3b8;font-size:.75rem}.loading{text-align:center;padding:40px;color:var(--text-muted)}.empty,.placeholder{text-align:center;padding:40px;color:var(--text-muted);font-style:italic}.error{color:var(--danger);text-align:center;padding:20px}.examples-container{display:flex;flex-direction:column;gap:16px}.example-card{border:1px solid var(--border);border-radius:var(--radius);padding:16px;background:#fafafa}.example-header{margin-bottom:12px}.example-header h3{font-size:1rem;margin-bottom:4px;color:var(--primary)}.example-desc{font-size:.85rem;color:var(--text-muted);margin:0 0 8px}.example-usecase{font-size:.85rem;color:#1e40af;background:#dbeafe;padding:8px 12px;border-radius:var(--radius);margin:0;border-left:3px solid var(--primary)}.example-result{margin-top:16px;padding-top:16px;border-top:1px solid var(--border)}.result-message{font-weight:500;padding:8px 12px;border-radius:var(--radius);margin:0 0 12px}.result-message.success{background:#d4edda;color:#155724}.result-message.error{background:#f8d7da;color:#721c24}.result-data,.result-code{margin-top:12px}.result-data h4,.result-code h4{font-size:.85rem;color:var(--text-muted);margin-bottom:8px}.result-data pre{background:#f1f5f9;padding:12px;border-radius:var(--radius);overflow-x:auto;font-size:.8rem;line-height:1.4;max-height:300px;overflow-y:auto}.result-data code{font-family:Fira Code,Monaco,Consolas,monospace}@media(max-width:600px){.container{padding:12px}header h1{font-size:1.5rem}.tabs{gap:4px}.tab{padding:8px 12px;font-size:.85rem}.form-row{flex-direction:column}.form-row input,.form-row select{width:100%}.action-row{flex-direction:column}.action-row .btn{width:100%}.query-row{flex-direction:column;align-items:stretch}.query-row label,.query-row select{width:100%}.stats{flex-direction:column;gap:8px}}</style>
</head>
<body>
<div id="app"></div>
</body>
</html>
