<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IndexedDB Showcase</title>
  <script type="module" crossorigin>(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const o of n)if(o.type==="childList")for(const a of o.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function t(n){const o={};return n.integrity&&(o.integrity=n.integrity),n.referrerPolicy&&(o.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?o.credentials="include":n.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(n){if(n.ep)return;n.ep=!0;const o=t(n);fetch(n.href,o)}})();const W=[{id:"u1",name:"Alice Johnson",email:"alice@example.com",age:28,status:"active",role:"admin",tags:["developer","leader"],createdAt:Date.now()-864e5*30},{id:"u2",name:"Bob Smith",email:"bob@example.com",age:35,status:"active",role:"user",tags:["developer"],createdAt:Date.now()-864e5*20},{id:"u3",name:"Carol White",email:"carol@example.com",age:42,status:"inactive",role:"user",tags:["designer"],createdAt:Date.now()-864e5*15},{id:"u4",name:"David Brown",email:"david@example.com",age:25,status:"active",role:"guest",tags:["intern"],createdAt:Date.now()-864e5*10},{id:"u5",name:"Eva Green",email:"eva@example.com",age:31,status:"active",role:"user",tags:["developer","tester"],createdAt:Date.now()-864e5*5}],Q=[{id:"p1",title:"Getting Started with IndexedDB",content:"IndexedDB is a powerful browser API...",authorId:"u1",published:!0,views:1200,createdAt:Date.now()-864e5*10},{id:"p2",title:"Advanced Queries",content:"Learn how to use the query builder...",authorId:"u1",published:!0,views:800,createdAt:Date.now()-864e5*8},{id:"p3",title:"Draft: New Features",content:"This post is still being written...",authorId:"u2",published:!1,views:50,createdAt:Date.now()-864e5*5},{id:"p4",title:"Cross-Tab Sync",content:"Keep data synchronized across tabs...",authorId:"u2",published:!0,views:500,createdAt:Date.now()-864e5*3},{id:"p5",title:"Error Handling Best Practices",content:"How to handle errors properly...",authorId:"u5",published:!0,views:300,createdAt:Date.now()-864e5}],ae=[{id:"s1",key:"theme",value:"dark",updatedAt:Date.now()-36e5},{id:"s2",key:"language",value:"en",updatedAt:Date.now()-72e5},{id:"s3",key:"notifications",value:"enabled",updatedAt:Date.now()}];class A extends Error{code;cause;constructor(e,t,s){super(t),this.name="DatabaseError",this.code=e,this.cause=s,Object.setPrototypeOf(this,new.target.prototype)}}class k extends A{storeName;key;constructor(e,t){const s=V(t);super("NOT_FOUND",`Record not found in "${e}" with key: ${s}`),this.name="NotFoundError",this.storeName=e,this.key=t}}class L extends A{storeName;key;constructor(e,t,s){const n=V(t);super("CONSTRAINT_ERROR",`Key already exists in "${e}": ${n}`,s),this.name="ConstraintError",this.storeName=e,this.key=t}}class ie extends A{constructor(e){super("QUOTA_EXCEEDED","Storage quota exceeded",e),this.name="QuotaExceededError"}}class D extends A{constructor(e,t,s){super(e,t,s),this.name="TransactionError"}}class B extends A{constructor(e,t,s){super(e,t,s),this.name="UpgradeError"}}class ce extends A{constructor(e,t){super("OPEN_FAILED",e,t),this.name="OpenError"}}class ue extends A{constructor(e,t){super("DATA_ERROR",e,t),this.name="DataError"}}class de extends A{constructor(e,t){super("READ_ONLY",e,t),this.name="ReadOnlyError"}}class le extends A{constructor(e,t){super("VERSION_ERROR",e,t),this.name="VersionError"}}class P extends A{constructor(e,t){super("INVALID_STATE",e,t),this.name="InvalidStateError"}}class me extends A{constructor(e,t){super("TIMEOUT",e,t),this.name="TimeoutError"}}function E(r,e){if(!r)return new A("UNKNOWN_ERROR","Unknown error occurred");const t=e?.storeName??"",s=e?.key??"";switch(r.name){case"ConstraintError":return new L(t,s,r);case"QuotaExceededError":return new ie(r);case"TransactionInactiveError":return new D("TRANSACTION_INACTIVE",r.message||"Transaction is not active",r);case"AbortError":return new D("TRANSACTION_ABORTED",r.message||"Transaction was aborted",r);case"VersionError":return new le(r.message||"Version error",r);case"DataError":return new ue(r.message||"Data error",r);case"InvalidStateError":return new P(r.message||"Invalid state",r);case"ReadOnlyError":return new de(r.message||"Attempted write in read-only transaction",r);case"NotFoundError":return new A("NOT_FOUND",r.message||"Object store or index not found",r);case"TimeoutError":return new me(r.message||"Operation timed out",r);default:return new A("UNKNOWN_ERROR",r.message||`Unknown error: ${r.name}`,r)}}function he(r){return r instanceof A}function F(r){return r instanceof k}function _(r){return r instanceof L}function ye(r,e){return r instanceof A&&r.code===e}function V(r){return typeof r=="string"?`"${r}"`:typeof r=="number"?String(r):r instanceof Date?r.toISOString():Array.isArray(r)?`[${r.map(V).join(", ")}]`:r instanceof ArrayBuffer||ArrayBuffer.isView(r)?"[Binary Data]":String(r)}const J="id",z=!1,R={DATABASE_NOT_OPEN:"Database connection is not open",DATABASE_CLOSED:"Database connection has been closed",STORE_NOT_FOUND:r=>`Object store "${r}" not found`,INDEX_NOT_FOUND:r=>`Index "${r}" not found`,TRANSACTION_INACTIVE:"Transaction is no longer active",TRANSACTION_MODE_MISMATCH:"Operation requires readwrite transaction",INVALID_KEY:"Invalid key type for this operation",NATIVE_ACCESS_NO_TRANSACTION:"Native store access requires active transaction",UPGRADE_BLOCKED:"Database upgrade blocked by other connections",UPGRADE_FAILED:"Database upgrade failed",OPEN_FAILED:"Failed to open database"};function j(r){return new Promise((e,t)=>{r.oncomplete=()=>e(),r.onerror=()=>{t(E(r.error))},r.onabort=()=>{t(new D("TRANSACTION_ABORTED",r.error?.message??"Transaction was aborted",r.error))}})}function X(r){if(r==null)return!1;const e=typeof r;return e==="number"?!Number.isNaN(r):e==="string"?!0:r instanceof Date?!Number.isNaN(r.getTime()):r instanceof ArrayBuffer||ArrayBuffer.isView(r)?!0:Array.isArray(r)?r.every(X):!1}function H(r){return Array.isArray(r)?r:[r]}function pe(r){return typeof r=="number"&&Number.isInteger(r)&&r>0}function ge(r){if(!pe(r))throw new Error(`Database version must be a positive integer, got: ${String(r)}`)}function fe(r){if(r.length===0)throw new Error("Database name must be a non-empty string")}function N(r){return r===void 0?"next":r==="previous"?"prev":r==="previousunique"?"prevunique":r}function Y(r){return r==="prev"?"previous":r==="prevunique"?"previousunique":r}class q{#t;#e;constructor(e,t){this.#t=e,this.#e=t}get native(){return this.#t}getKey(){return this.#t.key}getPrimaryKey(){return this.#t.primaryKey}getValue(){return this.#t.value}getDirection(){return Y(this.#t.direction)}async continue(e){return new Promise((t,s)=>{this.#e.onsuccess=()=>{const n=this.#e.result;t(n?new q(n,this.#e):null)},this.#e.onerror=()=>s(E(this.#e.error)),e!==void 0?this.#t.continue(e):this.#t.continue()})}async continuePrimaryKey(e,t){return new Promise((s,n)=>{this.#e.onsuccess=()=>{const o=this.#e.result;s(o?new q(o,this.#e):null)},this.#e.onerror=()=>n(E(this.#e.error)),this.#t.continuePrimaryKey(e,t)})}async advance(e){return new Promise((t,s)=>{this.#e.onsuccess=()=>{const n=this.#e.result;t(n?new q(n,this.#e):null)},this.#e.onerror=()=>s(E(this.#e.error)),this.#t.advance(e)})}async update(e){return new Promise((t,s)=>{const n=this.#t.update(e);n.onsuccess=()=>t(n.result),n.onerror=()=>s(E(n.error))})}async delete(){return new Promise((e,t)=>{const s=this.#t.delete();s.onsuccess=()=>e(),s.onerror=()=>t(E(s.error))})}}class O{#t;#e;constructor(e,t){this.#t=e,this.#e=t}get native(){return this.#t}getKey(){return this.#t.key}getPrimaryKey(){return this.#t.primaryKey}getDirection(){return Y(this.#t.direction)}async continue(e){return new Promise((t,s)=>{this.#e.onsuccess=()=>{const n=this.#e.result;t(n?new O(n,this.#e):null)},this.#e.onerror=()=>s(E(this.#e.error)),e!==void 0?this.#t.continue(e):this.#t.continue()})}async continuePrimaryKey(e,t){return new Promise((s,n)=>{this.#e.onsuccess=()=>{const o=this.#e.result;s(o?new O(o,this.#e):null)},this.#e.onerror=()=>n(E(this.#e.error)),this.#t.continuePrimaryKey(e,t)})}async advance(e){return new Promise((t,s)=>{this.#e.onsuccess=()=>{const n=this.#e.result;t(n?new O(n,this.#e):null)},this.#e.onerror=()=>s(E(this.#e.error)),this.#t.advance(e)})}}function we(){return{keyPath:null,range:null,anyOfValues:null,filters:[],direction:"ascending",limitCount:null,offsetCount:0}}class x{#t;#e;constructor(e,t){this.#t=e,this.#e=t??we()}where(e){return new ve(this.#t,{...this.#e,keyPath:e})}filter(e){return new x(this.#t,{...this.#e,filters:[...this.#e.filters,e]})}orderBy(e){return new x(this.#t,{...this.#e,direction:e})}limit(e){return new x(this.#t,{...this.#e,limitCount:e})}offset(e){return new x(this.#t,{...this.#e,offsetCount:e})}async toArray(){const e=[];for await(const t of this.iterate())e.push(t);return e}async first(){const t=await new x(this.#t,{...this.#e,limitCount:1}).iterate().next();return t.done?void 0:t.value}async count(){if(this.#e.filters.length===0&&this.#e.anyOfValues===null){const n=(await this.#t.ensureOpen()).transaction([this.#t.storeName],"readonly").objectStore(this.#t.storeName),a=this.#s(n).count(this.#e.range??void 0);return this.#a(a)}let e=0;for await(const t of this.iterate())e++;return e}async keys(){const e=[],n=(await this.#t.ensureOpen()).transaction([this.#t.storeName],"readonly").objectStore(this.#t.storeName),o=this.#s(n),a=N(this.#e.direction==="ascending"?"next":"previous");if(this.#e.anyOfValues!==null){const m=await this.#i(n);return this.#u(m)}const i=o.openKeyCursor(this.#e.range??void 0,a);let c=0,u=0,d=await this.#a(i);for(;d;){if(c<this.#e.offsetCount){c++,d.continue(),d=await this.#a(i);continue}if(this.#e.limitCount!==null&&u>=this.#e.limitCount)break;if(this.#e.filters.length>0){const m=n.get(d.primaryKey),l=await this.#a(m);l!==void 0&&this.#n(l)&&(e.push(d.primaryKey),u++)}else e.push(d.primaryKey),u++;d.continue(),d=await this.#a(i)}return e}async*iterate(){const s=(await this.#t.ensureOpen()).transaction([this.#t.storeName],"readonly").objectStore(this.#t.storeName);if(this.#e.anyOfValues!==null){const d=await this.#r(s),m=this.#u(d);for(const l of m)yield l;return}const n=this.#s(s),o=N(this.#e.direction==="ascending"?"next":"previous"),a=n.openCursor(this.#e.range??void 0,o);let i=0,c=0,u=await this.#a(a);for(;u;){const d=u.value;if(!this.#n(d)){u.continue(),u=await this.#a(a);continue}if(i<this.#e.offsetCount){i++,u.continue(),u=await this.#a(a);continue}if(this.#e.limitCount!==null&&c>=this.#e.limitCount)break;yield d,c++,u.continue(),u=await this.#a(a)}}#s(e){const t=this.#e.keyPath;if(t===null||t===this.#t.primaryKeyPath)return e;if(this.#t.indexNames.includes(t))return e.index(t);for(const s of this.#t.indexNames)try{const n=e.index(s);if(n.keyPath===t)return n}catch{}return e}#n(e){for(const t of this.#e.filters)if(!t(e))return!1;return!0}async#r(e){if(this.#e.anyOfValues===null)return[];const t=this.#e.keyPath,s=new Map,n=this.#e.anyOfValues.map(async a=>{let i=[];if(t===null||t===this.#t.primaryKeyPath){const c=await this.#a(e.get(a));i=c?[c]:[]}else if(this.#t.indexNames.includes(t)){const c=e.index(t);i=await this.#a(c.getAll(a))}else for(const c of this.#t.indexNames)try{const u=e.index(c);if(u.keyPath===t){i=await this.#a(u.getAll(a));break}}catch{}for(const c of i)if(this.#n(c)){const u=this.#o(c);u!==void 0&&s.set(this.#c(u),c)}});await Promise.all(n);const o=Array.from(s.values());return this.#e.direction==="descending"&&o.reverse(),o}async#i(e){if(this.#e.anyOfValues===null)return[];const t=this.#e.keyPath,s=new Set,n=[],o=this.#e.anyOfValues.map(async a=>{let i;if(t===null||t===this.#t.primaryKeyPath)i=await this.#a(e.count(a))>0?[a]:[];else if(this.#t.indexNames.includes(t)){const c=e.index(t);i=await this.#a(c.getAllKeys(a))}else i=[];for(const c of i){const u=this.#c(c);s.has(u)||(s.add(u),n.push(c))}});return await Promise.all(o),this.#e.direction==="descending"&&n.reverse(),n}#o(e){const t=this.#t.primaryKeyPath;if(!(t===null||typeof e!="object"||e===null))return e[t]}#u(e){let t=e;return this.#e.offsetCount>0&&(t=t.slice(this.#e.offsetCount)),this.#e.limitCount!==null&&(t=t.slice(0,this.#e.limitCount)),t}#a(e){return new Promise((t,s)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>s(E(e.error,{storeName:this.#t.storeName}))})}#c(e){return typeof e=="string"?e:typeof e=="number"?`n:${e}`:e instanceof Date?`d:${e.getTime()}`:e instanceof ArrayBuffer?`b:${Array.from(new Uint8Array(e)).join(",")}`:ArrayBuffer.isView(e)?`b:${Array.from(new Uint8Array(e.buffer)).join(",")}`:Array.isArray(e)?`a:${JSON.stringify(e)}`:JSON.stringify(e)}}class ve{#t;#e;constructor(e,t){this.#t=e,this.#e=t}equals(e){return X(e)?new x(this.#t,{...this.#e,range:IDBKeyRange.only(e)}):this.#s(e,t=>t===e)}#s(e,t){const s=this.#e.keyPath,n=o=>{if(s===null||typeof o!="object"||o===null)return!1;const a=o[s];return t(a)};return new x(this.#t,{...this.#e,keyPath:null,filters:[...this.#e.filters,n]})}greaterThan(e){return new x(this.#t,{...this.#e,range:IDBKeyRange.lowerBound(e,!0)})}greaterThanOrEqual(e){return new x(this.#t,{...this.#e,range:IDBKeyRange.lowerBound(e,!1)})}lessThan(e){return new x(this.#t,{...this.#e,range:IDBKeyRange.upperBound(e,!0)})}lessThanOrEqual(e){return new x(this.#t,{...this.#e,range:IDBKeyRange.upperBound(e,!1)})}between(e,t,s){return new x(this.#t,{...this.#e,range:IDBKeyRange.bound(e,t,s?.lowerOpen??!1,s?.upperOpen??!1)})}startsWith(e){return new x(this.#t,{...this.#e,range:IDBKeyRange.bound(e,e+"ï¿¿",!1,!1)})}anyOf(e){return new x(this.#t,{...this.#e,anyOfValues:e})}}class Z{#t;#e;#s;#n;constructor(e,t,s,n){this.#t=e,this.#e=t,this.#s=s,this.#n=n}get native(){throw new Error("Index.native requires active transaction. Use openCursor() or iterate().")}getName(){return this.#e}getKeyPath(){return this.#s.keyPath}isUnique(){return this.#s.unique??!1}isMultiEntry(){return this.#s.multiEntry??!1}async get(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return Array.isArray(e)?await Promise.all(e.map(a=>this.#r(o.get(a)))):this.#r(o.get(e))}async resolve(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);if(Array.isArray(e))return await Promise.all(e.map(async i=>{const c=await this.#r(o.get(i));if(c===void 0)throw new k(this.#t,i);return c}));const a=await this.#r(o.get(e));if(a===void 0)throw new k(this.#t,e);return a}async getKey(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return this.#r(o.getKey(e))}async all(e,t){const a=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return this.#r(a.getAll(e??void 0,t))}async keys(e,t){const a=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return this.#r(a.getAllKeys(e??void 0,t))}async count(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return this.#r(o.count(e))}query(){return new x({storeName:this.#t,primaryKeyPath:null,indexNames:[this.#e],ensureOpen:this.#n})}async*iterate(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e),a=N(e?.direction),i=o.openCursor(e?.query??null,a);let c=await this.#r(i);for(;c;){yield c.value;const u=new Promise(d=>{i.onsuccess=()=>d(i.result)});c.continue(),c=await u}}async*iterateKeys(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e),a=N(e?.direction),i=o.openKeyCursor(e?.query??null,a);let c=await this.#r(i);for(;c;){yield c.key;const u=new Promise(d=>{i.onsuccess=()=>d(i.result)});c.continue(),c=await u}}async openCursor(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e),a=N(e?.direction),i=o.openCursor(e?.query??null,a),c=await this.#r(i);return c?new q(c,i):null}async openKeyCursor(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e),a=N(e?.direction),i=o.openKeyCursor(e?.query??null,a),c=await this.#r(i);return c?new O(c,i):null}#r(e){return new Promise((t,s)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>s(E(e.error,{storeName:this.#t}))})}}class be{#t;#e;#s;#n=new Set;constructor(e,t,s){this.#t=e,this.#e=t,this.#s=s}get native(){throw new Error(R.NATIVE_ACCESS_NO_TRANSACTION)}getName(){return this.#e}getKeyPath(){return this.#s.keyPath===void 0?J:this.#s.keyPath}getIndexNames(){return(this.#s.indexes??[]).map(e=>e.name)}hasAutoIncrement(){return this.#s.autoIncrement??z}async get(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);return Array.isArray(e)?await Promise.all(e.map(o=>this.#r(n.get(o)))):this.#r(n.get(e))}async resolve(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);if(Array.isArray(e))return await Promise.all(e.map(async a=>{const i=await this.#r(n.get(a));if(i===void 0)throw new k(this.#e,a);return i}));const o=await this.#r(n.get(e));if(o===void 0)throw new k(this.#e,e);return o}async has(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);return Array.isArray(e)?await Promise.all(e.map(async a=>await this.#r(n.count(a))>0)):await this.#r(n.count(e))>0}async set(e,t){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readwrite"),o=n.objectStore(this.#e);if(Array.isArray(e)){const i=await Promise.all(e.map(c=>this.#r(o.put(c))));return await this.#i(n),this.#o("set",i),i}const a=await this.#r(o.put(e,t));return await this.#i(n),this.#o("set",[a]),a}async add(e,t){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readwrite"),o=n.objectStore(this.#e);if(Array.isArray(e)){const i=await Promise.all(e.map(c=>this.#r(o.add(c))));return await this.#i(n),this.#o("add",i),i}const a=await this.#r(o.add(e,t));return await this.#i(n),this.#o("add",[a]),a}async remove(e){const s=(await this.#t.ensureOpen()).transaction([this.#e],"readwrite"),n=s.objectStore(this.#e);if(Array.isArray(e)){await Promise.all(e.map(o=>this.#r(n.delete(o)))),await this.#i(s),this.#o("remove",e.map(o=>o));return}await this.#r(n.delete(e)),await this.#i(s),this.#o("remove",[e])}async all(e,t){const o=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);return this.#r(o.getAll(e??void 0,t))}async keys(e,t){const o=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);return this.#r(o.getAllKeys(e??void 0,t))}async clear(){const t=(await this.#t.ensureOpen()).transaction([this.#e],"readwrite"),s=t.objectStore(this.#e);await this.#r(s.clear()),await this.#i(t),this.#o("clear",[])}async count(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);return this.#r(n.count(e))}index(e){const s=(this.#s.indexes??[]).find(n=>n.name===e);if(!s)throw new Error(`Index "${e}" not found on store "${this.#e}"`);return new Z(this.#e,e,s,()=>this.#t.ensureOpen())}query(){const e=this.getKeyPath();return new x({storeName:this.#e,primaryKeyPath:typeof e=="string"?e:null,indexNames:this.getIndexNames(),ensureOpen:()=>this.#t.ensureOpen()})}async*iterate(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e),o=N(e?.direction),a=n.openCursor(e?.query??null,o);let i=await this.#r(a);for(;i;){yield i.value;const c=new Promise(u=>{a.onsuccess=()=>u(a.result)});i.continue(),i=await c}}async*iterateKeys(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e),o=N(e?.direction),a=n.openKeyCursor(e?.query??null,o);let i=await this.#r(a);for(;i;){yield i.key;const c=new Promise(u=>{a.onsuccess=()=>u(a.result)});i.continue(),i=await c}}async openCursor(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e),o=N(e?.direction),a=n.openCursor(e?.query??null,o),i=await this.#r(a);return i?new q(i,a):null}async openKeyCursor(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e),o=N(e?.direction),a=n.openKeyCursor(e?.query??null,o),i=await this.#r(a);return i?new O(i,a):null}onChange(e){return this.#n.add(e),()=>this.#n.delete(e)}#r(e){return new Promise((t,s)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>s(E(e.error,{storeName:this.#e}))})}#i(e){return new Promise((t,s)=>{e.oncomplete=()=>t(),e.onerror=()=>s(E(e.error)),e.onabort=()=>s(E(e.error))})}#o(e,t){const s={storeName:this.#e,type:e,keys:t,source:"local"};for(const n of this.#n)try{n(s)}catch{}this.#t.emitChange(s)}emitRemoteChange(e){for(const t of this.#n)try{t(e)}catch{}}}class xe{#t;#e;constructor(e,t){this.#t=e,this.#e=t}get native(){return this.#t}async get(e){return Array.isArray(e)?Promise.all(e.map(t=>this.#s(this.#t.get(t)))):this.#s(this.#t.get(e))}async resolve(e){if(Array.isArray(e))return Promise.all(e.map(async s=>{const n=await this.#s(this.#t.get(s));if(n===void 0)throw new k(this.#e,s);return n}));const t=await this.#s(this.#t.get(e));if(t===void 0)throw new k(this.#e,e);return t}async set(e,t){return Array.isArray(e)?Promise.all(e.map(s=>this.#s(this.#t.put(s)))):this.#s(this.#t.put(e,t))}async add(e,t){return Array.isArray(e)?Promise.all(e.map(s=>this.#s(this.#t.add(s)))):this.#s(this.#t.add(e,t))}async remove(e){if(Array.isArray(e)){await Promise.all(e.map(t=>this.#s(this.#t.delete(t))));return}await this.#s(this.#t.delete(e))}async all(e,t){return this.#s(this.#t.getAll(e??void 0,t))}async keys(e,t){return this.#s(this.#t.getAllKeys(e??void 0,t))}async clear(){await this.#s(this.#t.clear())}async count(e){return this.#s(this.#t.count(e))}index(e){if(!this.#t.indexNames.contains(e))throw new Error(`Index "${e}" not found on store "${this.#e}"`);const t=this.#t.index(e),s={name:t.name,keyPath:t.keyPath,unique:t.unique,multiEntry:t.multiEntry},n=this.#t.transaction.db;return new Z(this.#e,e,s,()=>Promise.resolve(n))}async openCursor(e){const t=N(e?.direction),s=this.#t.openCursor(e?.query??null,t),n=await this.#s(s);return n?new q(n,s):null}async openKeyCursor(e){const t=N(e?.direction),s=this.#t.openKeyCursor(e?.query??null,t),n=await this.#s(s);return n?new O(n,s):null}#s(e){return new Promise((t,s)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>s(E(e.error,{storeName:this.#e}))})}}class G{#t;#e;#s=!0;#n=!1;constructor(e){this.#t=e,this.#e=Array.from(e.objectStoreNames),e.oncomplete=()=>{this.#s=!1,this.#n=!0},e.onabort=()=>{this.#s=!1,this.#n=!0},e.onerror=()=>{this.#s=!1,this.#n=!0}}get native(){return this.#t}getMode(){return this.#t.mode}getStoreNames(){return this.#e}isActive(){return this.#s}isFinished(){return this.#n}store(e){if(!this.#e.includes(e))throw new D("INVALID_STATE",`Store "${e}" is not in transaction scope. Scoped stores: ${this.#e.join(", ")}`);if(!this.#s)throw new D("TRANSACTION_INACTIVE","Transaction is no longer active");const t=this.#t.objectStore(e);return new xe(t,e)}abort(){if(this.#n)throw new D("INVALID_STATE","Cannot abort: transaction already finished");this.#t.abort(),this.#s=!1,this.#n=!0}commit(){if(this.#n)throw new D("INVALID_STATE","Cannot commit: transaction already finished");typeof this.#t.commit=="function"&&this.#t.commit()}}class Ee{#t;#e;#s;#n;#r;#i;#o=null;#u=null;#a=!1;#c=null;#d=new Set;#m=new Set;#h=new Set;#l=new Set;#y=new Map;constructor(e){fe(e.name),ge(e.version),this.#t=e.name,this.#e=e.version,this.#s=e.stores,this.#n=e.migrations??[],this.#r=e.onBlocked,this.#i=e.crossTabSync!==!1,this.#i&&typeof BroadcastChannel<"u"&&(this.#c=new BroadcastChannel(`idb:${e.name}`),this.#c.onmessage=t=>{this.#g(t.data)}),this.#t=e.name,this.#e=e.version,this.#s=e.stores,this.#n=e.migrations??[],this.#r=e.onBlocked,e.onChange&&this.#d.add(e.onChange),e.onError&&this.#m.add(e.onError),e.onVersionChange&&this.#h.add(e.onVersionChange),e.onClose&&this.#l.add(e.onClose)}get native(){if(!this.#o)throw new P(R.DATABASE_NOT_OPEN);return this.#o}getName(){return this.#t}getVersion(){return this.#e}getStoreNames(){return this.#o?Array.from(this.#o.objectStoreNames):Object.keys(this.#s)}isOpen(){return this.#o!==null&&!this.#a}store(e){if(!(e in this.#s))throw new P(R.STORE_NOT_FOUND(e));let t=this.#y.get(e);return t||(t=new be(this,e,this.#s[e]),this.#y.set(e,t)),t}async read(e,t){const s=await this.ensureOpen(),n=H(e),o=s.transaction([...n],"readonly"),a=new G(o);try{await t(a),await j(o)}catch(i){if(a.isActive())try{a.abort()}catch{}throw i}}async write(e,t,s){const n=await this.ensureOpen(),o=H(e),a=s?.durability?{durability:s.durability}:void 0,i=[...o],c=a?n.transaction(i,"readwrite",a):n.transaction(i,"readwrite"),u=new G(c);try{await t(u),await j(c)}catch(d){if(u.isActive())try{u.abort()}catch{}throw d}}close(){this.#c&&(this.#c.close(),this.#c=null),this.#o&&(this.#o.close(),this.#o=null),this.#a=!0,this.#u=null;for(const e of this.#l)try{e()}catch{}}async drop(){return this.close(),new Promise((e,t)=>{const s=indexedDB.deleteDatabase(this.#t);s.onsuccess=()=>e(),s.onerror=()=>t(E(s.error)),s.onblocked=()=>{}})}onChange(e){return this.#d.add(e),()=>this.#d.delete(e)}onError(e){return this.#m.add(e),()=>this.#m.delete(e)}onVersionChange(e){return this.#h.add(e),()=>this.#h.delete(e)}onClose(e){return this.#l.add(e),()=>this.#l.delete(e)}async ensureOpen(){if(this.#a)throw new P(R.DATABASE_CLOSED);if(this.#o)return this.#o;if(this.#u)return this.#u;this.#u=this.#f();try{return this.#o=await this.#u,this.#o}catch(e){throw this.#u=null,e}}emitChange(e){for(const t of this.#d)try{t(e)}catch(s){this.#p(s instanceof Error?s:new Error(String(s)))}if(e.source==="local"&&this.#c)try{this.#c.postMessage(e)}catch{}}#g(e){const t={...e,source:"remote"};for(const n of this.#d)try{n(t)}catch(o){this.#p(o instanceof Error?o:new Error(String(o)))}const s=this.#y.get(e.storeName);s&&s.emitRemoteChange(t)}async#f(){return new Promise((e,t)=>{const s=indexedDB.open(this.#t,this.#e);s.onerror=()=>{t(new ce(`Failed to open database "${this.#t}"`,s.error))},s.onsuccess=()=>{const n=s.result;this.#w(n),e(n)},s.onupgradeneeded=n=>{const o=s.result,a=s.transaction;if(!a){t(new B("UPGRADE_FAILED","No transaction available during upgrade"));return}try{this.#v(o,a,n.oldVersion,n.newVersion??this.#e)}catch(i){a.abort(),t(i instanceof B?i:new B("UPGRADE_FAILED",i instanceof Error?i.message:"Upgrade failed",i))}},s.onblocked=n=>{this.#r&&this.#r({oldVersion:n.oldVersion,newVersion:n.newVersion??this.#e})}})}#w(e){e.onversionchange=t=>{for(const s of this.#h)try{s({oldVersion:t.oldVersion,newVersion:t.newVersion})}catch{}},e.onclose=()=>{this.#o=null,this.#a=!0;for(const t of this.#l)try{t()}catch{}},e.onerror=t=>{const n=t.target?.error??new Error("Unknown database error");this.#p(n instanceof Error?n:new Error(String(n)))}}#v(e,t,s,n){for(const[a,i]of Object.entries(this.#s))e.objectStoreNames.contains(a)||this.#b(e,a,i);const o=this.#n.filter(a=>a.version>s&&a.version<=n).sort((a,i)=>a.version-i.version);for(const a of o)a.migrate({database:e,transaction:t,oldVersion:s,newVersion:n})}#b(e,t,s){const n=s.keyPath===void 0?J:s.keyPath,a={autoIncrement:s.autoIncrement??z};n!==null&&(a.keyPath=n);const i=e.createObjectStore(t,a);for(const c of s.indexes??[])this.#x(i,c)}#x(e,t){e.createIndex(t.name,t.keyPath,{unique:t.unique??!1,multiEntry:t.multiEntry??!1})}#p(e){for(const t of this.#m)try{t(e)}catch{}}}function Ae(r){return new Ee(r)}function Ce(){return Ae({name:"showcase-db",version:1,stores:{users:{indexes:[{name:"byEmail",keyPath:"email",unique:!0},{name:"byStatus",keyPath:"status"},{name:"byRole",keyPath:"role"},{name:"byAge",keyPath:"age"},{name:"byTags",keyPath:"tags",multiEntry:!0},{name:"byCreatedAt",keyPath:"createdAt"}]},posts:{indexes:[{name:"byAuthor",keyPath:"authorId"},{name:"byPublished",keyPath:"published"},{name:"byViews",keyPath:"views"},{name:"byCreatedAt",keyPath:"createdAt"}]},settings:{indexes:[{name:"byKey",keyPath:"key",unique:!0},{name:"byUpdatedAt",keyPath:"updatedAt"}]}},crossTabSync:!0})}async function Se(r){const e=r.store("users"),t=await e.get("u1"),s=await e.get("nonexistent"),n=["u1","u2","nonexistent"],o=await e.get(n);return{success:!0,message:"get() returns undefined for missing records",data:{single:t?.name??"undefined",missing:s===void 0?"undefined (as expected)":"found",batch:o.map(a=>a?.name??"undefined")},code:`
// Single key lookup - returns T | undefined
const user = await store.get('u1')
if (user) {
  console.log(user.name)  // Safe to access
}

// Missing key returns undefined (no error)
const missing = await store.get('nonexistent')  // undefined

// Batch lookup - some may be undefined
const users = await store.get(['u1', 'u2', 'nonexistent'])
// users[2] is undefined
`.trim()}}async function Ne(r){const e=r.store("users");let t="";const s=await e.resolve("u1");try{await e.resolve("nonexistent")}catch(n){F(n)&&(t=`NotFoundError: Key "${JSON.stringify(n.key)}" not found in "${n.storeName}"`)}return{success:!0,message:"resolve() throws NotFoundError for missing records",data:{found:s.name,error:t},code:`
// resolve() throws if record doesn't exist
try {
  const user = await store.resolve('u1')
  console.log(user.name)  // Guaranteed to exist
} catch (error) {
  if (error instanceof NotFoundError) {
    console.log(\`Key \${error.key} not found in \${error.storeName}\`)
  }
}

// Batch resolve - throws if ANY is missing
const users = await store.resolve(['u1', 'u2', 'u3'])
`.trim()}}async function Te(r){const e=r.store("users"),t=await e.set({id:"demo-user",name:"Demo User",email:"demo@example.com",age:30,status:"active",role:"user",tags:["demo"],createdAt:Date.now()});await e.set({id:"demo-user",name:"Demo User (Updated)",email:"demo@example.com",age:31,status:"active",role:"user",tags:["demo","updated"],createdAt:Date.now()});const s=await e.set([...W]);return await e.remove("demo-user"),{success:!0,message:"set() upserts records (insert or update)",data:{singleKey:t,batchKeys:s},code:`
// Single record - insert or update (upsert)
const key = await store.set({ id: 'u1', name: 'Alice', ... })

// Update existing record (same key)
await store.set({ id: 'u1', name: 'Alice (Updated)', ... })

// Batch set - single transaction, atomic
const keys = await store.set([user1, user2, user3])
`.trim()}}async function ke(r){const e=r.store("users");let t="";const s={id:"new-user",name:"New User",email:"new@example.com",age:25,status:"active",role:"guest",tags:["new"],createdAt:Date.now()},n=await e.add(s);try{await e.add(s)}catch(o){_(o)&&(t=`ConstraintError: Key "${JSON.stringify(o.key)}" already exists`)}return await e.remove("new-user"),{success:!0,message:"add() throws ConstraintError if key exists",data:{addedKey:n,duplicateError:t},code:`
// add() inserts only - throws if key exists
try {
  await store.add({ id: 'u1', name: 'Alice' })
} catch (error) {
  if (error instanceof ConstraintError) {
    console.log('User already exists, updating instead')
    await store.set({ id: 'u1', name: 'Alice' })
  }
}

// Batch add - fails if ANY key exists
await store.add([user1, user2, user3])
`.trim()}}async function De(r){const e=r.store("users");await e.set({id:"to-delete",name:"To Delete",email:"delete@example.com",age:0,status:"inactive",role:"guest",tags:[],createdAt:Date.now()});const t=await e.count();await e.remove("to-delete"),await e.remove("nonexistent");const s=await e.count();return{success:!0,message:"remove() silently succeeds for missing keys",data:{beforeCount:t,afterCount:s,difference:t-s},code:`
// Single key remove
await store.remove('u1')

// Removing nonexistent key - no error
await store.remove('nonexistent')  // Silently succeeds

// Batch remove
await store.remove(['u1', 'u2', 'u3'])
`.trim()}}async function Ie(r){const e=r.store("users"),t=await e.has("u1"),s=await e.has("nonexistent"),n=await e.has(["u1","u2","nonexistent"]);return{success:!0,message:"has() checks if records exist",data:{exists:t,missing:s,batchChecks:n},code:`
// Single key existence check
const exists = await store.has('u1')  // true

// Missing key
const missing = await store.has('nonexistent')  // false

// Batch check
const checks = await store.has(['u1', 'u2', 'nonexistent'])
// [true, true, false]
`.trim()}}async function qe(r){const e=r.store("users"),t=await e.all(),s=await e.all(null,3),n=await e.keys(),o=await e.count();return{success:!0,message:"Bulk operations: all(), keys(), count()",data:{allCount:t.length,first3Names:s.map(a=>a.name),allKeys:n,count:o},code:`
// Get all records
const allUsers = await store.all()

// Get all with limit
const first3 = await store.all(null, 3)

// With key range
const range = IDBKeyRange.bound('a', 'z')
const subset = await store.all(range)

// Get all keys
const allKeys = await store.keys()

// Count records
const count = await store.count()

// Clear all records (dangerous!)
// await store.clear()
`.trim()}}function Oe(r){const e=r.store("users");return{success:!0,message:"Store accessor methods",data:{name:e.getName(),keyPath:e.getKeyPath(),indexNames:e.getIndexNames(),autoIncrement:e.hasAutoIncrement()},code:`
const store = db.store('users')

store.getName()           // 'users'
store.getKeyPath()        // 'id'
store.getIndexNames()     // ['byEmail', 'byStatus', ...]
store.hasAutoIncrement()  // false
`.trim()}}function Pe(r){const e=r.store("users"),t=e.index("byEmail"),s=e.index("byStatus"),n=e.index("byTags");return{success:!0,message:"Index accessor methods",data:{emailIndex:{name:t.getName(),keyPath:t.getKeyPath(),unique:t.isUnique(),multiEntry:t.isMultiEntry()},statusIndex:{name:s.getName(),keyPath:s.getKeyPath(),unique:s.isUnique(),multiEntry:s.isMultiEntry()},tagsIndex:{name:n.getName(),keyPath:n.getKeyPath(),unique:n.isUnique(),multiEntry:n.isMultiEntry()}},code:`
const emailIndex = store.index('byEmail')

emailIndex.getName()      // 'byEmail'
emailIndex.getKeyPath()   // 'email'
emailIndex.isUnique()     // true
emailIndex.isMultiEntry() // false

// Multi-entry index for arrays
const tagsIndex = store.index('byTags')
tagsIndex.isMultiEntry()  // true
`.trim()}}async function Re(r){const t=r.store("users").index("byEmail"),s=await t.get("alice@example.com"),n=await t.get("nonexistent@example.com");let o="";try{await t.resolve("nonexistent@example.com")}catch{o="NotFoundError thrown as expected"}const a=await t.getKey("alice@example.com");return{success:!0,message:"Index lookup operations",data:{userByEmail:s?.name??"not found",missing:n===void 0?"undefined (correct)":"found",resolveError:o,primaryKey:a},code:`
const emailIndex = store.index('byEmail')

// Get by index key (returns first match)
const user = await emailIndex.get('alice@example.com')

// Returns undefined for missing
const missing = await emailIndex.get('nonexistent@example.com')  // undefined

// resolve throws for missing
const user = await emailIndex.resolve('alice@example.com')  // Throws if not found

// Get primary key for an index key
const primaryKey = await emailIndex.getKey('alice@example.com')  // 'u1'
`.trim()}}async function Ue(r){const t=r.store("users").index("byStatus"),s=await t.all(IDBKeyRange.only("active")),n=await t.all(IDBKeyRange.only("inactive")),o=await t.count("active"),a=await t.count("inactive");return{success:!0,message:"Non-unique index queries",data:{activeUsers:s.map(i=>i.name),inactiveUsers:n.map(i=>i.name),activeCount:o,inactiveCount:a},code:`
const statusIndex = store.index('byStatus')

// Get all matching a specific value
const activeUsers = await statusIndex.all(IDBKeyRange.only('active'))

// Count records with specific index value
const activeCount = await statusIndex.count('active')
const inactiveCount = await statusIndex.count('inactive')
`.trim()}}async function $e(r){const t=r.store("users").index("byTags"),s=await t.all(IDBKeyRange.only("developer")),n=await t.all(IDBKeyRange.only("designer"));return{success:!0,message:"Multi-entry index for arrays",data:{developersCount:s.length,developers:s.map(o=>({name:o.name,tags:o.tags})),designersCount:n.length,designers:n.map(o=>({name:o.name,tags:o.tags}))},code:`
// Multi-entry index indexes each array element separately
// User: { tags: ['developer', 'leader'] }
// Creates index entries for both 'developer' AND 'leader'

const tagsIndex = store.index('byTags')  // multiEntry: true

// Find all users with 'developer' tag
const developers = await tagsIndex.all(IDBKeyRange.only('developer'))

// Find all users with 'designer' tag
const designers = await tagsIndex.all(IDBKeyRange.only('designer'))
`.trim()}}async function Be(r){const t=r.store("users").index("byAge"),s=await t.all(IDBKeyRange.lowerBound(30)),n=await t.all(IDBKeyRange.upperBound(30,!0)),o=await t.all(IDBKeyRange.bound(25,35));return{success:!0,message:"Index range queries",data:{over30:s.map(a=>({name:a.name,age:a.age})),under30:n.map(a=>({name:a.name,age:a.age})),between25And35:o.map(a=>({name:a.name,age:a.age}))},code:`
const ageIndex = store.index('byAge')

// Users over 30
const over30 = await ageIndex.all(IDBKeyRange.lowerBound(30))

// Users under 30 (exclusive)
const under30 = await ageIndex.all(IDBKeyRange.upperBound(30, true))

// Users between 25 and 35 (inclusive)
const between25And35 = await ageIndex.all(IDBKeyRange.bound(25, 35))
`.trim()}}function Ke(r){const s=r.store("users").index("byEmail").native;return{success:!0,message:"Native IDBIndex access",data:{nativeName:s.name,nativeKeyPath:s.keyPath,nativeUnique:s.unique,nativeMultiEntry:s.multiEntry},code:`
const emailIndex = store.index('byEmail')

// Access native IDBIndex for advanced operations
const nativeIndex = emailIndex.native

// Use native APIs
nativeIndex.name        // 'byEmail'
nativeIndex.keyPath     // 'email'
nativeIndex.unique      // true
nativeIndex.multiEntry  // false
`.trim()}}async function Me(r){const e=r.store("users"),t=await e.query().where("byStatus").equals("active").toArray(),s=await e.query().where("byRole").equals("admin").toArray();return{success:!0,message:"where().equals() - Fast indexed queries",data:{activeUsers:t.map(n=>n.name),admins:s.map(n=>n.name)},code:`
// Fast indexed query using where().equals()
const activeUsers = await store.query()
  .where('byStatus').equals('active')
  .toArray()

// Query by role
const admins = await store.query()
  .where('byRole').equals('admin')
  .toArray()

// Note: Uses IDBKeyRange.only() internally for performance
`.trim()}}async function Le(r){const e=r.store("users"),t=await e.query().where("byAge").greaterThan(30).toArray(),s=await e.query().where("byAge").lessThanOrEqual(30).toArray(),n=await e.query().where("byAge").between(25,35).toArray(),o=await e.query().where("byAge").between(25,35,{lowerOpen:!0,upperOpen:!0}).toArray();return{success:!0,message:"Comparison queries: greaterThan, lessThan, between",data:{over30:t.map(a=>({name:a.name,age:a.age})),under30:s.map(a=>({name:a.name,age:a.age})),between25And35:n.map(a=>({name:a.name,age:a.age})),between25And35Exclusive:o.map(a=>({name:a.name,age:a.age}))},code:`
// Greater than (exclusive)
const over30 = await store.query()
  .where('byAge').greaterThan(30)
  .toArray()

// Less than or equal (inclusive)
const under30 = await store.query()
  .where('byAge').lessThanOrEqual(30)
  .toArray()

// Between (inclusive by default)
const between = await store.query()
  .where('byAge').between(25, 35)
  .toArray()

// With exclusivity options
const betweenExclusive = await store.query()
  .where('byAge').between(25, 35, { lowerOpen: true, upperOpen: true })
  .toArray()
`.trim()}}async function Fe(r){return{success:!0,message:"startsWith() - String prefix queries",data:{aEmails:(await r.store("users").query().where("byEmail").startsWith("a").toArray()).map(s=>({name:s.name,email:s.email}))},code:`
// String prefix query
const aEmails = await store.query()
  .where('byEmail').startsWith('a')  // 'alice@...', 'adam@...', etc.
  .toArray()

// Uses IDBKeyRange.bound(prefix, prefix + '\\uffff')
`.trim()}}async function _e(r){return{success:!0,message:"anyOf() - Multiple value queries",data:{adminOrUser:(await r.store("users").query().where("byRole").anyOf(["admin","user"]).toArray()).map(s=>({name:s.name,role:s.role}))},code:`
// Find records matching any of multiple values
const adminOrUser = await store.query()
  .where('byRole').anyOf(['admin', 'user'])
  .toArray()

// Executes parallel queries and merges results
// Results are deduplicated by primary key
`.trim()}}async function Ve(r){const e=r.store("users"),t=await e.query().filter(o=>o.email.endsWith("@example.com")).toArray(),s=await e.query().filter(o=>o.age>=30&&o.status==="active").toArray(),n=await e.query().filter(o=>/^[A-D]/.test(o.name)).toArray();return{success:!0,message:"filter() - Flexible post-cursor filtering",data:{gmailUsers:t.map(o=>o.email),activeAdults:s.map(o=>({name:o.name,age:o.age})),namePattern:n.map(o=>o.name)},code:`
// Filter for conditions that can't use indexes
const gmailUsers = await store.query()
  .filter(u => u.email.endsWith('@gmail.com'))
  .toArray()

// Complex conditions
const activeAdults = await store.query()
  .filter(u => u.age >= 30 && u.status === 'active')
  .toArray()

// Regex matching
const pattern = await store.query()
  .filter(u => /^J.*n$/.test(u.name))
  .toArray()
`.trim()}}async function je(r){return{success:!0,message:"Combining where() and filter() for optimal performance",data:{activeWithE:(await r.store("users").query().where("byStatus").equals("active").filter(s=>s.name.includes("a")).toArray()).map(s=>s.name)},code:`
// Best practice: narrow with index first, then filter
const results = await store.query()
  .where('byStatus').equals('active')  // Fast: uses index
  .filter(u => u.email.endsWith('@gmail.com'))  // Then: post-filter
  .toArray()

// This is more efficient than filtering all records
`.trim()}}async function He(r){const e=r.store("users"),t=await e.query().where("byAge").greaterThanOrEqual(0).orderBy("ascending").toArray(),s=await e.query().where("byAge").greaterThanOrEqual(0).orderBy("descending").toArray(),n=await e.query().limit(2).offset(0).toArray(),o=await e.query().limit(2).offset(2).toArray();return{success:!0,message:"orderBy() and limit/offset pagination",data:{ascending:t.map(a=>({name:a.name,age:a.age})),descending:s.map(a=>({name:a.name,age:a.age})),page1:n.map(a=>a.name),page2:o.map(a=>a.name)},code:`
// Ascending order (default)
const ascending = await store.query()
  .where('byAge').greaterThanOrEqual(0)
  .orderBy('ascending')
  .toArray()

// Descending order
const descending = await store.query()
  .orderBy('descending')
  .toArray()

// Pagination
const page1 = await store.query().limit(10).offset(0).toArray()
const page2 = await store.query().limit(10).offset(10).toArray()
`.trim()}}async function Ge(r){const e=r.store("users"),t=await e.query().where("byStatus").equals("active").toArray(),s=await e.query().where("byStatus").equals("active").first(),n=await e.query().where("byStatus").equals("active").count(),o=await e.query().where("byStatus").equals("active").keys();return{success:!0,message:"Terminal operations: toArray, first, count, keys",data:{allCount:t.length,first:s?.name??"none",count:n,keys:o},code:`
// Get all matching records
const records = await query.toArray()

// Get first match only (more efficient)
const first = await query.first()

// Count matches (without loading data)
const count = await query.count()

// Get keys only (more efficient than full records)
const keys = await query.keys()

// Memory-efficient iteration
for await (const record of query.iterate()) {
  processRecord(record)
  if (done) break  // Early termination supported
}
`.trim()}}async function We(r){const e=r.store("users"),t=[];for await(const n of e.query().where("byStatus").equals("active").iterate())t.push(n.name);let s;for await(const n of e.query().iterate())if(n.status==="active"){s=n.name;break}return{success:!0,message:"iterate() - Memory-efficient async generator",data:{iteratedNames:t,firstActive:s},code:`
// Memory-efficient iteration
for await (const user of store.query().iterate()) {
  processUser(user)
  if (done) break  // Clean early termination
}

// Only one record in memory at a time
// Great for large datasets
`.trim()}}async function Qe(r){const e=r.store("posts"),t=await e.query().where("byPublished").equals(!0).toArray(),s=await e.query().where("byPublished").equals(!1).toArray();return{success:!0,message:"Boolean queries - Automatic fallback to filter",data:{publishedPosts:t.map(n=>n.title),draftPosts:s.map(n=>n.title)},code:`
// Boolean values are NOT valid IndexedDB keys
// The library automatically handles this

const published = await store.query()
  .where('byPublished').equals(true)  // Works! Falls back to filter
  .toArray()

// This is equivalent to:
const published = await store.query()
  .filter(post => post.published === true)
  .toArray()

// For better performance, consider storing as 0/1 instead
`.trim()}}async function Je(r){let e=0,t=0,s="";return await r.read(["users","posts"],async n=>{const o=await n.store("users").all(),a=await n.store("posts").all();e=o.length,t=a.length,s=o[0]?.name??"none"}),{success:!0,message:"db.read() - Consistent reads across stores",data:{userCount:e,postCount:t,firstUser:s},code:`
// Read transaction - consistent view
await db.read(['users', 'posts'], async (tx) => {
  const users = await tx.store('users').all()
  const posts = await tx.store('posts').all()
  // Both reads see the same snapshot
})

// Single store reads can use store directly
const user = await db.store('users').get('u1')
`.trim()}}async function ze(r){await r.store("posts").set([...Q]);let e="",t="";return await r.write(["users","posts"],async s=>{const n=await s.store("users").resolve("u1");t=n.name;const o={id:"tx-post",title:"Transaction Demo Post",content:"Created in a transaction",authorId:n.id,published:!0,views:0,createdAt:Date.now()};await s.store("posts").set(o),e=o.id}),await r.store("posts").remove("tx-post"),{success:!0,message:"db.write() - Atomic multi-store modifications",data:{createdPostId:e,authorName:t},code:`
// Write transaction - atomic modifications
await db.write(['users', 'posts'], async (tx) => {
  const user = await tx.store('users').resolve('u1')

  await tx.store('posts').set({
    id: crypto.randomUUID(),
    title: 'New Post',
    authorId: user.id,
    // ...
  })

  // Transaction commits on success
  // Aborts on any error (all changes rolled back)
})
`.trim()}}async function Xe(r){return await r.write(["settings"],async e=>{await e.store("settings").set({id:"durability-test",key:"test",value:"relaxed",updatedAt:Date.now()})},{durability:"relaxed"}),await r.store("settings").remove("durability-test"),{success:!0,message:"Transaction durability options",data:{durabilityLevels:["default","strict","relaxed"]},code:`
// Durability options control when transaction is considered complete

// 'default' - OS/browser default behavior
await db.write(['logs'], async (tx) => {
  await tx.store('logs').set(entry)
})

// 'strict' - Wait for data to be flushed to disk
await db.write(['critical'], async (tx) => {
  await tx.store('critical').set(data)
}, { durability: 'strict' })

// 'relaxed' - May return before data is flushed (faster)
await db.write(['logs'], async (tx) => {
  await tx.store('logs').set(entry)
}, { durability: 'relaxed' })
`.trim()}}async function Ye(r){let e="",t=[],s=!1;return await r.read(["users","posts"],n=>{e=n.getMode(),t=n.getStoreNames(),s=n.isActive()}),{success:!0,message:"Transaction accessor methods",data:{mode:e,storeNames:t,isActive:s},code:`
await db.read(['users', 'posts'], async (tx) => {
  tx.getMode()         // 'readonly' | 'readwrite'
  tx.getStoreNames()   // ['users', 'posts']
  tx.isActive()        // true (while in operation)
  tx.isFinished()      // false (until complete/abort)
})
`.trim()}}async function Ze(r){const e=await r.store("settings").count();let t=!1;try{await r.write(["settings"],async n=>{await n.store("settings").set({id:"abort-test",key:"abort",value:"should be rolled back",updatedAt:Date.now()}),n.abort()})}catch{t=!0}const s=await r.store("settings").count();return{success:!0,message:"Transaction abort - rolls back all changes",data:{beforeCount:e,afterCount:s,errorCaught:t,recordsAdded:s-e},code:`
await db.write(['users'], async (tx) => {
  await tx.store('users').set(user1)
  await tx.store('users').set(user2)

  if (someCondition) {
    tx.abort()  // Roll back ALL changes
  }
})

// Also aborts on any thrown error:
await db.write(['users'], async (tx) => {
  await tx.store('users').set(user)
  throw new Error('Something went wrong')
  // Transaction is automatically aborted
})
`.trim()}}async function et(r){let e="";return await r.read(["users"],t=>{e=t.native.mode}),{success:!0,message:"Native IDBTransaction access",data:{nativeMode:e},code:`
await db.write(['users'], async (tx) => {
  // Access native IDBTransaction
  const nativeTx = tx.native

  // Use native APIs when needed
  nativeTx.mode           // 'readonly' | 'readwrite'
  nativeTx.objectStoreNames  // DOMStringList
  nativeTx.db             // IDBDatabase
})
`.trim()}}async function tt(r){const e=r.store("users"),t=[];for await(const n of e.iterate())t.push(n.name);const s=[];for await(const n of e.iterate({direction:"previous"}))s.push(n.name);return{success:!0,message:"iterate() - Memory-efficient async generator",data:{names:t,reversedNames:s},code:`
// Simple iteration
for await (const user of store.iterate()) {
  console.log(user.name)
}

// With options
for await (const user of store.iterate({
  direction: 'previous',  // Reverse order
  query: IDBKeyRange.bound('a', 'm')  // Filter by key range
})) {
  console.log(user.name)
}

// Early termination is clean
for await (const user of store.iterate()) {
  if (found) break  // Resources properly cleaned up
}
`.trim()}}async function st(r){const e=r.store("users"),t=[];for await(const s of e.iterateKeys())t.push(JSON.stringify(s));return{success:!0,message:"iterateKeys() - Efficient key-only iteration",data:{keys:t},code:`
// Key-only iteration - more efficient than full records
for await (const key of store.iterateKeys()) {
  console.log(key)
}

// Use when you only need keys, not full records
// Doesn't load record data = less memory, faster
`.trim()}}async function rt(r){const e=r.store("users"),t=[];let s=await e.openCursor();for(;s;)t.push({key:s.getKey(),name:s.getValue().name}),s=await s.continue();return{success:!0,message:"openCursor() - Manual cursor control",data:{recordCount:t.length,records:t},code:`
// Manual cursor for full control
let cursor = await store.openCursor()

while (cursor) {
  const key = cursor.getKey()
  const primaryKey = cursor.getPrimaryKey()
  const value = cursor.getValue()
  const direction = cursor.getDirection()

  console.log(\`\${key}: \${value.name}\`)

  cursor = await cursor.continue()
}
`.trim()}}async function nt(r){await r.store("users").set({id:"cursor-test-1",name:"Cursor Test User 1",email:"cursor1@test.com",age:99,status:"inactive",role:"guest",tags:["test"],createdAt:Date.now()}),await r.store("users").set({id:"cursor-test-2",name:"Cursor Test User 2",email:"cursor2@test.com",age:98,status:"inactive",role:"guest",tags:["test"],createdAt:Date.now()});let e=0,t=0;return await r.write(["users"],async s=>{let n=await s.store("users").openCursor();for(;n;){const o=n.getValue();o.id==="cursor-test-1"?(await n.update({...o,name:"Updated via Cursor"}),e++):o.id==="cursor-test-2"&&(await n.delete(),t++),n=await n.continue()}}),await r.store("users").remove("cursor-test-1"),{success:!0,message:"Cursor mutation - Update and delete during iteration",data:{updated:e,deleted:t},code:`
// Use write transaction for cursor mutations
await db.write(['users'], async (tx) => {
  let cursor = await tx.store('users').openCursor()

  while (cursor) {
    const user = cursor.getValue()

    if (user.status === 'inactive') {
      // Delete during iteration
      await cursor.delete()
    } else if (user.needsUpdate) {
      // Update during iteration
      await cursor.update({ ...user, updatedAt: Date.now() })
    }

    cursor = await cursor.continue()
  }
})
`.trim()}}async function ot(r){const e=r.store("users"),t=[];let s=await e.openCursor();s&&(t.push(s.getValue().name),s=await s.continue(),s&&t.push(s.getValue().name));const n=[];return s=await e.openCursor(),s&&(n.push(s.getValue().name),s=await s.advance(2),s&&n.push(`(after skip 2) ${s.getValue().name}`)),{success:!0,message:"Cursor navigation methods",data:{continued:t,advanced:n},code:`
let cursor = await store.openCursor()

// Continue to next record
cursor = await cursor.continue()

// Continue to specific key
cursor = await cursor.continue('u5')

// Skip N records
cursor = await cursor.advance(5)

// For index cursors: continue to specific primary key
// cursor = await cursor.continuePrimaryKey(indexKey, primaryKey)
`.trim()}}async function at(r){const e=r.store("users"),t=[];for await(const n of e.iterate({direction:"next"}))t.push(n.name);const s=[];for await(const n of e.iterate({direction:"previous"}))s.push(n.name);return{success:!0,message:"Cursor directions",data:{forward:t,backward:s,directions:["next","nextunique","previous","previousunique"]},code:`
// Direction options:
// 'next'           - Ascending, include duplicates (default)
// 'nextunique'     - Ascending, skip duplicates
// 'previous'       - Descending, include duplicates
// 'previousunique' - Descending, skip duplicates

for await (const user of store.iterate({ direction: 'previous' })) {
  console.log(user.name)  // Reverse order
}
`.trim()}}async function it(r){const e=r.store("users"),t=[];let s=await e.openKeyCursor();for(;s;)t.push(JSON.stringify(s.getKey())),s=await s.continue();return{success:!0,message:"Key cursor - Efficient key-only access",data:{keys:t},code:`
// Key cursor doesn't load record values
// More efficient when you only need keys

let keyCursor = await store.openKeyCursor()

while (keyCursor) {
  const key = keyCursor.getKey()
  const primaryKey = keyCursor.getPrimaryKey()
  const direction = keyCursor.getDirection()

  console.log(key)

  keyCursor = await keyCursor.continue()
}
`.trim()}}async function ct(r){const t=r.store("users").index("byStatus"),s=[];for await(const n of t.iterate({query:IDBKeyRange.only("active")}))s.push({indexKey:"active",primaryKey:n.id,name:n.name});return{success:!0,message:"Index cursors - Iterate through index",data:{activeUsers:s},code:`
const statusIndex = store.index('byStatus')

// Iterate through index
for await (const user of statusIndex.iterate({
  query: IDBKeyRange.only('active')
})) {
  console.log(user.name)
}

// Manual index cursor
let cursor = await statusIndex.openCursor()
while (cursor) {
  // cursor.getKey() returns index key
  // cursor.getPrimaryKey() returns primary key
  // cursor.getValue() returns full record
  cursor = await cursor.continue()
}
`.trim()}}const I=[];async function ut(r){I.length=0;const e=[],t=r.onChange(s=>{I.push({...s,timestamp:Date.now()})});return e.push(t),await r.store("settings").set({id:"event-test",key:"test",value:"trigger-change",updatedAt:Date.now()}),await r.store("settings").remove("event-test"),await new Promise(s=>setTimeout(s,50)),e.forEach(s=>s()),{success:!0,message:"db.onChange() - Database-level change events",data:{events:I.map(s=>({storeName:s.storeName,type:s.type,keys:s.keys,source:s.source}))},code:`
// Subscribe to all changes across all stores
const unsubscribe = db.onChange((event) => {
  console.log(\`\${event.storeName}: \${event.type}\`, event.keys)

  if (event.source === 'remote') {
    // Change from another tab
    refreshUI()
  }
})

// Event structure:
// {
//   storeName: string,      // Store that changed
//   type: 'set' | 'add' | 'remove' | 'clear',
//   keys: ValidKey[],       // Affected keys
//   source: 'local' | 'remote'  // Origin
// }

// Cleanup when done
unsubscribe()
`.trim()}}async function dt(r){I.length=0;const e=[],t=r.store("settings").onChange(s=>{I.push({...s,timestamp:Date.now()})});return e.push(t),await r.store("settings").set({id:"store-event-test",key:"test",value:"store-level",updatedAt:Date.now()}),await r.store("users").set({id:"no-trigger",name:"No Trigger",email:"no@trigger.com",age:0,status:"inactive",role:"guest",tags:[],createdAt:Date.now()}),await new Promise(s=>setTimeout(s,50)),await r.store("settings").remove("store-event-test"),await r.store("users").remove("no-trigger"),e.forEach(s=>s()),{success:!0,message:"store.onChange() - Store-level change events",data:{settingsEvents:I.length,events:I.map(s=>({type:s.type,keys:s.keys}))},code:`
// Subscribe to specific store changes only
const unsubscribe = db.store('users').onChange((event) => {
  if (event.type === 'set') {
    invalidateCache(event.keys)
  }
})

// Only triggers for changes to this store
// More efficient than database-level when targeting one store

unsubscribe()
`.trim()}}function lt(r){return{success:!0,message:"Cross-tab synchronization via BroadcastChannel",data:{crossTabSyncEnabled:!0,howToTest:"Open this page in another tab and make changes"},code:`
// Cross-tab sync is enabled by default
const db = createDatabase<AppSchema>({
  name: 'myApp',
  version: 1,
  stores: { users: {} },
  crossTabSync: true  // Default: true
})

// Changes in Tab 1
await db.store('users').set({ id: 'u1', name: 'Alice' })

// Tab 2 receives change event with source: 'remote'
db.onChange((event) => {
  if (event.source === 'remote') {
    console.log('Another tab made changes:', event)
    refreshUI()
  }
})

// Disable if not needed (saves resources)
const db = createDatabase({
  // ...
  crossTabSync: false
})
`.trim()}}function mt(r){const e=[];return r.onError(s=>{e.push(s.message)})(),{success:!0,message:"db.onError() - Error event handling",data:{subscribedToErrors:!0,note:"Errors are captured for logging/analytics"},code:`
// Subscribe to error events
const unsubscribe = db.onError((error) => {
  console.error('Database error:', error)
  reportToAnalytics(error)
})

// Useful for:
// - Centralized error logging
// - Analytics
// - User notifications
// - Error recovery strategies

unsubscribe()
`.trim()}}function ht(r){let e=!1;return r.onVersionChange(()=>{e=!0})(),{success:!0,message:"db.onVersionChange() - Handle version upgrades",data:{subscribedToVersionChange:!0,versionChangeReceived:e},code:`
// Triggered when another tab wants to upgrade the database
const unsubscribe = db.onVersionChange((event) => {
  console.log(\`Upgrade requested: v\${event.oldVersion} -> v\${event.newVersion}\`)

  // Typically close connection to allow upgrade
  showNotification('Updating app, please wait...')
  db.close()
})

// Important for:
// - Graceful handling of database upgrades
// - User communication during upgrades
// - Preventing upgrade blocking

unsubscribe()
`.trim()}}function yt(r){let e=!1;return r.onClose(()=>{e=!0})(),{success:!0,message:"db.onClose() - Handle connection close",data:{subscribedToClose:!0,closeReceived:e},code:`
// Triggered when database connection closes
const unsubscribe = db.onClose(() => {
  console.log('Database connection closed')

  // Reconnect or show offline message
  showOfflineMessage()
})

// Useful for:
// - Cleanup resources
// - Show offline indicators
// - Reconnection logic

unsubscribe()
`.trim()}}function pt(){return{success:!0,message:"Event hooks in database options",data:{availableHooks:["onChange","onError","onBlocked","onVersionChange","onClose"]},code:`
// Set up event handlers at creation time
const db = createDatabase<AppSchema>({
  name: 'myApp',
  version: 1,
  stores: { users: {} },

  // Event hooks
  onChange: (event) => {
    console.log('Change:', event)
    syncToUI()
  },

  onError: (error) => {
    console.error('Error:', error)
    reportError(error)
  },

  onBlocked: () => {
    console.warn('Upgrade blocked by other tabs')
    showCloseTabsMessage()
  },

  onVersionChange: (event) => {
    console.log('Version change:', event)
    prepareForUpgrade()
  },

  onClose: () => {
    console.log('Connection closed')
    showOfflineStatus()
  }
})
`.trim()}}async function gt(r){const e=r.store("users");let t=null;try{await e.resolve("nonexistent-user")}catch(s){s instanceof k&&(t={name:s.name,code:s.code,key:JSON.stringify(s.key),storeName:s.storeName})}return{success:!0,message:"NotFoundError - Thrown by resolve() for missing records",data:{errorDetails:t},code:`
try {
  const user = await store.resolve('nonexistent')
} catch (error) {
  if (error instanceof NotFoundError) {
    console.log(\`Key: \${error.key}\`)
    console.log(\`Store: \${error.storeName}\`)
    console.log(\`Code: \${error.code}\`)  // 'NOT_FOUND'
  }
}

// NotFoundError properties:
// - code: 'NOT_FOUND'
// - key: ValidKey - The missing key
// - storeName: string - The store name
`.trim()}}async function ft(r){const e=r.store("users");let t=null;await e.set({id:"constraint-test",name:"Constraint Test",email:"constraint@test.com",age:30,status:"active",role:"user",tags:[],createdAt:Date.now()});try{await e.add({id:"constraint-test",name:"Duplicate",email:"dupe@test.com",age:25,status:"active",role:"user",tags:[],createdAt:Date.now()})}catch(s){s instanceof L&&(t={name:s.name,code:s.code,key:JSON.stringify(s.key)})}return await e.remove("constraint-test"),{success:!0,message:"ConstraintError - Thrown by add() for duplicate keys",data:{errorDetails:t},code:`
try {
  await store.add({ id: 'existing', name: 'Duplicate' })
} catch (error) {
  if (error instanceof ConstraintError) {
    console.log('Key already exists:', error.key)

    // Common pattern: fallback to set() for upsert
    await store.set({ id: 'existing', name: 'Updated' })
  }
}

// ConstraintError properties:
// - code: 'CONSTRAINT_ERROR'
// - key: ValidKey - The conflicting key
// - storeName: string - The store name
`.trim()}}function wt(){return{success:!0,message:"Error codes for different failure modes",data:{errorCodes:["NOT_FOUND","CONSTRAINT_ERROR","QUOTA_EXCEEDED","TRANSACTION_ABORTED","TRANSACTION_INACTIVE","OPEN_FAILED","UPGRADE_FAILED","UPGRADE_BLOCKED","DATA_ERROR","READ_ONLY","VERSION_ERROR","INVALID_STATE","TIMEOUT","UNKNOWN_ERROR"]},code:`
// All database errors have a code property
type DatabaseErrorCode =
  | 'OPEN_FAILED'           // Database failed to open
  | 'UPGRADE_FAILED'        // Migration or store creation failed
  | 'UPGRADE_BLOCKED'       // Other connections prevent upgrade
  | 'TRANSACTION_ABORTED'   // Transaction was aborted
  | 'TRANSACTION_INACTIVE'  // Operation on inactive transaction
  | 'CONSTRAINT_ERROR'      // Key/uniqueness constraint violated
  | 'QUOTA_EXCEEDED'        // Storage quota exceeded
  | 'NOT_FOUND'             // Record not found (resolve())
  | 'DATA_ERROR'            // Invalid data format
  | 'READ_ONLY'             // Write attempted on readonly transaction
  | 'VERSION_ERROR'         // Version conflict
  | 'INVALID_STATE'         // Database in invalid state
  | 'TIMEOUT'               // Operation timed out
  | 'UNKNOWN_ERROR'         // Unrecognized error
`.trim()}}async function vt(r){const e=r.store("users");let t=!1,s=!1,n=!1,o=!1;try{await e.resolve("nonexistent")}catch(a){t=F(a),n=he(a),o=ye(a,"NOT_FOUND")}await e.set({id:"guard-test",name:"Guard Test",email:"guard@test.com",age:30,status:"active",role:"user",tags:[],createdAt:Date.now()});try{await e.add({id:"guard-test",name:"Duplicate",email:"dupe@test.com",age:25,status:"active",role:"user",tags:[],createdAt:Date.now()})}catch(a){s=_(a)}return await e.remove("guard-test"),{success:!0,message:"Type guards for safe error handling",data:{isNotFoundError:t,isConstraintError:s,isDatabaseError:n,hasErrorCode:o},code:`
import {
  isDatabaseError,
  isNotFoundError,
  isConstraintError,
  isQuotaExceededError,
  isTransactionError,
  hasErrorCode
} from '@mikesaintsg/indexeddb'

try {
  await store.resolve('u1')
} catch (error) {
  if (isNotFoundError(error)) {
    // error is typed as NotFoundError
    console.log(error.key, error.storeName)
  } else if (isConstraintError(error)) {
    // error is typed as ConstraintError
    console.log(error.key)
  } else if (isDatabaseError(error)) {
    // error is typed as DatabaseError
    console.log(error.code, error.message)
  }

  // Check for specific error code
  if (hasErrorCode(error, 'QUOTA_EXCEEDED')) {
    showStorageFullMessage()
  }
}
`.trim()}}function bt(){return{success:!0,message:"Error class hierarchy",data:{hierarchy:["DatabaseError (base)","  ââ NotFoundError","  ââ ConstraintError","  ââ QuotaExceededError","  ââ TransactionError","  ââ UpgradeError","  ââ OpenError","  ââ DataError","  ââ ReadOnlyError","  ââ VersionError","  ââ InvalidStateError","  ââ TimeoutError"]},code:`
// Error class hierarchy:
// DatabaseError (base) â all database errors
//   ââ NotFoundError â resolve() when record missing
//   ââ ConstraintError â add() when key exists
//   ââ QuotaExceededError â storage quota exceeded
//   ââ TransactionError â transaction aborted or inactive
//   ââ UpgradeError â database upgrade failed or blocked
//   ââ OpenError â database failed to open
//   ââ DataError â invalid data format
//   ââ ReadOnlyError â write on readonly transaction
//   ââ VersionError â version conflict
//   ââ InvalidStateError â invalid database state
//   ââ TimeoutError â operation timed out

// All errors extend DatabaseError
if (error instanceof DatabaseError) {
  console.log(error.code)     // Error code
  console.log(error.message)  // Error message
  console.log(error.cause)    // Original error (if wrapped)
}
`.trim()}}async function xt(r){const e=r.store("users"),t=[],s=await e.get("nonexistent");t.push(`get() returns: ${s===void 0?"undefined":"value"}`);try{await e.resolve("nonexistent")}catch(n){F(n)&&t.push("resolve() throws NotFoundError")}await e.set({id:"error-demo",name:"Demo",email:"demo@test.com",age:30,status:"active",role:"user",tags:[],createdAt:Date.now()});try{await e.add({id:"error-demo",name:"Duplicate",email:"dupe@test.com",age:25,status:"active",role:"user",tags:[],createdAt:Date.now()})}catch(n){_(n)&&t.push("add() throws ConstraintError")}return await e.remove("error-demo"),{success:!0,message:"Comprehensive error handling patterns",data:{results:t},code:`
// Comprehensive error handling pattern
async function safeOperation() {
  try {
    const user = await store.resolve('u1')
    await store.add(newRecord)
  } catch (error) {
    if (isNotFoundError(error)) {
      // Handle missing record
      return createDefault()
    }

    if (isConstraintError(error)) {
      // Handle duplicate key
      return store.set(record)  // Fallback to upsert
    }

    if (isQuotaExceededError(error)) {
      // Handle storage full
      await clearOldData()
      return retry()
    }

    if (isTransactionError(error)) {
      // Handle transaction failure
      await retry()
    }

    // Unknown error - rethrow
    throw error
  }
}
`.trim()}}function Et(){let r;return{html:`
			<div class="demo-app contact-manager">
				<h4>ð Contact Manager</h4>
				<p class="demo-desc">Add, edit, and delete contacts using <code>set()</code>, <code>get()</code>, and <code>remove()</code></p>

				<div class="demo-form">
					<input type="text" id="contact-name" placeholder="Name" class="demo-input" />
					<input type="email" id="contact-email" placeholder="Email" class="demo-input" />
					<input type="number" id="contact-age" placeholder="Age" class="demo-input" min="1" max="120" />
					<button id="add-contact-btn" class="btn primary">â Add Contact</button>
				</div>

				<div class="demo-stats" id="contact-stats">
					<span class="stat">Total: <strong id="total-contacts">0</strong></span>
					<span class="stat">Active: <strong id="active-contacts">0</strong></span>
				</div>

				<div class="demo-list" id="contact-list">
					<p class="placeholder">Loading contacts...</p>
				</div>

				<div class="demo-log" id="contact-log"></div>
			</div>
		`,init:async(e,t)=>{const s=t.store("users"),n=e.querySelector("#contact-list"),o=e.querySelector("#contact-log"),a=e.querySelector("#total-contacts"),i=e.querySelector("#active-contacts"),c=e.querySelector("#contact-name"),u=e.querySelector("#contact-email"),d=e.querySelector("#contact-age"),m=e.querySelector("#add-contact-btn");function l(g,y="info"){const p=document.createElement("div");p.className=`log-entry ${y}`,p.textContent=`${new Date().toLocaleTimeString()} - ${g}`,o.insertBefore(p,o.firstChild),o.children.length>5&&o.lastChild&&o.removeChild(o.lastChild)}async function f(){const g=await s.all(),y=g.filter(p=>p.status==="active").length;if(a.textContent=String(g.length),i.textContent=String(y),g.length===0){n.innerHTML='<p class="placeholder">No contacts yet. Add one above!</p>';return}n.innerHTML=g.map(p=>`
					<div class="list-item" data-id="${p.id}">
						<div class="item-info">
							<strong>${p.name}</strong>
							<span class="item-meta">${p.email} â¢ Age ${p.age} â¢ ${p.status}</span>
						</div>
						<div class="item-actions">
							<button class="btn small toggle-status" data-id="${p.id}" title="Toggle Status">
								${p.status==="active"?"â":"â"}
							</button>
							<button class="btn small danger delete-contact" data-id="${p.id}" title="Delete">ðï¸</button>
						</div>
					</div>
				`).join(""),n.querySelectorAll(".toggle-status").forEach(p=>{const v=p;v.onclick=()=>{const C=v.dataset.id??"";s.get(C).then(async b=>{if(b){const T={...b,status:b.status==="active"?"inactive":"active"};await s.set(T),l(`set() - Toggled ${b.name} to ${T.status}`,"success")}}).catch(b=>{l(`Error: ${b instanceof Error?b.message:"Unknown"}`,"error")})}}),n.querySelectorAll(".delete-contact").forEach(p=>{const v=p;v.onclick=()=>{const C=v.dataset.id??"";s.get(C).then(async b=>{await s.remove(C),l(`remove() - Deleted ${b?.name??C}`,"success")}).catch(b=>{l(`Error: ${b instanceof Error?b.message:"Unknown"}`,"error")})}})}m.onclick=()=>{const g=c.value.trim(),y=u.value.trim(),p=parseInt(d.value,10);if(!g||!y||isNaN(p)){l("Please fill all fields","error");return}const v={id:`u-${Date.now()}`,name:g,email:y,age:p,status:"active",role:"user",tags:[],createdAt:Date.now()};s.set(v).then(()=>{l(`set() - Added "${g}"`,"success"),c.value="",u.value="",d.value=""})},r=s.onChange(()=>{f()}),await f(),l("Contact Manager ready!","info")},cleanup:()=>{r?.()}}}function At(){return{html:`
			<div class="demo-app user-search">
				<h4>ð User Search</h4>
				<p class="demo-desc">Search and filter users with <code>where()</code>, <code>filter()</code>, and <code>orderBy()</code></p>

				<div class="demo-filters">
					<input type="text" id="search-name" placeholder="Search by name..." class="demo-input" />
					<select id="filter-status" class="demo-select">
						<option value="">All Statuses</option>
						<option value="active">Active</option>
						<option value="inactive">Inactive</option>
					</select>
					<select id="filter-role" class="demo-select">
						<option value="">All Roles</option>
						<option value="admin">Admin</option>
						<option value="user">User</option>
						<option value="guest">Guest</option>
					</select>
				</div>

				<div class="demo-stats">
					<span class="stat">Results: <strong id="search-count">0</strong></span>
					<span class="stat">Query time: <strong id="search-time">0</strong>ms</span>
				</div>

				<div class="query-display" id="query-display">
					<strong>Query:</strong> <code id="query-code">store.all()</code>
				</div>

				<div class="demo-list" id="search-results">
					<p class="placeholder">Enter search criteria above...</p>
				</div>
			</div>
		`,init:(r,e)=>{const t=e.store("users"),s=r.querySelector("#search-results"),n=r.querySelector("#search-count"),o=r.querySelector("#search-time"),a=r.querySelector("#query-code"),i=r.querySelector("#search-name"),c=r.querySelector("#filter-status"),u=r.querySelector("#filter-role");async function d(){const f=i.value.toLowerCase().trim(),g=c.value,y=u.value,p=performance.now();let v=t.query();const C=["store.query()"];g&&(v=v.where("byStatus").equals(g),C.push(`.where('byStatus').equals('${g}')`)),f&&(v=v.filter(S=>S.name.toLowerCase().includes(f)),C.push(`.filter(u => u.name.includes('${f}'))`)),y&&(v=v.filter(S=>S.role===y),C.push(`.filter(u => u.role === '${y}')`)),C.push(".toArray()");const b=await v.toArray(),T=Math.round(performance.now()-p);if(n.textContent=String(b.length),o.textContent=String(T),a.textContent=C.join(`
  `),b.length===0){s.innerHTML='<p class="placeholder">No users match your criteria</p>';return}s.innerHTML=b.map(S=>`
					<div class="list-item">
						<div class="item-info">
							<strong>${S.name}</strong>
							<span class="item-meta">${S.email} â¢ Age ${S.age} â¢ ${S.status} â¢ ${S.role}</span>
						</div>
					</div>
				`).join("")}let m;function l(){clearTimeout(m),m=setTimeout(()=>{d()},150)}i.oninput=l,c.onchange=l,u.onchange=l,d()}}}function Ct(){return{html:`
			<div class="demo-app shopping-cart">
				<h4>ð Shopping Cart</h4>
				<p class="demo-desc">Atomic checkout with <code>write()</code> transaction - all operations succeed or all fail</p>

				<div class="cart-layout">
					<div class="cart-products">
						<h5>Products</h5>
						<div class="product-list">
							<div class="product-item" data-id="prod1">
								<span class="product-name">ð± Smartphone</span>
								<span class="product-price">$599</span>
								<button class="btn small add-to-cart" data-id="prod1" data-name="Smartphone" data-price="599">Add</button>
							</div>
							<div class="product-item" data-id="prod2">
								<span class="product-name">ð» Laptop</span>
								<span class="product-price">$1299</span>
								<button class="btn small add-to-cart" data-id="prod2" data-name="Laptop" data-price="1299">Add</button>
							</div>
							<div class="product-item" data-id="prod3">
								<span class="product-name">ð§ Headphones</span>
								<span class="product-price">$199</span>
								<button class="btn small add-to-cart" data-id="prod3" data-name="Headphones" data-price="199">Add</button>
							</div>
						</div>
					</div>

					<div class="cart-summary">
						<h5>Cart</h5>
						<div id="cart-items" class="cart-items">
							<p class="placeholder">Cart is empty</p>
						</div>
						<div class="cart-total">
							Total: <strong>$<span id="cart-total">0</span></strong>
						</div>
						<button id="checkout-btn" class="btn primary" disabled>â Checkout (Atomic)</button>
						<button id="checkout-fail-btn" class="btn danger" disabled>â Simulate Failure</button>
					</div>
				</div>

				<div class="demo-log" id="cart-log"></div>
			</div>
		`,init:(r,e)=>{const t=r.querySelector("#cart-items"),s=r.querySelector("#cart-total"),n=r.querySelector("#cart-log"),o=r.querySelector("#checkout-btn"),a=r.querySelector("#checkout-fail-btn"),i=new Map;function c(d,m="info"){const l=document.createElement("div");l.className=`log-entry ${m}`,l.textContent=`${new Date().toLocaleTimeString()} - ${d}`,n.insertBefore(l,n.firstChild),n.children.length>8&&n.lastChild&&n.removeChild(n.lastChild)}function u(){const d=Array.from(i.values()),m=d.reduce((l,f)=>l+f.price*f.quantity,0);if(s.textContent=String(m),o.disabled=d.length===0,a.disabled=d.length===0,d.length===0){t.innerHTML='<p class="placeholder">Cart is empty</p>';return}t.innerHTML=d.map(l=>`
					<div class="cart-item">
						<span>${l.name} x${l.quantity}</span>
						<span>$${l.price*l.quantity}</span>
						<button class="btn small danger remove-item" data-id="${l.id}">Ã</button>
					</div>
				`).join(""),t.querySelectorAll(".remove-item").forEach(l=>{const f=l;f.onclick=()=>{const g=f.dataset.id??"",y=i.get(g);y&&y.quantity>1?i.set(g,{...y,quantity:y.quantity-1}):i.delete(g),u(),c(`Removed ${y?.name??"item"} from cart`)}})}r.querySelectorAll(".add-to-cart").forEach(d=>{const m=d;m.onclick=()=>{const l=m.dataset.id??"",f=m.dataset.name??"",g=parseInt(m.dataset.price??"0",10),y=i.get(l);y?i.set(l,{...y,quantity:y.quantity+1}):i.set(l,{id:l,name:f,price:g,quantity:1}),u(),c(`Added ${f} to cart`)}}),o.onclick=()=>{c("Starting atomic transaction...","info"),e.write(["settings"],async d=>{const m=d.store("settings"),l=Array.from(i.values()),f=`order-${Date.now()}`,g={id:f,key:"lastOrder",value:JSON.stringify({items:l.map(y=>({name:y.name,qty:y.quantity})),total:l.reduce((y,p)=>y+p.price*p.quantity,0)}),updatedAt:Date.now()};await m.set(g),c(`TX: Created order ${f}`,"info")}).then(()=>{c("â Transaction committed!","success"),i.clear(),u()}).catch(d=>{const m=d instanceof Error?d.message:"Unknown error";c(`â Transaction failed: ${m}`,"error")})},a.onclick=()=>{c("Starting transaction with failure...","info"),e.write(["settings"],async d=>{const m=d.store("settings"),l={id:"temp-checkout",key:"checkoutInProgress",value:"true",updatedAt:Date.now()};await m.set(l),c("TX: First operation succeeded","info"),c("TX: Aborting...","error"),d.abort()}).catch(()=>{c("â Transaction aborted! All changes rolled back.","error")})},u(),c("Shopping Cart ready!","info")}}}function St(){let r;return{html:`
			<div class="demo-app activity-monitor">
				<h4>ð¡ Live Activity Monitor</h4>
				<p class="demo-desc">Watch <code>onChange</code> events in real-time as data changes</p>

				<div class="monitor-controls">
					<button id="add-random-btn" class="btn primary">â Add User</button>
					<button id="update-random-btn" class="btn">âï¸ Update User</button>
					<button id="delete-random-btn" class="btn danger">ðï¸ Delete User</button>
				</div>

				<div class="monitor-stats">
					<span class="stat">Events: <strong id="event-count">0</strong></span>
					<span class="stat">Last: <strong id="last-event-type">-</strong></span>
				</div>

				<div class="event-feed" id="event-feed">
					<p class="placeholder">Waiting for events...</p>
				</div>

				<p class="demo-tip">ð¡ Open in another tab to see cross-tab sync!</p>
			</div>
		`,init:(e,t)=>{const s=e.querySelector("#event-feed"),n=e.querySelector("#event-count"),o=e.querySelector("#last-event-type"),a=e.querySelector("#add-random-btn"),i=e.querySelector("#update-random-btn"),c=e.querySelector("#delete-random-btn"),u=t.store("users");let d=0,m=!0;function l(y){d++,n.textContent=String(d),o.textContent=y.type,m&&(s.innerHTML="",m=!1);const p=document.createElement("div");p.className=`event-entry event-${y.type}`;const v=y.source==="remote"?'<span class="event-cross-tab">ð¡ Cross-Tab</span>':"";for(p.innerHTML=`
					<span class="event-time">${new Date().toLocaleTimeString()}</span>
					<span class="event-badge ${y.type}">${y.type.toUpperCase()}</span>
					<span class="event-store">${y.storeName}</span>
					<span class="event-keys">Keys: ${JSON.stringify(y.keys)}</span>
					${v}
				`,s.insertBefore(p,s.firstChild);s.children.length>10&&s.lastChild;)s.removeChild(s.lastChild)}r=t.onChange(y=>{l(y)});const f=["Alex","Jordan","Taylor","Morgan","Casey","Riley"],g=["Smith","Johnson","Williams","Brown","Jones"];a.onclick=()=>{const y=f[Math.floor(Math.random()*f.length)],p=g[Math.floor(Math.random()*g.length)],v=`${y} ${p}`,C={id:`u-${Date.now()}`,name:v,email:`${v.toLowerCase().replace(" ",".")}@example.com`,age:20+Math.floor(Math.random()*40),status:"active",role:"user",tags:[],createdAt:Date.now()};u.set(C).catch(()=>{})},i.onclick=()=>{u.all().then(async y=>{if(y.length===0)return;const p=y[Math.floor(Math.random()*y.length)];if(p){const v={...p,age:p.age+1};await u.set(v)}}).catch(()=>{})},c.onclick=()=>{u.all().then(async y=>{if(y.length===0)return;const p=y[Math.floor(Math.random()*y.length)];p&&await u.remove(p.id)}).catch(()=>{})}},cleanup:()=>{r?.()}}}function Nt(){return{html:`
			<div class="demo-app data-export">
				<h4>ð Data Export Tool</h4>
				<p class="demo-desc">Stream records with <code>iterate()</code> - memory efficient</p>

				<div class="export-controls">
					<select id="export-store" class="demo-select">
						<option value="users">Users</option>
						<option value="posts">Posts</option>
						<option value="settings">Settings</option>
					</select>
					<select id="export-format" class="demo-select">
						<option value="json">JSON</option>
						<option value="csv">CSV</option>
					</select>
					<button id="export-btn" class="btn primary">ð¤ Export</button>
				</div>

				<div class="export-progress" id="export-progress" style="display: none;">
					<div class="progress-bar">
						<div class="progress-fill" id="progress-fill" style="width: 0%"></div>
					</div>
					<span id="progress-text">0 records</span>
				</div>

				<div class="export-output">
					<h5>Preview</h5>
					<pre id="export-preview" class="code-preview"><code>Click Export to generate...</code></pre>
				</div>

				<div class="demo-log" id="export-log"></div>
			</div>
		`,init:(r,e)=>{const t=r.querySelector("#export-store"),s=r.querySelector("#export-format"),n=r.querySelector("#export-btn"),o=r.querySelector("#export-progress"),a=r.querySelector("#progress-fill"),i=r.querySelector("#progress-text"),c=r.querySelector("#export-preview code"),u=r.querySelector("#export-log");function d(m,l="info"){const f=document.createElement("div");f.className=`log-entry ${l}`,f.textContent=`${new Date().toLocaleTimeString()} - ${m}`,u.insertBefore(f,u.firstChild),u.children.length>5&&u.lastChild&&u.removeChild(u.lastChild)}n.onclick=()=>{const m=t.value,l=s.value;n.disabled=!0,o.style.display="block",a.style.width="0%";const f=e.store(m);(async()=>{try{const g=await f.count(),y=[];let p=0;d(`Exporting ${g} records from "${m}"...`);const v=performance.now();for await(const T of f.iterate()){y.push(T),p++;const S=Math.round(p/g*100);a.style.width=`${S}%`,i.textContent=`${p} / ${g}`,p%2===0&&await new Promise($=>setTimeout($,30))}const C=Math.round(performance.now()-v);d(`Completed: ${p} records in ${C}ms`,"success");let b;if(l==="json")b=JSON.stringify(y,null,2);else if(y.length===0)b="(no data)";else{const T=y[0],S=Object.keys(T),$=y.map(re=>{const ne=re;return S.map(oe=>JSON.stringify(ne[oe]??"")).join(",")});b=[S.join(","),...$].join(`
`)}c.textContent=b.length>1500?b.substring(0,1500)+`
... (truncated)`:b,n.disabled=!1}catch(g){d(`Export failed: ${g instanceof Error?g.message:"Unknown"}`,"error"),n.disabled=!1}})()}}}}function Tt(){return{html:`
			<div class="demo-app email-lookup">
				<h4>ð§ Email Lookup</h4>
				<p class="demo-desc">Fast O(1) lookups with <code>index().get()</code></p>

				<div class="lookup-form">
					<input type="email" id="lookup-email" placeholder="Enter email..." class="demo-input" list="email-suggestions" />
					<datalist id="email-suggestions">
						<option value="alice@example.com">
						<option value="bob@example.com">
						<option value="carol@example.com">
					</datalist>
					<button id="lookup-btn" class="btn primary">ð Lookup</button>
				</div>

				<div class="lookup-stats" id="lookup-stats" style="display: none;">
					<span class="stat">Time: <strong id="lookup-time">0</strong>ms</span>
				</div>

				<div class="lookup-result" id="lookup-result">
					<p class="placeholder">Enter an email to search...</p>
				</div>

				<div class="lookup-code">
					<h5>ð» Code</h5>
					<pre><code>// O(1) index lookup
const user = await store.index('byEmail').get('alice@example.com')</code></pre>
				</div>
			</div>
		`,init:(r,e)=>{const t=r.querySelector("#lookup-email"),s=r.querySelector("#lookup-btn"),n=r.querySelector("#lookup-result"),o=r.querySelector("#lookup-stats"),a=r.querySelector("#lookup-time"),i=e.store("users").index("byEmail");function c(){const u=t.value.trim();if(!u){n.innerHTML='<p class="placeholder">Enter an email to search...</p>',o.style.display="none";return}const d=performance.now();i.get(u).then(m=>{const l=performance.now()-d;o.style.display="flex",a.textContent=l.toFixed(2),m?n.innerHTML=`
							<div class="user-card found">
								<h5>â User Found</h5>
								<div class="user-details">
									<p><strong>Name:</strong> ${m.name}</p>
									<p><strong>Email:</strong> ${m.email}</p>
									<p><strong>Age:</strong> ${m.age}</p>
									<p><strong>Status:</strong> ${m.status}</p>
								</div>
							</div>
						`:n.innerHTML=`
							<div class="user-card not-found">
								<h5>â Not Found</h5>
								<p>No user with email "${u}"</p>
							</div>
						`})}s.onclick=c,t.onkeypress=u=>{u.key==="Enter"&&c()}}}}function kt(){return{html:`
			<div class="demo-app registration">
				<h4>ð User Registration</h4>
				<p class="demo-desc">Handle <code>ConstraintError</code> and <code>NotFoundError</code></p>

				<div class="registration-form">
					<input type="text" id="reg-name" placeholder="Full Name" class="demo-input" />
					<input type="email" id="reg-email" placeholder="Email (try alice@example.com)" class="demo-input" />
					<button id="reg-submit" class="btn primary">Create Account</button>
				</div>

				<div class="registration-result" id="reg-result"></div>

				<div class="error-demo-section">
					<h5>Try These Scenarios:</h5>
					<button class="btn small scenario-btn" data-scenario="duplicate">1. Duplicate Email</button>
					<button class="btn small scenario-btn" data-scenario="notfound">2. Missing User</button>
					<button class="btn small scenario-btn" data-scenario="success">3. Success</button>
				</div>

				<div class="demo-log" id="reg-log"></div>
			</div>
		`,init:(r,e)=>{const t=r.querySelector("#reg-name"),s=r.querySelector("#reg-email"),n=r.querySelector("#reg-submit"),o=r.querySelector("#reg-result"),a=r.querySelector("#reg-log"),i=e.store("users");function c(m,l="info"){const f=document.createElement("div");f.className=`log-entry ${l}`,f.textContent=`${new Date().toLocaleTimeString()} - ${m}`,a.insertBefore(f,a.firstChild),a.children.length>6&&a.lastChild&&a.removeChild(a.lastChild)}function u(m,l){o.innerHTML=`<div class="result-box ${l?"success":"error"}">${m}</div>`}async function d(m,l){try{await i.index("byEmail").get(l)&&c(`Email "${l}" already registered`,"error");const g={id:`u-${Date.now()}`,name:m,email:l,age:25,status:"active",role:"user",tags:[],createdAt:Date.now()};await i.add(g),c(`User "${m}" registered!`,"success"),u(`<h5>â Success!</h5><p>Welcome, ${m}!</p>`,!0)}catch(f){if(f instanceof Error&&f.name==="ConstraintError")c("ConstraintError: Duplicate key","error"),u(`<h5>â Failed</h5><p>Email "${l}" already exists.</p>`,!1);else{const g=f instanceof Error?f.message:"Unknown";c(`Error: ${g}`,"error"),u(`<h5>â Error</h5><p>${g}</p>`,!1)}}}n.onclick=()=>{const m=t.value.trim(),l=s.value.trim();if(!m||!l){c("Please fill all fields","error");return}d(m,l)},r.querySelectorAll(".scenario-btn").forEach(m=>{const l=m;l.onclick=()=>{switch(l.dataset.scenario){case"duplicate":t.value="Test User",s.value="alice@example.com",d("Test User","alice@example.com");break;case"notfound":c("Calling resolve() for missing user...","info"),i.resolve("nonexistent-id").catch(g=>{g instanceof Error&&g.name==="NotFoundError"&&(c("NotFoundError: User not found","error"),u("<h5>â NotFoundError</h5><p>User not found.</p>",!1))});break;case"success":{const g=`user-${Date.now()}@example.com`;t.value="New User",s.value=g,d("New User",g);break}}}}),c("Registration demo ready!","info")}}}let h,U="store";const K=[],ee=[],M=[],te=[{id:"store",emoji:"ð¦",label:"Store Operations",description:"CRUD: get, resolve, set, add, remove, has, all, keys, count, clear",demo:Et},{id:"index",emoji:"ð",label:"Index Operations",description:"Index queries, multi-entry indexes, unique constraints",demo:Tt},{id:"query",emoji:"ð",label:"Query Builder",description:"where, filter, orderBy, limit, offset, terminal operations",demo:At},{id:"transactions",emoji:"â¡",label:"Transactions",description:"read, write, durability, abort, multi-store atomic operations",demo:Ct},{id:"cursors",emoji:"â¡ï¸",label:"Cursors",description:"iterate, iterateKeys, openCursor, navigation, mutation",demo:Nt},{id:"events",emoji:"ð¡",label:"Events",description:"onChange, onError, cross-tab sync, version change",demo:St},{id:"errors",emoji:"â ï¸",label:"Error Handling",description:"Error classes, type guards, comprehensive patterns",demo:kt}];function Dt(r){switch(r){case"store":return[{id:"get",title:"get() - Optional Lookup",description:"Returns undefined for missing records",run:()=>Se(h)},{id:"resolve",title:"resolve() - Required Lookup",description:"Throws NotFoundError for missing records",run:()=>Ne(h)},{id:"set",title:"set() - Upsert",description:"Insert or update records",run:()=>Te(h)},{id:"add",title:"add() - Insert Only",description:"Throws ConstraintError if key exists",run:()=>ke(h)},{id:"remove",title:"remove() - Delete",description:"Silently succeeds for missing keys",run:()=>De(h)},{id:"has",title:"has() - Existence Check",description:"Check if records exist",run:()=>Ie(h)},{id:"bulk",title:"Bulk Operations",description:"all(), keys(), count()",run:()=>qe(h)},{id:"accessors",title:"Store Accessors",description:"getName, getKeyPath, getIndexNames",run:()=>Oe(h)}];case"index":return[{id:"accessors",title:"Index Accessors",description:"getName, getKeyPath, isUnique, isMultiEntry",run:()=>Pe(h)},{id:"lookup",title:"Index Lookup",description:"get, resolve, getKey by index",run:()=>Re(h)},{id:"nonunique",title:"Non-Unique Index",description:"Query non-unique index values",run:()=>Ue(h)},{id:"multientry",title:"Multi-Entry Index",description:"Index array elements separately",run:()=>$e(h)},{id:"range",title:"Range Queries",description:"Numeric range queries on index",run:()=>Be(h)},{id:"native",title:"Native Access",description:"Access native IDBIndex",run:()=>Ke(h)}];case"query":return[{id:"equals",title:"where().equals()",description:"Fast indexed equality query",run:()=>Me(h)},{id:"comparison",title:"Comparison Queries",description:"greaterThan, lessThan, between",run:()=>Le(h)},{id:"startswith",title:"startsWith()",description:"String prefix queries",run:()=>Fe(h)},{id:"anyof",title:"anyOf()",description:"Multiple value queries",run:()=>_e(h)},{id:"filter",title:"filter()",description:"Post-cursor filtering",run:()=>Ve(h)},{id:"combined",title:"Combined Query",description:"where() + filter() for optimal performance",run:()=>je(h)},{id:"ordering",title:"Ordering & Pagination",description:"orderBy, limit, offset",run:()=>He(h)},{id:"terminal",title:"Terminal Operations",description:"toArray, first, count, keys, iterate",run:()=>Ge(h)},{id:"iterate",title:"iterate()",description:"Memory-efficient async generator",run:()=>We(h)},{id:"boolean",title:"Boolean Queries",description:"Automatic fallback for non-indexable types",run:()=>Qe(h)}];case"transactions":return[{id:"read",title:"Read Transaction",description:"Consistent reads across stores",run:()=>Je(h)},{id:"write",title:"Write Transaction",description:"Atomic multi-store modifications",run:()=>ze(h)},{id:"durability",title:"Durability Options",description:"default, strict, relaxed",run:()=>Xe(h)},{id:"accessors",title:"Transaction Accessors",description:"getMode, getStoreNames, isActive",run:()=>Ye(h)},{id:"abort",title:"Transaction Abort",description:"Roll back all changes",run:()=>Ze(h)},{id:"native",title:"Native Access",description:"Access native IDBTransaction",run:()=>et(h)}];case"cursors":return[{id:"iterate",title:"iterate()",description:"Async generator for records",run:()=>tt(h)},{id:"iteratekeys",title:"iterateKeys()",description:"Key-only iteration",run:()=>st(h)},{id:"manual",title:"Manual Cursor",description:"openCursor() for full control",run:()=>rt(h)},{id:"mutation",title:"Cursor Mutation",description:"Update and delete during iteration",run:()=>nt(h)},{id:"navigation",title:"Cursor Navigation",description:"continue, advance methods",run:()=>ot(h)},{id:"directions",title:"Cursor Directions",description:"next, previous, unique variants",run:()=>at(h)},{id:"keycursor",title:"Key Cursor",description:"Efficient key-only cursor",run:()=>it(h)},{id:"indexcursor",title:"Index Cursor",description:"Iterate through index",run:()=>ct(h)}];case"events":return[{id:"dbchange",title:"Database onChange",description:"All store changes",run:()=>ut(h)},{id:"storechange",title:"Store onChange",description:"Specific store changes",run:()=>dt(h)},{id:"crosstab",title:"Cross-Tab Sync",description:"BroadcastChannel synchronization",run:()=>lt()},{id:"onerror",title:"onError",description:"Error event handling",run:()=>mt(h)},{id:"versionchange",title:"onVersionChange",description:"Handle version upgrades",run:()=>ht(h)},{id:"onclose",title:"onClose",description:"Handle connection close",run:()=>yt(h)},{id:"hooks",title:"Event Hooks",description:"Configure hooks at creation",run:()=>pt()}];case"errors":return[{id:"notfound",title:"NotFoundError",description:"resolve() for missing records",run:()=>gt(h)},{id:"constraint",title:"ConstraintError",description:"add() for duplicate keys",run:()=>ft(h)},{id:"codes",title:"Error Codes",description:"All error code enumeration",run:()=>wt()},{id:"guards",title:"Type Guards",description:"Safe error type checking",run:()=>vt(h)},{id:"hierarchy",title:"Error Hierarchy",description:"Error class structure",run:()=>bt()},{id:"comprehensive",title:"Comprehensive Handling",description:"Best practices pattern",run:()=>xt(h)}]}}function w(r,e){const t=document.createElement(r);return e?.className&&(t.className=e.className),e?.textContent&&(t.textContent=e.textContent),e?.id&&(t.id=e.id),t}function It(r){if(r===void 0)return"undefined";if(r===null)return"null";try{return JSON.stringify(r,null,2)}catch{return typeof r=="object"&&r!==null?"[Object]":typeof r=="string"?r:"[Unknown]"}}function se(){M.forEach(u=>u()),M.length=0;const r=document.getElementById("app");if(!r)return;r.innerHTML="";const e=w("div",{className:"container"}),t=w("header"),s=w("h1",{textContent:"ðï¸ IndexedDB Showcase"}),n=w("p",{textContent:"Comprehensive demonstration of ALL @mikesaintsg/indexeddb features"});t.append(s,n);const o=w("nav",{className:"tabs"});te.forEach(u=>{const d=w("button",{className:`tab ${U===u.id?"active":""}`,textContent:`${u.emoji} ${u.label}`});d.title=u.description,d.addEventListener("click",()=>{U=u.id,se()}),o.appendChild(d)});const a=w("main",{id:"content"});qt(a);const i=w("footer"),c=w("p");c.innerHTML="ð¡ <strong>Open this page in another tab</strong> to see cross-tab sync in action!",i.appendChild(c),e.append(t,o,a,i),r.appendChild(e)}async function qt(r){const e=te.find(i=>i.id===U);if(!e)return;const t=w("section",{className:"card"}),s=w("h2",{textContent:`${e.emoji} ${e.label}`}),n=w("p",{className:"subtitle",textContent:e.description});if(t.append(s,n),e.demo){const i=e.demo(),c=w("div",{className:"interactive-demo-container"});if(c.innerHTML=i.html,t.appendChild(c),i.init)try{await i.init(c,h)}catch(d){console.error("Demo init error:",d)}i.cleanup&&M.push(i.cleanup);const u=w("div",{className:"demo-separator"});u.innerHTML='<h3 style="margin: 24px 0 16px; color: #6b7280; font-size: 0.95rem;">ð API Reference Examples</h3>',t.appendChild(u)}const o=Dt(U),a=w("div",{className:"examples-container"});o.forEach(i=>{const c=Ot(i);a.appendChild(c)}),t.appendChild(a),r.appendChild(t)}function Ot(r){const e=w("div",{className:"example-card"}),t=w("div",{className:"example-header"}),s=w("h3",{textContent:r.title}),n=w("p",{className:"example-desc",textContent:r.description});t.append(s,n);const o=w("button",{className:"btn primary",textContent:"â¶ Run Example"}),a=w("div",{className:"example-result"});return a.style.display="none",o.addEventListener("click",()=>{Pt(r,o,a)}),e.append(t,o,a),e}async function Pt(r,e,t){e.disabled=!0,e.textContent="â³ Running...",t.style.display="block",t.innerHTML='<p class="loading">Running example...</p>';try{const s=await r.run();t.innerHTML="";const n=s.success?"success":"error",o=s.success?"â":"â",a=w("p",{className:`result-message ${n}`,textContent:`${o} ${s.message}`});if(t.appendChild(a),s.data!==void 0){const i=w("div",{className:"result-data"}),c=w("h4",{textContent:"ð Result Data"}),u=w("pre"),d=w("code",{textContent:It(s.data)});u.appendChild(d),i.append(c,u),t.appendChild(i)}if(s.code){const i=w("div",{className:"result-code"}),c=w("h4",{textContent:"ð» Code Example"}),u=w("div",{className:"code-block"}),d=w("pre"),m=w("code",{textContent:s.code});d.appendChild(m),u.appendChild(d),i.append(c,u),t.appendChild(i)}}catch(s){t.innerHTML="";const n=w("p",{className:"result-message error",textContent:`â Error: ${s instanceof Error?s.message:String(s)}`});t.appendChild(n)}finally{e.disabled=!1,e.textContent="â¶ Run Example"}}async function Rt(){h=Ce(),await h.store("users").count()===0&&(await h.store("users").set([...W]),await h.store("posts").set([...Q]),await h.store("settings").set([...ae]));const e=h.onChange(t=>{K.unshift({...t,timestamp:Date.now()}),K.length>100&&K.pop()});ee.push(e)}Rt().then(()=>{se()});window.addEventListener("beforeunload",()=>{ee.forEach(r=>r())});</script>
  <style rel="stylesheet" crossorigin>*{box-sizing:border-box;margin:0;padding:0}:root{--primary: #4f46e5;--primary-hover: #4338ca;--danger: #dc2626;--danger-hover: #b91c1c;--warning: #f59e0b;--warning-hover: #d97706;--secondary: #6b7280;--secondary-hover: #4b5563;--success: #10b981;--bg: #f3f4f6;--card-bg: #ffffff;--text: #1f2937;--text-muted: #6b7280;--border: #e5e7eb;--radius: 8px;--shadow: 0 1px 3px rgba(0, 0, 0, .1);--shadow-lg: 0 4px 6px -1px rgba(0, 0, 0, .1)}body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,sans-serif;background:var(--bg);color:var(--text);line-height:1.5;min-height:100vh}.container{max-width:900px;margin:0 auto;padding:20px}header{text-align:center;margin-bottom:24px}header h1{font-size:2rem;margin-bottom:8px;color:var(--primary)}header p{color:var(--text-muted)}footer{text-align:center;margin-top:32px;padding:16px;color:var(--text-muted);font-size:.875rem;background:#e0e7ff;border-radius:var(--radius)}.tabs{display:flex;gap:8px;margin-bottom:20px;flex-wrap:wrap}.tab{padding:10px 20px;border:none;background:var(--card-bg);border-radius:var(--radius);cursor:pointer;font-size:.95rem;font-weight:500;transition:all .2s;box-shadow:var(--shadow)}.tab:hover{background:var(--border)}.tab.active{background:var(--primary);color:#fff}.card{background:var(--card-bg);border-radius:var(--radius);padding:24px;box-shadow:var(--shadow-lg)}.card h2{margin-bottom:4px;font-size:1.5rem}.card .subtitle{color:var(--text-muted);margin-bottom:20px;font-size:.875rem}.card code{background:#f1f5f9;padding:2px 6px;border-radius:4px;font-size:.85rem;color:var(--primary)}.form-row,.action-row{display:flex;gap:10px;margin-bottom:16px;flex-wrap:wrap}input[type=text],input[type=number],select{padding:10px 14px;border:1px solid var(--border);border-radius:var(--radius);font-size:.95rem;background:#fff;flex:1;min-width:120px}input[type=text]:focus,input[type=number]:focus,select:focus{outline:none;border-color:var(--primary);box-shadow:0 0 0 3px #4f46e51a}input[type=number]{width:80px;flex:none}.btn{padding:10px 18px;border:none;border-radius:var(--radius);font-size:.95rem;font-weight:500;cursor:pointer;transition:all .2s;white-space:nowrap}.btn.small{padding:6px 12px;font-size:.85rem}.btn.primary{background:var(--primary);color:#fff}.btn.primary:hover{background:var(--primary-hover)}.btn.secondary{background:var(--secondary);color:#fff}.btn.secondary:hover{background:var(--secondary-hover)}.btn.warning{background:var(--warning);color:#fff}.btn.warning:hover{background:var(--warning-hover)}.btn.danger{background:var(--danger);color:#fff}.btn.danger:hover{background:var(--danger-hover)}.filter-row{display:flex;gap:8px;margin-bottom:20px;flex-wrap:wrap;align-items:center}.filter-btn{padding:6px 14px;border:1px solid var(--border);background:#fff;border-radius:20px;cursor:pointer;font-size:.875rem;transition:all .2s}.filter-btn:hover{background:var(--border)}.filter-btn.active{background:var(--primary);color:#fff;border-color:var(--primary)}.todo-list{max-height:400px;overflow-y:auto;border:1px solid var(--border);border-radius:var(--radius)}.todo-item{display:flex;align-items:center;gap:12px;padding:12px 16px;border-bottom:1px solid var(--border);transition:background .2s}.todo-item:last-child{border-bottom:none}.todo-item:hover{background:#f9fafb}.todo-item.completed .todo-title{text-decoration:line-through;color:var(--text-muted)}.todo-toggle{width:20px;height:20px;cursor:pointer;flex-shrink:0}.priority{font-size:1rem;flex-shrink:0}.todo-title{flex:1;font-size:.95rem}.todo-date{font-size:.75rem;color:var(--text-muted);flex-shrink:0}.delete-btn{width:28px;height:28px;border:none;background:transparent;color:var(--text-muted);font-size:1.2rem;cursor:pointer;border-radius:50%;transition:all .2s;flex-shrink:0}.delete-btn:hover{background:var(--danger);color:#fff}.stats{display:flex;gap:24px;padding-top:16px;border-top:1px solid var(--border);margin-top:16px;font-size:.875rem;color:var(--text-muted)}.stats strong{color:var(--text)}.notes-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:16px;margin-top:16px}.note-card{padding:16px;border-radius:var(--radius);box-shadow:var(--shadow);transition:transform .2s,box-shadow .2s}.note-card:hover{transform:translateY(-2px);box-shadow:var(--shadow-lg)}.note-card h3{font-size:1rem;margin-bottom:8px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.note-card p{font-size:.875rem;color:#374151;margin-bottom:12px;max-height:60px;overflow:hidden}.note-footer{display:flex;justify-content:space-between;align-items:center;font-size:.75rem;color:var(--text-muted)}.delete-note-btn{width:24px;height:24px;border:none;background:#0000001a;border-radius:50%;cursor:pointer;font-size:1rem;line-height:1}.delete-note-btn:hover{background:var(--danger);color:#fff}.query-builder{background:#f8fafc;padding:20px;border-radius:var(--radius);margin-bottom:20px}.query-row{display:flex;align-items:center;gap:12px;margin-bottom:12px;flex-wrap:wrap}.query-row label{width:140px;font-weight:500;font-size:.875rem;flex-shrink:0}.query-row select{flex:none;width:180px}.query-results{min-height:100px;margin-bottom:20px}.query-results table{width:100%;border-collapse:collapse}.query-results th,.query-results td{padding:10px 12px;text-align:left;border-bottom:1px solid var(--border)}.query-results th{background:#f8fafc;font-weight:600;font-size:.875rem}.query-results td{font-size:.875rem}.query-results tr.completed td{color:var(--text-muted)}.result-count{margin-top:12px;font-size:.875rem;color:var(--text-muted)}.code-section h3{font-size:.95rem;margin-bottom:8px;color:var(--text-muted)}.code-block{background:#1e293b;color:#e2e8f0;padding:16px;border-radius:var(--radius);overflow-x:auto}.code-block pre{margin:0;font-family:Fira Code,Monaco,Consolas,monospace;font-size:.85rem;line-height:1.6}.info-box{background:#dbeafe;border:1px solid #93c5fd;padding:16px;border-radius:var(--radius);margin-bottom:20px}.info-box p{color:#1e40af;margin:0 0 8px}.info-box p:last-child{margin-bottom:0}.event-log{background:#1e293b;color:#e2e8f0;padding:16px;border-radius:var(--radius);max-height:400px;overflow-y:auto;font-family:Fira Code,Monaco,Consolas,monospace;font-size:.85rem}.event-list{list-style:none}.event-list li{padding:8px 12px;border-bottom:1px solid #334155;display:flex;gap:12px;align-items:center}.event-list li:last-child{border-bottom:none}.event-list li.local{border-left:3px solid #3b82f6}.event-list li.remote{border-left:3px solid #f59e0b;background:#f59e0b1a}.event-time{color:#94a3b8;font-size:.75rem}.event-source{font-weight:600;font-size:.75rem;padding:2px 6px;border-radius:4px}.event-list li.local .event-source{background:#3b82f6;color:#fff}.event-list li.remote .event-source{background:#f59e0b;color:#fff}.event-type{color:#22c55e}.event-store{color:#a78bfa}.event-keys{color:#94a3b8;font-size:.75rem}.loading{text-align:center;padding:40px;color:var(--text-muted)}.empty,.placeholder{text-align:center;padding:40px;color:var(--text-muted);font-style:italic}.error{color:var(--danger);text-align:center;padding:20px}.examples-container{display:flex;flex-direction:column;gap:16px}.example-card{border:1px solid var(--border);border-radius:var(--radius);padding:16px;background:#fafafa}.example-header{margin-bottom:12px}.example-header h3{font-size:1rem;margin-bottom:4px;color:var(--primary)}.example-desc{font-size:.85rem;color:var(--text-muted);margin:0 0 8px}.example-usecase{font-size:.85rem;color:#1e40af;background:#dbeafe;padding:8px 12px;border-radius:var(--radius);margin:0;border-left:3px solid var(--primary)}.example-result{margin-top:16px;padding-top:16px;border-top:1px solid var(--border)}.result-message{font-weight:500;padding:8px 12px;border-radius:var(--radius);margin:0 0 12px}.result-message.success{background:#d4edda;color:#155724}.result-message.error{background:#f8d7da;color:#721c24}.result-data,.result-code{margin-top:12px}.result-data h4,.result-code h4{font-size:.85rem;color:var(--text-muted);margin-bottom:8px}.result-data pre{background:#f1f5f9;padding:12px;border-radius:var(--radius);overflow-x:auto;font-size:.8rem;line-height:1.4;max-height:300px;overflow-y:auto}.result-data code{font-family:Fira Code,Monaco,Consolas,monospace}.demo-app{background:#fff;border:2px solid var(--primary);border-radius:var(--radius);padding:20px;margin-bottom:24px}.demo-app h4{font-size:1.1rem;color:var(--primary);margin-bottom:8px}.demo-app .demo-desc{font-size:.85rem;color:var(--text-muted);margin-bottom:16px}.demo-form{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px}.demo-input{padding:10px 14px;border:1px solid var(--border);border-radius:var(--radius);font-size:.9rem;flex:1;min-width:120px}.demo-input:focus{outline:none;border-color:var(--primary);box-shadow:0 0 0 3px #4f46e51a}.demo-input.small{flex:none;width:80px}.demo-select{padding:10px 14px;border:1px solid var(--border);border-radius:var(--radius);font-size:.9rem;background:#fff;cursor:pointer}.demo-stats{display:flex;gap:16px;margin-bottom:16px;flex-wrap:wrap}.demo-stats .stat{font-size:.85rem;color:var(--text-muted)}.demo-stats .stat strong{color:var(--primary)}.demo-list{border:1px solid var(--border);border-radius:var(--radius);max-height:300px;overflow-y:auto;margin-bottom:16px}.demo-list .placeholder{padding:24px;text-align:center;color:var(--text-muted);font-style:italic}.list-item{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid var(--border);gap:12px}.list-item:last-child{border-bottom:none}.list-item:hover{background:#f9fafb}.item-info{flex:1;min-width:0}.item-info strong{display:block;font-size:.95rem;margin-bottom:2px}.item-meta{font-size:.8rem;color:var(--text-muted)}.item-actions{display:flex;gap:6px;flex-shrink:0}.demo-log{background:#1e293b;color:#e2e8f0;padding:12px;border-radius:var(--radius);font-family:Fira Code,Monaco,Consolas,monospace;font-size:.8rem;max-height:150px;overflow-y:auto}.log-entry{padding:4px 0;border-bottom:1px solid #334155}.log-entry:last-child{border-bottom:none}.log-entry.info{color:#94a3b8}.log-entry.success{color:#22c55e}.log-entry.error{color:#f87171}.query-display{background:#f8fafc;padding:12px;border-radius:var(--radius);margin-bottom:16px;font-size:.85rem}.query-display code{display:block;margin-top:8px;white-space:pre-wrap;word-break:break-all;color:var(--primary)}.cart-layout{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:16px}@media(max-width:700px){.cart-layout{grid-template-columns:1fr}}.cart-products,.cart-summary{background:#f8fafc;padding:16px;border-radius:var(--radius)}.cart-products h5,.cart-summary h5{font-size:.95rem;margin-bottom:12px;color:var(--text)}.product-list{display:flex;flex-direction:column;gap:8px}.product-item{display:flex;justify-content:space-between;align-items:center;padding:8px 12px;background:#fff;border-radius:var(--radius);gap:8px}.product-name{flex:1;font-size:.9rem}.product-price{font-weight:600;color:var(--primary)}.cart-items{min-height:100px;margin-bottom:12px}.cart-item{display:flex;justify-content:space-between;align-items:center;padding:8px;background:#fff;border-radius:4px;margin-bottom:6px;font-size:.85rem}.cart-total{padding:12px;background:#fff;border-radius:var(--radius);text-align:right;font-size:1.1rem;margin-bottom:12px}.cart-total strong{color:var(--primary)}.monitor-controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px}.monitor-stats{display:flex;gap:20px;margin-bottom:16px}.event-feed{border:1px solid var(--border);border-radius:var(--radius);max-height:250px;overflow-y:auto;margin-bottom:16px}.event-entry{display:flex;gap:10px;padding:10px 12px;border-bottom:1px solid var(--border);font-size:.85rem;align-items:center;flex-wrap:wrap}.event-entry:last-child{border-bottom:none}.event-time{color:var(--text-muted);font-size:.75rem}.event-badge{padding:2px 8px;border-radius:4px;font-size:.7rem;font-weight:600;text-transform:uppercase}.event-badge.set{background:#dbeafe;color:#1e40af}.event-badge.add{background:#d1fae5;color:#065f46}.event-badge.remove{background:#fee2e2;color:#991b1b}.event-store{color:var(--primary);font-weight:500}.event-keys{color:var(--text-muted);font-size:.8rem}.event-cross-tab{background:#fef3c7;color:#92400e;padding:2px 6px;border-radius:4px;font-size:.7rem}.demo-tip{font-size:.85rem;color:var(--text-muted);font-style:italic;margin-top:12px}.export-controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px}.export-progress{margin-bottom:16px}.progress-bar{height:8px;background:var(--border);border-radius:4px;overflow:hidden;margin-bottom:8px}.progress-fill{height:100%;background:var(--primary);transition:width .1s}#progress-text{font-size:.8rem;color:var(--text-muted)}.export-output h5{font-size:.9rem;margin-bottom:8px}.code-preview{background:#1e293b;color:#e2e8f0;padding:16px;border-radius:var(--radius);max-height:200px;overflow:auto;font-size:.8rem}.lookup-form{display:flex;gap:8px;margin-bottom:16px}.lookup-stats{display:flex;gap:16px;margin-bottom:16px;font-size:.85rem}.lookup-result{margin-bottom:16px}.user-card{padding:16px;border-radius:var(--radius)}.user-card.found{background:#d1fae5;border:1px solid #10b981}.user-card.not-found{background:#fee2e2;border:1px solid #ef4444}.user-card h5{margin-bottom:8px}.user-details p{font-size:.9rem;margin:4px 0}.lookup-code{background:#f8fafc;padding:16px;border-radius:var(--radius)}.lookup-code h5{margin-bottom:8px;font-size:.9rem}.lookup-code pre{background:#1e293b;color:#e2e8f0;padding:12px;border-radius:var(--radius);font-size:.8rem;overflow-x:auto}.registration-form{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px}.registration-result{margin-bottom:16px}.result-box{padding:16px;border-radius:var(--radius)}.result-box.success{background:#d1fae5;border:1px solid #10b981}.result-box.error{background:#fee2e2;border:1px solid #ef4444}.result-box h5{margin-bottom:8px}.result-box pre{background:#1e293b;color:#e2e8f0;padding:12px;border-radius:var(--radius);font-size:.8rem;margin-top:12px;overflow-x:auto}.error-demo-section{background:#f8fafc;padding:16px;border-radius:var(--radius);margin-bottom:16px}.error-demo-section h5{margin-bottom:12px;font-size:.9rem}.scenario-btn{margin:4px}.demo-filters{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px}@media(max-width:600px){.container{padding:12px}header h1{font-size:1.5rem}.tabs{gap:4px}.tab{padding:8px 12px;font-size:.85rem}.form-row{flex-direction:column}.form-row input,.form-row select{width:100%}.action-row{flex-direction:column}.action-row .btn{width:100%}.query-row{flex-direction:column;align-items:stretch}.query-row label,.query-row select{width:100%}.stats{flex-direction:column;gap:8px}}</style>
</head>
<body>
<div id="app"></div>
</body>
</html>
