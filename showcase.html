<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IndexedDB Showcase</title>
  <script type="module" crossorigin>(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const o of n)if(o.type==="childList")for(const a of o.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function t(n){const o={};return n.integrity&&(o.integrity=n.integrity),n.referrerPolicy&&(o.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?o.credentials="include":n.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(n){if(n.ep)return;n.ep=!0;const o=t(n);fetch(n.href,o)}})();const X=[{id:"u1",name:"Alice Johnson",email:"alice@example.com",age:28,status:"active",role:"admin",tags:["developer","leader"],createdAt:Date.now()-864e5*30},{id:"u2",name:"Bob Smith",email:"bob@example.com",age:35,status:"active",role:"user",tags:["developer"],createdAt:Date.now()-864e5*20},{id:"u3",name:"Carol White",email:"carol@example.com",age:42,status:"inactive",role:"user",tags:["designer"],createdAt:Date.now()-864e5*15},{id:"u4",name:"David Brown",email:"david@example.com",age:25,status:"active",role:"guest",tags:["intern"],createdAt:Date.now()-864e5*10},{id:"u5",name:"Eva Green",email:"eva@example.com",age:31,status:"active",role:"user",tags:["developer","tester"],createdAt:Date.now()-864e5*5}],Y=[{id:"p1",title:"Getting Started with IndexedDB",content:"IndexedDB is a powerful browser API...",authorId:"u1",published:!0,views:1200,createdAt:Date.now()-864e5*10},{id:"p2",title:"Advanced Queries",content:"Learn how to use the query builder...",authorId:"u1",published:!0,views:800,createdAt:Date.now()-864e5*8},{id:"p3",title:"Draft: New Features",content:"This post is still being written...",authorId:"u2",published:!1,views:50,createdAt:Date.now()-864e5*5},{id:"p4",title:"Cross-Tab Sync",content:"Keep data synchronized across tabs...",authorId:"u2",published:!0,views:500,createdAt:Date.now()-864e5*3},{id:"p5",title:"Error Handling Best Practices",content:"How to handle errors properly...",authorId:"u5",published:!0,views:300,createdAt:Date.now()-864e5}],le=[{id:"s1",key:"theme",value:"dark",updatedAt:Date.now()-36e5},{id:"s2",key:"language",value:"en",updatedAt:Date.now()-72e5},{id:"s3",key:"notifications",value:"enabled",updatedAt:Date.now()}];class I extends Error{code;cause;constructor(e,t,s){super(t),this.name="DatabaseError",this.code=e,this.cause=s,Object.setPrototypeOf(this,new.target.prototype)}}class R extends I{storeName;key;constructor(e,t){const s=se(t);super("NOT_FOUND",`Record not found in "${e}" with key: ${s}`),this.name="NotFoundError",this.storeName=e,this.key=t}}class Z extends I{storeName;key;constructor(e,t,s){const n=se(t);super("CONSTRAINT_ERROR",`Key already exists in "${e}": ${n}`,s),this.name="ConstraintError",this.storeName=e,this.key=t}}class fe extends I{constructor(e){super("QUOTA_EXCEEDED","Storage quota exceeded",e),this.name="QuotaExceededError"}}class M extends I{constructor(e,t,s){super(e,t,s),this.name="TransactionError"}}class Q extends I{constructor(e,t,s){super(e,t,s),this.name="UpgradeError"}}class we extends I{constructor(e,t){super("OPEN_FAILED",e,t),this.name="OpenError"}}class be extends I{constructor(e,t){super("DATA_ERROR",e,t),this.name="DataError"}}class ve extends I{constructor(e,t){super("READ_ONLY",e,t),this.name="ReadOnlyError"}}class xe extends I{constructor(e,t){super("VERSION_ERROR",e,t),this.name="VersionError"}}class K extends I{constructor(e,t){super("INVALID_STATE",e,t),this.name="InvalidStateError"}}class Ee extends I{constructor(e,t){super("TIMEOUT",e,t),this.name="TimeoutError"}}function N(r,e){if(!r)return new I("UNKNOWN_ERROR","Unknown error occurred");const t=e?.storeName??"",s=e?.key??"";switch(r.name){case"ConstraintError":return new Z(t,s,r);case"QuotaExceededError":return new fe(r);case"TransactionInactiveError":return new M("TRANSACTION_INACTIVE",r.message||"Transaction is not active",r);case"AbortError":return new M("TRANSACTION_ABORTED",r.message||"Transaction was aborted",r);case"VersionError":return new xe(r.message||"Version error",r);case"DataError":return new be(r.message||"Data error",r);case"InvalidStateError":return new K(r.message||"Invalid state",r);case"ReadOnlyError":return new ve(r.message||"Attempted write in read-only transaction",r);case"NotFoundError":return new I("NOT_FOUND",r.message||"Object store or index not found",r);case"TimeoutError":return new Ee(r.message||"Operation timed out",r);default:return new I("UNKNOWN_ERROR",r.message||`Unknown error: ${r.name}`,r)}}function Ae(r){return r instanceof I}function ee(r){return r instanceof R}function te(r){return r instanceof Z}function Ce(r,e){return r instanceof I&&r.code===e}function se(r){return typeof r=="string"?`"${r}"`:typeof r=="number"?String(r):r instanceof Date?r.toISOString():Array.isArray(r)?`[${r.map(se).join(", ")}]`:r instanceof ArrayBuffer||ArrayBuffer.isView(r)?"[Binary Data]":String(r)}const ue="id",de=!1,F={DATABASE_NOT_OPEN:"Database connection is not open",DATABASE_CLOSED:"Database connection has been closed",STORE_NOT_FOUND:r=>`Object store "${r}" not found`,INDEX_NOT_FOUND:r=>`Index "${r}" not found`,TRANSACTION_INACTIVE:"Transaction is no longer active",TRANSACTION_MODE_MISMATCH:"Operation requires readwrite transaction",INVALID_KEY:"Invalid key type for this operation",NATIVE_ACCESS_NO_TRANSACTION:"Native store access requires active transaction",UPGRADE_BLOCKED:"Database upgrade blocked by other connections",UPGRADE_FAILED:"Database upgrade failed",OPEN_FAILED:"Failed to open database"};function W(r){return new Promise((e,t)=>{r.oncomplete=()=>e(),r.onerror=()=>{t(N(r.error))},r.onabort=()=>{t(new M("TRANSACTION_ABORTED",r.error?.message??"Transaction was aborted",r.error))}})}function Se(r,e){if(typeof r!="object"||r===null)return;if(typeof e=="string")return re(r,e);const t=[];for(const s of e){const n=re(r,s);if(n===void 0)return;t.push(n)}return t}function re(r,e){const t=e.split(".");let s=r;for(const n of t){if(typeof s!="object"||s===null)return;s=s[n]}if(j(s))return s}function j(r){if(r==null)return!1;const e=typeof r;return e==="number"?!Number.isNaN(r):e==="string"?!0:r instanceof Date?!Number.isNaN(r.getTime()):r instanceof ArrayBuffer||ArrayBuffer.isView(r)?!0:Array.isArray(r)?r.every(j):!1}function ne(r){return Array.isArray(r)?r:[r]}function Te(r){return typeof r=="number"&&Number.isInteger(r)&&r>0}function ke(r){if(!Te(r))throw new Error(`Database version must be a positive integer, got: ${String(r)}`)}function Ne(r){if(r.length===0)throw new Error("Database name must be a non-empty string")}function O(r){return r===void 0?"next":r==="previous"?"prev":r==="previousunique"?"prevunique":r}function he(r){return r==="prev"?"previous":r==="prevunique"?"previousunique":r}function De(){return{keyPath:null,range:null,anyOfValues:null,filters:[],direction:"ascending",limitCount:null,offsetCount:0}}class ${#t;#e;constructor(e,t){this.#t=e,this.#e=t}get native(){return this.#t}getKey(){return this.#t.key}getPrimaryKey(){return this.#t.primaryKey}getValue(){return this.#t.value}getDirection(){return he(this.#t.direction)}async continue(e){return new Promise((t,s)=>{this.#e.onsuccess=()=>{const n=this.#e.result;t(n?new $(n,this.#e):null)},this.#e.onerror=()=>s(N(this.#e.error)),e!==void 0?this.#t.continue(e):this.#t.continue()})}async continuePrimaryKey(e,t){return new Promise((s,n)=>{this.#e.onsuccess=()=>{const o=this.#e.result;s(o?new $(o,this.#e):null)},this.#e.onerror=()=>n(N(this.#e.error)),this.#t.continuePrimaryKey(e,t)})}async advance(e){return new Promise((t,s)=>{this.#e.onsuccess=()=>{const n=this.#e.result;t(n?new $(n,this.#e):null)},this.#e.onerror=()=>s(N(this.#e.error)),this.#t.advance(e)})}async update(e){return new Promise((t,s)=>{const n=this.#t.update(e);n.onsuccess=()=>t(n.result),n.onerror=()=>s(N(n.error))})}async delete(){return new Promise((e,t)=>{const s=this.#t.delete();s.onsuccess=()=>e(),s.onerror=()=>t(N(s.error))})}}class U{#t;#e;constructor(e,t){this.#t=e,this.#e=t}get native(){return this.#t}getKey(){return this.#t.key}getPrimaryKey(){return this.#t.primaryKey}getDirection(){return he(this.#t.direction)}async continue(e){return new Promise((t,s)=>{this.#e.onsuccess=()=>{const n=this.#e.result;t(n?new U(n,this.#e):null)},this.#e.onerror=()=>s(N(this.#e.error)),e!==void 0?this.#t.continue(e):this.#t.continue()})}async continuePrimaryKey(e,t){return new Promise((s,n)=>{this.#e.onsuccess=()=>{const o=this.#e.result;s(o?new U(o,this.#e):null)},this.#e.onerror=()=>n(N(this.#e.error)),this.#t.continuePrimaryKey(e,t)})}async advance(e){return new Promise((t,s)=>{this.#e.onsuccess=()=>{const n=this.#e.result;t(n?new U(n,this.#e):null)},this.#e.onerror=()=>s(N(this.#e.error)),this.#t.advance(e)})}}class S{#t;#e;constructor(e,t){this.#t=e,this.#e=t??De()}where(e){return new Ie(this.#t,{...this.#e,keyPath:e})}filter(e){return new S(this.#t,{...this.#e,filters:[...this.#e.filters,e]})}ascending(){return new S(this.#t,{...this.#e,direction:"ascending"})}descending(){return new S(this.#t,{...this.#e,direction:"descending"})}getRange(){return this.#e.range}limit(e){return new S(this.#t,{...this.#e,limitCount:e})}offset(e){return new S(this.#t,{...this.#e,offsetCount:e})}async toArray(){const e=[];for await(const t of this.iterate())e.push(t);return e}async first(){const t=await new S(this.#t,{...this.#e,limitCount:1}).iterate().next();return t.done?void 0:t.value}async count(){if(this.#e.filters.length===0&&this.#e.anyOfValues===null){const n=(await this.#t.ensureOpen()).transaction([this.#t.storeName],"readonly").objectStore(this.#t.storeName),a=this.#s(n).count(this.#e.range??void 0);return this.#a(a)}let e=0;for await(const t of this.iterate())e++;return e}async keys(){const e=[],n=(await this.#t.ensureOpen()).transaction([this.#t.storeName],"readonly").objectStore(this.#t.storeName),o=this.#s(n),a=O(this.#e.direction==="ascending"?"next":"previous");if(this.#e.anyOfValues!==null){const h=await this.#c(n);return this.#i(h)}const i=o.openKeyCursor(this.#e.range??void 0,a);let c=0,l=0,u=await this.#a(i);for(;u;){if(c<this.#e.offsetCount){c++,u.continue(),u=await this.#a(i);continue}if(this.#e.limitCount!==null&&l>=this.#e.limitCount)break;if(this.#e.filters.length>0){const h=n.get(u.primaryKey),d=await this.#a(h);d!==void 0&&this.#n(d)&&(e.push(u.primaryKey),l++)}else e.push(u.primaryKey),l++;u.continue(),u=await this.#a(i)}return e}async*iterate(){const s=(await this.#t.ensureOpen()).transaction([this.#t.storeName],"readonly").objectStore(this.#t.storeName);if(this.#e.anyOfValues!==null){const u=await this.#r(s),h=this.#i(u);for(const d of h)yield d;return}const n=this.#s(s),o=O(this.#e.direction==="ascending"?"next":"previous"),a=n.openCursor(this.#e.range??void 0,o);let i=0,c=0,l=await this.#a(a);for(;l;){const u=l.value;if(!this.#n(u)){l.continue(),l=await this.#a(a);continue}if(i<this.#e.offsetCount){i++,l.continue(),l=await this.#a(a);continue}if(this.#e.limitCount!==null&&c>=this.#e.limitCount)break;yield u,c++,l.continue(),l=await this.#a(a)}}#s(e){const t=this.#e.keyPath;if(t===null||t===this.#t.primaryKeyPath)return e;if(this.#t.indexNames.includes(t))return e.index(t);for(const s of this.#t.indexNames)try{const n=e.index(s);if(n.keyPath===t)return n}catch{}return e}#n(e){for(const t of this.#e.filters)if(!t(e))return!1;return!0}async#r(e){if(this.#e.anyOfValues===null)return[];const t=this.#e.keyPath,s=new Map,n=this.#e.anyOfValues.map(async a=>{let i=[];if(t===null||t===this.#t.primaryKeyPath){const c=await this.#a(e.get(a));i=c?[c]:[]}else if(this.#t.indexNames.includes(t)){const c=e.index(t);i=await this.#a(c.getAll(a))}else for(const c of this.#t.indexNames)try{const l=e.index(c);if(l.keyPath===t){i=await this.#a(l.getAll(a));break}}catch{}for(const c of i)if(this.#n(c)){const l=this.#o(c);l!==void 0&&s.set(this.#l(l),c)}});await Promise.all(n);const o=Array.from(s.values());return this.#e.direction==="descending"&&o.reverse(),o}async#c(e){if(this.#e.anyOfValues===null)return[];const t=this.#e.keyPath,s=new Set,n=[],o=this.#e.anyOfValues.map(async a=>{let i;if(t===null||t===this.#t.primaryKeyPath)i=await this.#a(e.count(a))>0?[a]:[];else if(this.#t.indexNames.includes(t)){const c=e.index(t);i=await this.#a(c.getAllKeys(a))}else i=[];for(const c of i){const l=this.#l(c);s.has(l)||(s.add(l),n.push(c))}});return await Promise.all(o),this.#e.direction==="descending"&&n.reverse(),n}#o(e){const t=this.#t.primaryKeyPath;if(!(t===null||typeof e!="object"||e===null))return Se(e,t)}#i(e){let t=e;return this.#e.offsetCount>0&&(t=t.slice(this.#e.offsetCount)),this.#e.limitCount!==null&&(t=t.slice(0,this.#e.limitCount)),t}#a(e){return new Promise((t,s)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>s(N(e.error,{storeName:this.#t.storeName}))})}#l(e){return typeof e=="string"?e:typeof e=="number"?`n:${e}`:e instanceof Date?`d:${e.getTime()}`:e instanceof ArrayBuffer?`b:${Array.from(new Uint8Array(e)).join(",")}`:ArrayBuffer.isView(e)?`b:${Array.from(new Uint8Array(e.buffer)).join(",")}`:Array.isArray(e)?`a:${JSON.stringify(e)}`:JSON.stringify(e)}}class Ie{#t;#e;constructor(e,t){this.#t=e,this.#e=t}equals(e){return j(e)?new S(this.#t,{...this.#e,range:IDBKeyRange.only(e)}):this.#s(e,t=>t===e)}#s(e,t){const s=this.#e.keyPath,n=o=>{if(s===null||typeof o!="object"||o===null)return!1;const a=o[s];return t(a)};return new S(this.#t,{...this.#e,keyPath:null,filters:[...this.#e.filters,n]})}greaterThan(e){return new S(this.#t,{...this.#e,range:IDBKeyRange.lowerBound(e,!0)})}greaterThanOrEqual(e){return new S(this.#t,{...this.#e,range:IDBKeyRange.lowerBound(e,!1)})}lessThan(e){return new S(this.#t,{...this.#e,range:IDBKeyRange.upperBound(e,!0)})}lessThanOrEqual(e){return new S(this.#t,{...this.#e,range:IDBKeyRange.upperBound(e,!1)})}between(e,t,s){return new S(this.#t,{...this.#e,range:IDBKeyRange.bound(e,t,s?.lowerOpen??!1,s?.upperOpen??!1)})}startsWith(e){return new S(this.#t,{...this.#e,range:IDBKeyRange.bound(e,e+"ï¿¿",!1,!1)})}anyOf(e){return e.length===1&&e[0]!==void 0?new S(this.#t,{...this.#e,range:IDBKeyRange.only(e[0])}):new S(this.#t,{...this.#e,anyOfValues:e})}noneOf(e){const t=this.#e.keyPath,s=new Set(e.map(o=>this.#n(o))),n=o=>{if(t===null||typeof o!="object"||o===null)return!0;const a=o[t];return j(a)?!s.has(this.#n(a)):!0};return new S(this.#t,{...this.#e,keyPath:null,filters:[...this.#e.filters,n]})}endsWith(e){const t=this.#e.keyPath,s=n=>{if(t===null||typeof n!="object"||n===null)return!1;const o=n[t];return typeof o!="string"?!1:o.endsWith(e)};return new S(this.#t,{...this.#e,keyPath:null,filters:[...this.#e.filters,s]})}#n(e){return typeof e=="string"?e:typeof e=="number"?`n:${e}`:e instanceof Date?`d:${e.getTime()}`:e instanceof ArrayBuffer?`b:${Array.from(new Uint8Array(e)).join(",")}`:ArrayBuffer.isView(e)?`b:${Array.from(new Uint8Array(e.buffer)).join(",")}`:Array.isArray(e)?`a:${JSON.stringify(e)}`:JSON.stringify(e)}}class qe{#t;#e;#s;#n;constructor(e,t,s,n){this.#t=e,this.#e=t,this.#s=s,this.#n=n}get native(){throw new Error("Index.native requires active transaction. Use openCursor() or iterate().")}getName(){return this.#e}getKeyPath(){return this.#s.keyPath}isUnique(){return this.#s.unique??!1}isMultiEntry(){return this.#s.multiEntry??!1}async get(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return Array.isArray(e)?await Promise.all(e.map(a=>this.#r(o.get(a)))):this.#r(o.get(e))}async resolve(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);if(Array.isArray(e))return await Promise.all(e.map(async i=>{const c=await this.#r(o.get(i));if(c===void 0)throw new R(this.#t,i);return c}));const a=await this.#r(o.get(e));if(a===void 0)throw new R(this.#t,e);return a}async getKey(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return this.#r(o.getKey(e))}async has(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return Array.isArray(e)?await Promise.all(e.map(async i=>await this.#r(o.count(i))>0)):await this.#r(o.count(e))>0}async all(e,t){const a=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return this.#r(a.getAll(e??void 0,t))}async keys(e,t){const a=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return this.#r(a.getAllKeys(e??void 0,t))}async count(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e);return this.#r(o.count(e))}query(){return new S({storeName:this.#t,primaryKeyPath:null,indexNames:[this.#e],ensureOpen:this.#n})}async*iterate(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e),a=O(e?.direction),i=o.openCursor(e?.query??null,a);let c=await this.#r(i);for(;c;){yield c.value;const l=new Promise(u=>{i.onsuccess=()=>u(i.result)});c.continue(),c=await l}}async*iterateKeys(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e),a=O(e?.direction),i=o.openKeyCursor(e?.query??null,a);let c=await this.#r(i);for(;c;){yield c.key;const l=new Promise(u=>{i.onsuccess=()=>u(i.result)});c.continue(),c=await l}}async openCursor(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e),a=O(e?.direction),i=o.openCursor(e?.query??null,a),c=await this.#r(i);return c?new $(c,i):null}async openKeyCursor(e){const o=(await this.#n()).transaction([this.#t],"readonly").objectStore(this.#t).index(this.#e),a=O(e?.direction),i=o.openKeyCursor(e?.query??null,a),c=await this.#r(i);return c?new U(c,i):null}#r(e){return new Promise((t,s)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>s(N(e.error,{storeName:this.#t}))})}}class Oe{#t;#e;#s;#n=new Set;constructor(e,t,s){this.#t=e,this.#e=t,this.#s=s}get native(){throw new Error(F.NATIVE_ACCESS_NO_TRANSACTION)}getName(){return this.#e}getKeyPath(){return this.#s.keyPath===void 0?ue:this.#s.keyPath}getIndexNames(){return(this.#s.indexes??[]).map(e=>e.name)}hasAutoIncrement(){return this.#s.autoIncrement??de}hasTTL(){return this.#s.ttl!==void 0}async get(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);if(Array.isArray(e)){const a=await Promise.all(e.map(i=>this.#r(n.get(i))));return this.hasTTL()?a.map(i=>i!==void 0&&this.#o(i)?void 0:i):a}const o=await this.#r(n.get(e));if(!(o!==void 0&&this.hasTTL()&&this.#o(o)))return o}async resolve(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);if(Array.isArray(e))return await Promise.all(e.map(async a=>{const i=await this.#r(n.get(a));if(i===void 0)throw new R(this.#e,a);return i}));const o=await this.#r(n.get(e));if(o===void 0)throw new R(this.#e,e);return o}async has(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);return Array.isArray(e)?await Promise.all(e.map(async a=>await this.#r(n.count(a))>0)):await this.#r(n.count(e))>0}async set(e,t){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readwrite"),o=n.objectStore(this.#e);if(Array.isArray(e)){const l=t?.onProgress,u=e.length,h=[];for(let d=0;d<u;d++){const m=await this.#r(o.put(e[d]));h.push(m),l&&l(d+1,u)}return await this.#c(n),this.#i("set",h),h}const a=t,i=await this.#r(o.put(e,a));return await this.#c(n),this.#i("set",[i]),i}async add(e,t){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readwrite"),o=n.objectStore(this.#e);if(Array.isArray(e)){const l=t?.onProgress,u=e.length,h=[];for(let d=0;d<u;d++){const m=await this.#r(o.add(e[d]));h.push(m),l&&l(d+1,u)}return await this.#c(n),this.#i("add",h),h}const a=t,i=await this.#r(o.add(e,a));return await this.#c(n),this.#i("add",[i]),i}async remove(e){const s=(await this.#t.ensureOpen()).transaction([this.#e],"readwrite"),n=s.objectStore(this.#e);if(Array.isArray(e)){await Promise.all(e.map(o=>this.#r(n.delete(o)))),await this.#c(s),this.#i("remove",e.map(o=>o));return}await this.#r(n.delete(e)),await this.#c(s),this.#i("remove",[e])}async all(e,t){const o=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e),a=await this.#r(o.getAll(e??void 0,t));return this.hasTTL()?a.filter(i=>!this.#o(i)):a}async keys(e,t){const o=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);return this.#r(o.getAllKeys(e??void 0,t))}async clear(){const t=(await this.#t.ensureOpen()).transaction([this.#e],"readwrite"),s=t.objectStore(this.#e);await this.#r(s.clear()),await this.#c(t),this.#i("clear",[])}async count(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e);return this.#r(n.count(e))}async prune(){if(!this.hasTTL())return{prunedCount:0,remainingCount:await this.count()};const t=(await this.#t.ensureOpen()).transaction([this.#e],"readwrite"),s=t.objectStore(this.#e),o=this.#s.ttl?.field??"_expiresAt",a=Date.now();let i=0;const c=[],l=s.openCursor();await new Promise((h,d)=>{l.onsuccess=()=>{const m=l.result;if(m){const w=m.value[o];typeof w=="number"&&w<=a&&(c.push(m.primaryKey),m.delete(),i++),m.continue()}else h()},l.onerror=()=>d(l.error??new Error("Cursor operation failed"))}),await this.#c(t),i>0&&this.#i("remove",c);const u=await this.count();return{prunedCount:i,remainingCount:u}}async isExpired(e){if(!this.hasTTL())return!1;const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e),o=await this.#r(n.get(e));if(!o)return!1;const i=this.#s.ttl?.field??"_expiresAt",c=o[i];return typeof c=="number"?c<=Date.now():!1}index(e){const s=(this.#s.indexes??[]).find(n=>n.name===e);if(!s)throw new Error(`Index "${e}" not found on store "${this.#e}"`);return new qe(this.#e,e,s,()=>this.#t.ensureOpen())}query(){const e=this.getKeyPath();return new S({storeName:this.#e,primaryKeyPath:typeof e=="string"?e:null,indexNames:this.getIndexNames(),ensureOpen:()=>this.#t.ensureOpen()})}async*iterate(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e),o=O(e?.direction),a=n.openCursor(e?.query??null,o);let i=await this.#r(a);for(;i;){yield i.value;const c=new Promise(l=>{a.onsuccess=()=>l(a.result)});i.continue(),i=await c}}async*iterateKeys(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e),o=O(e?.direction),a=n.openKeyCursor(e?.query??null,o);let i=await this.#r(a);for(;i;){yield i.key;const c=new Promise(l=>{a.onsuccess=()=>l(a.result)});i.continue(),i=await c}}async openCursor(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e),o=O(e?.direction),a=n.openCursor(e?.query??null,o),i=await this.#r(a);return i?new $(i,a):null}async openKeyCursor(e){const n=(await this.#t.ensureOpen()).transaction([this.#e],"readonly").objectStore(this.#e),o=O(e?.direction),a=n.openKeyCursor(e?.query??null,o),i=await this.#r(a);return i?new U(i,a):null}onChange(e){return this.#n.add(e),()=>this.#n.delete(e)}#r(e){return new Promise((t,s)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>s(N(e.error,{storeName:this.#e}))})}#c(e){return new Promise((t,s)=>{e.oncomplete=()=>t(),e.onerror=()=>s(N(e.error)),e.onabort=()=>s(N(e.error))})}#o(e){if(!this.hasTTL())return!1;const s=this.#s.ttl?.field??"_expiresAt",n=e[s];return typeof n=="number"?n<=Date.now():!1}#i(e,t){const s=t.length>0?t[0]:void 0,n={storeName:this.#e,type:e,keys:t,source:"local",timestamp:Date.now()},o=s!==void 0?{...n,key:s}:n;for(const a of this.#n)try{a(o)}catch{}this.#t.emitChange(o)}emitRemoteChange(e){for(const t of this.#n)try{t(e)}catch{}}}class Pe{#t;#e;constructor(e,t){this.#t=e,this.#e=t}get native(){return this.#t}getName(){return this.#t.name}getKeyPath(){const e=this.#t.keyPath;return Array.isArray(e),e}isUnique(){return this.#t.unique}isMultiEntry(){return this.#t.multiEntry}async get(e){return Array.isArray(e)?Promise.all(e.map(t=>this.#s(this.#t.get(t)))):this.#s(this.#t.get(e))}async resolve(e){if(Array.isArray(e))return Promise.all(e.map(async s=>{const n=await this.#s(this.#t.get(s));if(n===void 0)throw new R(this.#e,s);return n}));const t=await this.#s(this.#t.get(e));if(t===void 0)throw new R(this.#e,e);return t}async has(e){return Array.isArray(e)?Promise.all(e.map(async s=>await this.#s(this.#t.count(s))>0)):await this.#s(this.#t.count(e))>0}async getKey(e){return this.#s(this.#t.getKey(e))}async all(e,t){return this.#s(this.#t.getAll(e??void 0,t))}async keys(e,t){return this.#s(this.#t.getAllKeys(e??void 0,t))}async count(e){return this.#s(this.#t.count(e))}async openCursor(e){const t=O(e?.direction),s=this.#t.openCursor(e?.query??null,t),n=await this.#s(s);return n?new $(n,s):null}async openKeyCursor(e){const t=O(e?.direction),s=this.#t.openKeyCursor(e?.query??null,t),n=await this.#s(s);return n?new U(n,s):null}#s(e){return new Promise((t,s)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>s(N(e.error,{storeName:this.#e}))})}}class Re{#t;#e;constructor(e,t){this.#t=e,this.#e=t}get native(){return this.#t}async get(e){return Array.isArray(e)?Promise.all(e.map(t=>this.#s(this.#t.get(t)))):this.#s(this.#t.get(e))}async resolve(e){if(Array.isArray(e))return Promise.all(e.map(async s=>{const n=await this.#s(this.#t.get(s));if(n===void 0)throw new R(this.#e,s);return n}));const t=await this.#s(this.#t.get(e));if(t===void 0)throw new R(this.#e,e);return t}async set(e,t){return Array.isArray(e)?Promise.all(e.map(s=>this.#s(this.#t.put(s)))):this.#s(this.#t.put(e,t))}async add(e,t){return Array.isArray(e)?Promise.all(e.map(s=>this.#s(this.#t.add(s)))):this.#s(this.#t.add(e,t))}async remove(e){if(Array.isArray(e)){await Promise.all(e.map(t=>this.#s(this.#t.delete(t))));return}await this.#s(this.#t.delete(e))}async has(e){return Array.isArray(e)?Promise.all(e.map(async s=>await this.#s(this.#t.count(s))>0)):await this.#s(this.#t.count(e))>0}async all(e,t){return this.#s(this.#t.getAll(e??void 0,t))}async keys(e,t){return this.#s(this.#t.getAllKeys(e??void 0,t))}async clear(){await this.#s(this.#t.clear())}async count(e){return this.#s(this.#t.count(e))}index(e){if(!this.#t.indexNames.contains(e))throw new Error(`Index "${e}" not found on store "${this.#e}"`);const t=this.#t.index(e);return new Pe(t,this.#e)}async openCursor(e){const t=O(e?.direction),s=this.#t.openCursor(e?.query??null,t),n=await this.#s(s);return n?new $(n,s):null}async openKeyCursor(e){const t=O(e?.direction),s=this.#t.openKeyCursor(e?.query??null,t),n=await this.#s(s);return n?new U(n,s):null}#s(e){return new Promise((t,s)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>s(N(e.error,{storeName:this.#e}))})}}class oe{#t;#e;#s=!0;#n=!1;constructor(e){this.#t=e,this.#e=Array.from(e.objectStoreNames),e.oncomplete=()=>{this.#s=!1,this.#n=!0},e.onabort=()=>{this.#s=!1,this.#n=!0},e.onerror=()=>{this.#s=!1,this.#n=!0}}get native(){return this.#t}getMode(){return this.#t.mode}getStoreNames(){return this.#e}isActive(){return this.#s}isFinished(){return this.#n}store(e){if(!this.#e.includes(e))throw new M("INVALID_STATE",`Store "${e}" is not in transaction scope. Scoped stores: ${this.#e.join(", ")}`);if(!this.#s)throw new M("TRANSACTION_INACTIVE","Transaction is no longer active");const t=this.#t.objectStore(e);return new Re(t,e)}abort(){if(this.#n)throw new M("INVALID_STATE","Cannot abort: transaction already finished");this.#t.abort(),this.#s=!1,this.#n=!0}commit(){if(this.#n)throw new M("INVALID_STATE","Cannot commit: transaction already finished");typeof this.#t.commit=="function"&&this.#t.commit()}}class $e{#t;#e;#s;#n;#r;#c;#o=null;#i=null;#a=!1;#l=null;#u=new Set;#h=new Set;#m=new Set;#d=new Set;#p=new Map;constructor(e){Ne(e.name),ke(e.version),this.#t=e.name,this.#e=e.version,this.#s=e.stores,this.#n=e.migrations??[],this.#r=e.onBlocked,this.#c=e.crossTabSync!==!1,this.#c&&typeof BroadcastChannel<"u"&&(this.#l=new BroadcastChannel(`idb:${e.name}`),this.#l.onmessage=t=>{this.#f(t.data)}),e.onChange&&this.#u.add(e.onChange),e.onError&&this.#h.add(e.onError),e.onVersionChange&&this.#m.add(e.onVersionChange),e.onClose&&this.#d.add(e.onClose)}get native(){if(!this.#o)throw new K(F.DATABASE_NOT_OPEN);return this.#o}getName(){return this.#t}getVersion(){return this.#e}getStoreNames(){return this.#o?Array.from(this.#o.objectStoreNames):Object.keys(this.#s)}isOpen(){return this.#o!==null&&!this.#a}store(e){if(!(e in this.#s))throw new K(F.STORE_NOT_FOUND(e));let t=this.#p.get(e);return t||(t=new Oe(this,e,this.#s[e]),this.#p.set(e,t)),t}async read(e,t){const s=await this.ensureOpen(),n=ne(e),o=s.transaction([...n],"readonly"),a=new oe(o);try{await t(a),await W(o)}catch(i){if(a.isActive())try{a.abort()}catch{}throw i}}async write(e,t,s){const n=await this.ensureOpen(),o=ne(e),a=s?.durability?{durability:s.durability}:void 0,i=[...o],c=a?n.transaction(i,"readwrite",a):n.transaction(i,"readwrite"),l=new oe(c);try{await t(l),await W(c)}catch(u){if(l.isActive())try{l.abort()}catch{}throw u}}close(){this.#l&&(this.#l.close(),this.#l=null),this.#o&&(this.#o.close(),this.#o=null),this.#a=!0,this.#i=null;for(const e of this.#d)try{e()}catch{}}async drop(){return this.close(),new Promise((e,t)=>{const s=indexedDB.deleteDatabase(this.#t);s.onsuccess=()=>e(),s.onerror=()=>t(N(s.error)),s.onblocked=()=>{}})}async export(){const e=await this.ensureOpen(),t=Object.keys(this.#s),s={};for(const n of t){const i=e.transaction([n],"readonly").objectStore(n).getAll(),c=await this.#g(i);s[n]=c}return{name:this.#t,version:this.#e,exportedAt:new Date().toISOString(),databaseName:this.#t,databaseVersion:this.#e,stores:s}}async import(e,t){const s=await this.ensureOpen(),n=t?.mode??"merge",o=t?.onProgress;for(const[a,i]of Object.entries(e.stores)){if(!(a in this.#s))continue;const c=s.transaction([a],"readwrite"),l=c.objectStore(a);n==="replace"&&await this.#g(l.clear());const u=i.length;for(let h=0;h<u;h++)await this.#g(l.put(i[h])),o&&o(a,h+1,u);await W(c)}}async getStorageEstimate(){if(!navigator?.storage?.estimate)return{usage:0,quota:0,available:0,percentUsed:0};const e=await navigator.storage.estimate(),t=e.usage??0,s=e.quota??0,n=s-t,o=s>0?t/s:0;return{usage:t,quota:s,available:n,percentUsed:o}}onChange(e){return this.#u.add(e),()=>this.#u.delete(e)}onError(e){return this.#h.add(e),()=>this.#h.delete(e)}onVersionChange(e){return this.#m.add(e),()=>this.#m.delete(e)}onClose(e){return this.#d.add(e),()=>this.#d.delete(e)}async ensureOpen(){if(this.#a)throw new K(F.DATABASE_CLOSED);if(this.#o)return this.#o;if(this.#i)return this.#i;this.#i=this.#w();try{return this.#o=await this.#i,this.#o}catch(e){throw this.#i=null,e}}emitChange(e){for(const t of this.#u)try{t(e)}catch(s){this.#y(s instanceof Error?s:new Error(String(s)))}if(e.source==="local"&&this.#l)try{this.#l.postMessage(e)}catch{}}#f(e){const t={...e,source:"remote"};for(const n of this.#u)try{n(t)}catch(o){this.#y(o instanceof Error?o:new Error(String(o)))}const s=this.#p.get(e.storeName);s&&s.emitRemoteChange(t)}async#w(){return new Promise((e,t)=>{const s=indexedDB.open(this.#t,this.#e);s.onerror=()=>{t(new we(`Failed to open database "${this.#t}"`,s.error))},s.onsuccess=()=>{const n=s.result;this.#b(n),e(n)},s.onupgradeneeded=n=>{const o=s.result,a=s.transaction;if(!a){t(new Q("UPGRADE_FAILED","No transaction available during upgrade"));return}try{this.#v(o,a,n.oldVersion,n.newVersion??this.#e)}catch(i){a.abort(),t(i instanceof Q?i:new Q("UPGRADE_FAILED",i instanceof Error?i.message:"Upgrade failed",i))}},s.onblocked=n=>{this.#r&&this.#r({oldVersion:n.oldVersion,newVersion:n.newVersion??this.#e})}})}#b(e){e.onversionchange=t=>{for(const s of this.#m)try{s({oldVersion:t.oldVersion,newVersion:t.newVersion})}catch{}},e.onclose=()=>{this.#o=null,this.#a=!0;for(const t of this.#d)try{t()}catch{}},e.onerror=t=>{const n=t.target?.error??new Error("Unknown database error");this.#y(n instanceof Error?n:new Error(String(n)))}}#v(e,t,s,n){for(const[a,i]of Object.entries(this.#s))e.objectStoreNames.contains(a)||this.#x(e,a,i);const o=this.#n.filter(a=>a.version>s&&a.version<=n).sort((a,i)=>a.version-i.version);for(const a of o){const i={database:e,transaction:t,oldVersion:s,newVersion:n,createStore:(c,l)=>e.createObjectStore(c,l),deleteStore:c=>e.deleteObjectStore(c),getStore:c=>t.objectStore(c)};a.migrate(i)}}#x(e,t,s){const n=s.keyPath??ue,a={autoIncrement:s.autoIncrement??de};n!==null&&(a.keyPath=n);const i=e.createObjectStore(t,a);for(const c of s.indexes??[])this.#E(i,c)}#E(e,t){e.createIndex(t.name,t.keyPath,{unique:t.unique??!1,multiEntry:t.multiEntry??!1})}#y(e){for(const t of this.#h)try{t(e)}catch{}}#g(e){return new Promise((t,s)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>s(N(e.error))})}}function Ue(r){return new $e(r)}function Me(){return Ue({name:"showcase-db",version:1,stores:{users:{indexes:[{name:"byEmail",keyPath:"email",unique:!0},{name:"byStatus",keyPath:"status"},{name:"byRole",keyPath:"role"},{name:"byAge",keyPath:"age"},{name:"byTags",keyPath:"tags",multiEntry:!0},{name:"byCreatedAt",keyPath:"createdAt"}]},posts:{indexes:[{name:"byAuthor",keyPath:"authorId"},{name:"byPublished",keyPath:"published"},{name:"byViews",keyPath:"views"},{name:"byCreatedAt",keyPath:"createdAt"}]},settings:{indexes:[{name:"byKey",keyPath:"key",unique:!0},{name:"byUpdatedAt",keyPath:"updatedAt"}]}},crossTabSync:!0})}async function Be(r){const e=r.store("users"),t=await e.get("u1"),s=await e.get("nonexistent"),n=["u1","u2","nonexistent"],o=await e.get(n);return{success:!0,message:"get() returns undefined for missing records",data:{single:t?.name??"undefined",missing:s===void 0?"undefined (as expected)":"found",batch:o.map(a=>a?.name??"undefined")},code:`
// Single key lookup - returns T | undefined
const user = await store.get('u1')
if (user) {
  console.log(user.name)  // Safe to access
}

// Missing key returns undefined (no error)
const missing = await store.get('nonexistent')  // undefined

// Batch lookup - some may be undefined
const users = await store.get(['u1', 'u2', 'nonexistent'])
// users[2] is undefined
`.trim()}}async function Le(r){const e=r.store("users");let t="";const s=await e.resolve("u1");try{await e.resolve("nonexistent")}catch(n){ee(n)&&(t=`NotFoundError: Key "${JSON.stringify(n.key)}" not found in "${n.storeName}"`)}return{success:!0,message:"resolve() throws NotFoundError for missing records",data:{found:s.name,error:t},code:`
// resolve() throws if record doesn't exist
try {
  const user = await store.resolve('u1')
  console.log(user.name)  // Guaranteed to exist
} catch (error) {
  if (error instanceof NotFoundError) {
    console.log(\`Key \${error.key} not found in \${error.storeName}\`)
  }
}

// Batch resolve - throws if ANY is missing
const users = await store.resolve(['u1', 'u2', 'u3'])
`.trim()}}async function Ke(r){const e=r.store("users"),t=await e.set({id:"demo-user",name:"Demo User",email:"demo@example.com",age:30,status:"active",role:"user",tags:["demo"],createdAt:Date.now()});await e.set({id:"demo-user",name:"Demo User (Updated)",email:"demo@example.com",age:31,status:"active",role:"user",tags:["demo","updated"],createdAt:Date.now()});const s=await e.set([...X]);return await e.remove("demo-user"),{success:!0,message:"set() upserts records (insert or update)",data:{singleKey:t,batchKeys:s},code:`
// Single record - insert or update (upsert)
const key = await store.set({ id: 'u1', name: 'Alice', ... })

// Update existing record (same key)
await store.set({ id: 'u1', name: 'Alice (Updated)', ... })

// Batch set - single transaction, atomic
const keys = await store.set([user1, user2, user3])
`.trim()}}async function Fe(r){const e=r.store("users");let t="";const s={id:"new-user",name:"New User",email:"new@example.com",age:25,status:"active",role:"guest",tags:["new"],createdAt:Date.now()},n=await e.add(s);try{await e.add(s)}catch(o){te(o)&&(t=`ConstraintError: Key "${JSON.stringify(o.key)}" already exists`)}return await e.remove("new-user"),{success:!0,message:"add() throws ConstraintError if key exists",data:{addedKey:n,duplicateError:t},code:`
// add() inserts only - throws if key exists
try {
  await store.add({ id: 'u1', name: 'Alice' })
} catch (error) {
  if (error instanceof ConstraintError) {
    console.log('User already exists, updating instead')
    await store.set({ id: 'u1', name: 'Alice' })
  }
}

// Batch add - fails if ANY key exists
await store.add([user1, user2, user3])
`.trim()}}async function je(r){const e=r.store("users");await e.set({id:"to-delete",name:"To Delete",email:"delete@example.com",age:0,status:"inactive",role:"guest",tags:[],createdAt:Date.now()});const t=await e.count();await e.remove("to-delete"),await e.remove("nonexistent");const s=await e.count();return{success:!0,message:"remove() silently succeeds for missing keys",data:{beforeCount:t,afterCount:s,difference:t-s},code:`
// Single key remove
await store.remove('u1')

// Removing nonexistent key - no error
await store.remove('nonexistent')  // Silently succeeds

// Batch remove
await store.remove(['u1', 'u2', 'u3'])
`.trim()}}async function _e(r){const e=r.store("users"),t=await e.has("u1"),s=await e.has("nonexistent"),n=await e.has(["u1","u2","nonexistent"]);return{success:!0,message:"has() checks if records exist",data:{exists:t,missing:s,batchChecks:n},code:`
// Single key existence check
const exists = await store.has('u1')  // true

// Missing key
const missing = await store.has('nonexistent')  // false

// Batch check
const checks = await store.has(['u1', 'u2', 'nonexistent'])
// [true, true, false]
`.trim()}}async function Ve(r){const e=r.store("users"),t=await e.all(),s=await e.all(null,3),n=await e.keys(),o=await e.count();return{success:!0,message:"Bulk operations: all(), keys(), count()",data:{allCount:t.length,first3Names:s.map(a=>a.name),allKeys:n,count:o},code:`
// Get all records
const allUsers = await store.all()

// Get all with limit
const first3 = await store.all(null, 3)

// With key range
const range = IDBKeyRange.bound('a', 'z')
const subset = await store.all(range)

// Get all keys
const allKeys = await store.keys()

// Count records
const count = await store.count()

// Clear all records (dangerous!)
// await store.clear()
`.trim()}}function He(r){const e=r.store("users");return{success:!0,message:"Store accessor methods",data:{name:e.getName(),keyPath:e.getKeyPath(),indexNames:e.getIndexNames(),autoIncrement:e.hasAutoIncrement()},code:`
const store = db.store('users')

store.getName()           // 'users'
store.getKeyPath()        // 'id'
store.getIndexNames()     // ['byEmail', 'byStatus', ...]
store.hasAutoIncrement()  // false
`.trim()}}async function Ge(r){const e=await r.export();return{success:!0,message:"Database export creates a full backup",data:{name:e.name,version:e.version,exportedAt:e.exportedAt,stores:{users:(e.stores.users?.length??0)+" records",posts:(e.stores.posts?.length??0)+" records",settings:(e.stores.settings?.length??0)+" records"}},code:`
// Export all data from the database
const backup = await db.export()

// backup contains:
// - name: database name
// - version: database version
// - exportedAt: ISO timestamp
// - stores: { [storeName]: records[] }

// Save to localStorage or file
const json = JSON.stringify(backup)
localStorage.setItem('backup', json)

// Or download as file
const blob = new Blob([json], { type: 'application/json' })
const url = URL.createObjectURL(blob)
`.trim()}}async function Qe(r){const e=await r.export(),t=await r.store("users").count(),s=[];await r.import(e,{mode:"merge",onProgress:(o,a,i)=>{(a===1||a===i)&&s.push(`${o}: ${a}/${i}`)}});const n=await r.store("users").count();return{success:!0,message:"Database import with progress tracking",data:{beforeCount:t,afterCount:n,progressLog:s},code:`
// Import with merge mode (default) - updates existing, adds new
await db.import(backup)

// Import with replace mode - clears before importing
await db.import(backup, { mode: 'replace' })

// Import with progress callback
await db.import(backup, {
  mode: 'replace',
  onProgress: (storeName, current, total) => {
    console.log(\`\${storeName}: \${current}/\${total}\`)
  }
})
`.trim()}}async function We(r){const e=await r.getStorageEstimate(),t=s=>{if(s===0)return"0 Bytes";const n=1024,o=["Bytes","KB","MB","GB"],a=Math.floor(Math.log(s)/Math.log(n));return parseFloat((s/Math.pow(n,a)).toFixed(2))+" "+o[a]};return{success:!0,message:"Storage quota information",data:{usage:t(e.usage),quota:t(e.quota),percentUsed:e.percentUsed.toFixed(2)+"%"},code:`
const estimate = await db.getStorageEstimate()

console.log(\`Used: \${estimate.usage} bytes\`)
console.log(\`Quota: \${estimate.quota} bytes\`)
console.log(\`Usage: \${estimate.percentUsed}%\`)

// Warn if storage is getting full
if (estimate.percentUsed > 80) {
  console.warn('Storage nearly full!')
}
`.trim()}}async function Je(r){const e=r.store("users"),t=[];for(let i=0;i<50;i++)t.push({id:`progress-test-${i}-${Date.now()}`,name:`Progress Test ${i}`,email:`progress${i}@example.com`,age:25,status:"active",role:"user",tags:[],createdAt:Date.now()});const s=[];let n=0;const o=performance.now();await e.set(t,{onProgress:(i,c)=>{const l=Math.round(i/c*100);(l>=n+25||i===c)&&(s.push(`${i}/${c} (${l}%)`),n=l)}});const a=Math.round(performance.now()-o);return await e.remove(t.map(i=>i.id)),{success:!0,message:"Bulk operations with progress tracking",data:{recordsInserted:t.length,elapsedMs:a,progressLog:s},code:`
// set() with progress callback
await store.set(users, {
  onProgress: (current, total) => {
    const percent = Math.round((current / total) * 100)
    console.log(\`\${percent}% (\${current}/\${total})\`)
  }
})

// add() also supports progress callbacks
await store.add(newUsers, {
  onProgress: (current, total) => {
    updateProgressBar(current / total)
  }
})
`.trim()}}function ze(r){const e=r.store("users"),t=e.index("byEmail"),s=e.index("byStatus"),n=e.index("byTags");return{success:!0,message:"Index accessor methods",data:{emailIndex:{name:t.getName(),keyPath:t.getKeyPath(),unique:t.isUnique(),multiEntry:t.isMultiEntry()},statusIndex:{name:s.getName(),keyPath:s.getKeyPath(),unique:s.isUnique(),multiEntry:s.isMultiEntry()},tagsIndex:{name:n.getName(),keyPath:n.getKeyPath(),unique:n.isUnique(),multiEntry:n.isMultiEntry()}},code:`
const emailIndex = store.index('byEmail')

emailIndex.getName()      // 'byEmail'
emailIndex.getKeyPath()   // 'email'
emailIndex.isUnique()     // true
emailIndex.isMultiEntry() // false

// Multi-entry index for arrays
const tagsIndex = store.index('byTags')
tagsIndex.isMultiEntry()  // true
`.trim()}}async function Xe(r){const t=r.store("users").index("byEmail"),s=await t.get("alice@example.com"),n=await t.get("nonexistent@example.com");let o="";try{await t.resolve("nonexistent@example.com")}catch{o="NotFoundError thrown as expected"}const a=await t.getKey("alice@example.com");return{success:!0,message:"Index lookup operations",data:{userByEmail:s?.name??"not found",missing:n===void 0?"undefined (correct)":"found",resolveError:o,primaryKey:a},code:`
const emailIndex = store.index('byEmail')

// Get by index key (returns first match)
const user = await emailIndex.get('alice@example.com')

// Returns undefined for missing
const missing = await emailIndex.get('nonexistent@example.com')  // undefined

// resolve throws for missing
const user = await emailIndex.resolve('alice@example.com')  // Throws if not found

// Get primary key for an index key
const primaryKey = await emailIndex.getKey('alice@example.com')  // 'u1'
`.trim()}}async function Ye(r){const t=r.store("users").index("byStatus"),s=await t.all(IDBKeyRange.only("active")),n=await t.all(IDBKeyRange.only("inactive")),o=await t.count("active"),a=await t.count("inactive");return{success:!0,message:"Non-unique index queries",data:{activeUsers:s.map(i=>i.name),inactiveUsers:n.map(i=>i.name),activeCount:o,inactiveCount:a},code:`
const statusIndex = store.index('byStatus')

// Get all matching a specific value
const activeUsers = await statusIndex.all(IDBKeyRange.only('active'))

// Count records with specific index value
const activeCount = await statusIndex.count('active')
const inactiveCount = await statusIndex.count('inactive')
`.trim()}}async function Ze(r){const t=r.store("users").index("byTags"),s=await t.all(IDBKeyRange.only("developer")),n=await t.all(IDBKeyRange.only("designer"));return{success:!0,message:"Multi-entry index for arrays",data:{developersCount:s.length,developers:s.map(o=>({name:o.name,tags:o.tags})),designersCount:n.length,designers:n.map(o=>({name:o.name,tags:o.tags}))},code:`
// Multi-entry index indexes each array element separately
// User: { tags: ['developer', 'leader'] }
// Creates index entries for both 'developer' AND 'leader'

const tagsIndex = store.index('byTags')  // multiEntry: true

// Find all users with 'developer' tag
const developers = await tagsIndex.all(IDBKeyRange.only('developer'))

// Find all users with 'designer' tag
const designers = await tagsIndex.all(IDBKeyRange.only('designer'))
`.trim()}}async function et(r){const t=r.store("users").index("byAge"),s=await t.all(IDBKeyRange.lowerBound(30)),n=await t.all(IDBKeyRange.upperBound(30,!0)),o=await t.all(IDBKeyRange.bound(25,35));return{success:!0,message:"Index range queries",data:{over30:s.map(a=>({name:a.name,age:a.age})),under30:n.map(a=>({name:a.name,age:a.age})),between25And35:o.map(a=>({name:a.name,age:a.age}))},code:`
const ageIndex = store.index('byAge')

// Users over 30
const over30 = await ageIndex.all(IDBKeyRange.lowerBound(30))

// Users under 30 (exclusive)
const under30 = await ageIndex.all(IDBKeyRange.upperBound(30, true))

// Users between 25 and 35 (inclusive)
const between25And35 = await ageIndex.all(IDBKeyRange.bound(25, 35))
`.trim()}}async function tt(r){const t=r.store("users").index("byEmail"),s=await t.has("alice@example.com"),n=await t.has("nonexistent@example.com"),o=await t.has(["alice@example.com","bob@example.com","nonexistent@example.com"]);return{success:!0,message:"Index has() checks existence by index key",data:{exists:s,missing:n,batchChecks:o},code:`
const emailIndex = store.index('byEmail')

// Check if record exists by index key
const exists = await emailIndex.has('alice@example.com')  // true
const missing = await emailIndex.has('nonexistent@example.com')  // false

// Batch check - returns array of booleans
const checks = await emailIndex.has([
  'alice@example.com',
  'bob@example.com',
  'nonexistent@example.com'
])
// [true, true, false]
`.trim()}}function st(r){const s=r.store("users").index("byEmail").native;return{success:!0,message:"Native IDBIndex access",data:{nativeName:s.name,nativeKeyPath:s.keyPath,nativeUnique:s.unique,nativeMultiEntry:s.multiEntry},code:`
const emailIndex = store.index('byEmail')

// Access native IDBIndex for advanced operations
const nativeIndex = emailIndex.native

// Use native APIs
nativeIndex.name        // 'byEmail'
nativeIndex.keyPath     // 'email'
nativeIndex.unique      // true
nativeIndex.multiEntry  // false
`.trim()}}async function rt(r){const e=r.store("users"),t=await e.query().where("byStatus").equals("active").toArray(),s=await e.query().where("byRole").equals("admin").toArray();return{success:!0,message:"where().equals() - Fast indexed queries",data:{activeUsers:t.map(n=>n.name),admins:s.map(n=>n.name)},code:`
// Fast indexed query using where().equals()
const activeUsers = await store.query()
  .where('byStatus').equals('active')
  .toArray()

// Query by role
const admins = await store.query()
  .where('byRole').equals('admin')
  .toArray()

// Note: Uses IDBKeyRange.only() internally for performance
`.trim()}}async function nt(r){const e=r.store("users"),t=await e.query().where("byAge").greaterThan(30).toArray(),s=await e.query().where("byAge").lessThanOrEqual(30).toArray(),n=await e.query().where("byAge").between(25,35).toArray(),o=await e.query().where("byAge").between(25,35,{lowerOpen:!0,upperOpen:!0}).toArray();return{success:!0,message:"Comparison queries: greaterThan, lessThan, between",data:{over30:t.map(a=>({name:a.name,age:a.age})),under30:s.map(a=>({name:a.name,age:a.age})),between25And35:n.map(a=>({name:a.name,age:a.age})),between25And35Exclusive:o.map(a=>({name:a.name,age:a.age}))},code:`
// Greater than (exclusive)
const over30 = await store.query()
  .where('byAge').greaterThan(30)
  .toArray()

// Less than or equal (inclusive)
const under30 = await store.query()
  .where('byAge').lessThanOrEqual(30)
  .toArray()

// Between (inclusive by default)
const between = await store.query()
  .where('byAge').between(25, 35)
  .toArray()

// With exclusivity options
const betweenExclusive = await store.query()
  .where('byAge').between(25, 35, { lowerOpen: true, upperOpen: true })
  .toArray()
`.trim()}}async function ot(r){return{success:!0,message:"startsWith() - String prefix queries",data:{aEmails:(await r.store("users").query().where("byEmail").startsWith("a").toArray()).map(s=>({name:s.name,email:s.email}))},code:`
// String prefix query
const aEmails = await store.query()
  .where('byEmail').startsWith('a')  // 'alice@...', 'adam@...', etc.
  .toArray()

// Uses IDBKeyRange.bound(prefix, prefix + '\\uffff')
`.trim()}}async function at(r){return{success:!0,message:"anyOf() - Multiple value queries",data:{adminOrUser:(await r.store("users").query().where("byRole").anyOf(["admin","user"]).toArray()).map(s=>({name:s.name,role:s.role}))},code:`
// Find records matching any of multiple values
const adminOrUser = await store.query()
  .where('byRole').anyOf(['admin', 'user'])
  .toArray()

// Executes parallel queries and merges results
// Results are deduplicated by primary key
`.trim()}}async function it(r){const e=r.store("users"),t=await e.query().filter(o=>o.email.endsWith("@example.com")).toArray(),s=await e.query().filter(o=>o.age>=30&&o.status==="active").toArray(),n=await e.query().filter(o=>/^[A-D]/.test(o.name)).toArray();return{success:!0,message:"filter() - Flexible post-cursor filtering",data:{gmailUsers:t.map(o=>o.email),activeAdults:s.map(o=>({name:o.name,age:o.age})),namePattern:n.map(o=>o.name)},code:`
// Filter for conditions that can't use indexes
const gmailUsers = await store.query()
  .filter(u => u.email.endsWith('@gmail.com'))
  .toArray()

// Complex conditions
const activeAdults = await store.query()
  .filter(u => u.age >= 30 && u.status === 'active')
  .toArray()

// Regex matching
const pattern = await store.query()
  .filter(u => /^J.*n$/.test(u.name))
  .toArray()
`.trim()}}async function ct(r){return{success:!0,message:"Combining where() and filter() for optimal performance",data:{activeWithE:(await r.store("users").query().where("byStatus").equals("active").filter(s=>s.name.includes("a")).toArray()).map(s=>s.name)},code:`
// Best practice: narrow with index first, then filter
const results = await store.query()
  .where('byStatus').equals('active')  // Fast: uses index
  .filter(u => u.email.endsWith('@gmail.com'))  // Then: post-filter
  .toArray()

// This is more efficient than filtering all records
`.trim()}}async function lt(r){const e=r.store("users"),t=await e.query().where("byAge").greaterThanOrEqual(0).ascending().toArray(),s=await e.query().where("byAge").greaterThanOrEqual(0).descending().toArray(),n=await e.query().limit(2).offset(0).toArray(),o=await e.query().limit(2).offset(2).toArray();return{success:!0,message:"ascending(), descending() and limit/offset pagination",data:{ascending:t.map(a=>({name:a.name,age:a.age})),descending:s.map(a=>({name:a.name,age:a.age})),page1:n.map(a=>a.name),page2:o.map(a=>a.name)},code:`
// Ascending order (default)
const ascending = await store.query()
  .where('byAge').greaterThanOrEqual(0)
  .ascending()
  .toArray()

// Descending order
const descending = await store.query()
  .descending()
  .toArray()

// Pagination
const page1 = await store.query().limit(10).offset(0).toArray()
const page2 = await store.query().limit(10).offset(10).toArray()
`.trim()}}async function ut(r){const e=r.store("users"),t=await e.query().where("byStatus").equals("active").toArray(),s=await e.query().where("byStatus").equals("active").first(),n=await e.query().where("byStatus").equals("active").count(),o=await e.query().where("byStatus").equals("active").keys();return{success:!0,message:"Terminal operations: toArray, first, count, keys",data:{allCount:t.length,first:s?.name??"none",count:n,keys:o},code:`
// Get all matching records
const records = await query.toArray()

// Get first match only (more efficient)
const first = await query.first()

// Count matches (without loading data)
const count = await query.count()

// Get keys only (more efficient than full records)
const keys = await query.keys()

// Memory-efficient iteration
for await (const record of query.iterate()) {
  processRecord(record)
  if (done) break  // Early termination supported
}
`.trim()}}async function dt(r){const e=r.store("users"),t=[];for await(const n of e.query().where("byStatus").equals("active").iterate())t.push(n.name);let s;for await(const n of e.query().iterate())if(n.status==="active"){s=n.name;break}return{success:!0,message:"iterate() - Memory-efficient async generator",data:{iteratedNames:t,firstActive:s},code:`
// Memory-efficient iteration
for await (const user of store.query().iterate()) {
  processUser(user)
  if (done) break  // Clean early termination
}

// Only one record in memory at a time
// Great for large datasets
`.trim()}}async function ht(r){const e=r.store("posts"),t=await e.query().where("byPublished").equals(!0).toArray(),s=await e.query().where("byPublished").equals(!1).toArray();return{success:!0,message:"Boolean queries - Automatic fallback to filter",data:{publishedPosts:t.map(n=>n.title),draftPosts:s.map(n=>n.title)},code:`
// Boolean values are NOT valid IndexedDB keys
// The library automatically handles this

const published = await store.query()
  .where('byPublished').equals(true)  // Works! Falls back to filter
  .toArray()

// This is equivalent to:
const published = await store.query()
  .filter(post => post.published === true)
  .toArray()

// For better performance, consider storing as 0/1 instead
`.trim()}}async function mt(r){let e=0,t=0,s="";return await r.read(["users","posts"],async n=>{const o=await n.store("users").all(),a=await n.store("posts").all();e=o.length,t=a.length,s=o[0]?.name??"none"}),{success:!0,message:"db.read() - Consistent reads across stores",data:{userCount:e,postCount:t,firstUser:s},code:`
// Read transaction - consistent view
await db.read(['users', 'posts'], async (tx) => {
  const users = await tx.store('users').all()
  const posts = await tx.store('posts').all()
  // Both reads see the same snapshot
})

// Single store reads can use store directly
const user = await db.store('users').get('u1')
`.trim()}}async function pt(r){await r.store("posts").set([...Y]);let e="",t="";return await r.write(["users","posts"],async s=>{const n=await s.store("users").resolve("u1");t=n.name;const o={id:"tx-post",title:"Transaction Demo Post",content:"Created in a transaction",authorId:n.id,published:!0,views:0,createdAt:Date.now()};await s.store("posts").set(o),e=o.id}),await r.store("posts").remove("tx-post"),{success:!0,message:"db.write() - Atomic multi-store modifications",data:{createdPostId:e,authorName:t},code:`
// Write transaction - atomic modifications
await db.write(['users', 'posts'], async (tx) => {
  const user = await tx.store('users').resolve('u1')

  await tx.store('posts').set({
    id: crypto.randomUUID(),
    title: 'New Post',
    authorId: user.id,
    // ...
  })

  // Transaction commits on success
  // Aborts on any error (all changes rolled back)
})
`.trim()}}async function yt(r){return await r.write(["settings"],async e=>{await e.store("settings").set({id:"durability-test",key:"test",value:"relaxed",updatedAt:Date.now()})},{durability:"relaxed"}),await r.store("settings").remove("durability-test"),{success:!0,message:"Transaction durability options",data:{durabilityLevels:["default","strict","relaxed"]},code:`
// Durability options control when transaction is considered complete

// 'default' - OS/browser default behavior
await db.write(['logs'], async (tx) => {
  await tx.store('logs').set(entry)
})

// 'strict' - Wait for data to be flushed to disk
await db.write(['critical'], async (tx) => {
  await tx.store('critical').set(data)
}, { durability: 'strict' })

// 'relaxed' - May return before data is flushed (faster)
await db.write(['logs'], async (tx) => {
  await tx.store('logs').set(entry)
}, { durability: 'relaxed' })
`.trim()}}async function gt(r){let e="",t=[],s=!1;return await r.read(["users","posts"],n=>{e=n.getMode(),t=n.getStoreNames(),s=n.isActive()}),{success:!0,message:"Transaction accessor methods",data:{mode:e,storeNames:t,isActive:s},code:`
await db.read(['users', 'posts'], async (tx) => {
  tx.getMode()         // 'readonly' | 'readwrite'
  tx.getStoreNames()   // ['users', 'posts']
  tx.isActive()        // true (while in operation)
  tx.isFinished()      // false (until complete/abort)
})
`.trim()}}async function ft(r){const e=await r.store("settings").count();let t=!1;try{await r.write(["settings"],async n=>{await n.store("settings").set({id:"abort-test",key:"abort",value:"should be rolled back",updatedAt:Date.now()}),n.abort()})}catch{t=!0}const s=await r.store("settings").count();return{success:!0,message:"Transaction abort - rolls back all changes",data:{beforeCount:e,afterCount:s,errorCaught:t,recordsAdded:s-e},code:`
await db.write(['users'], async (tx) => {
  await tx.store('users').set(user1)
  await tx.store('users').set(user2)

  if (someCondition) {
    tx.abort()  // Roll back ALL changes
  }
})

// Also aborts on any thrown error:
await db.write(['users'], async (tx) => {
  await tx.store('users').set(user)
  throw new Error('Something went wrong')
  // Transaction is automatically aborted
})
`.trim()}}async function wt(r){let e="";return await r.read(["users"],t=>{e=t.native.mode}),{success:!0,message:"Native IDBTransaction access",data:{nativeMode:e},code:`
await db.write(['users'], async (tx) => {
  // Access native IDBTransaction
  const nativeTx = tx.native

  // Use native APIs when needed
  nativeTx.mode           // 'readonly' | 'readwrite'
  nativeTx.objectStoreNames  // DOMStringList
  nativeTx.db             // IDBDatabase
})
`.trim()}}async function bt(r){const e=r.store("users"),t=[];for await(const n of e.iterate())t.push(n.name);const s=[];for await(const n of e.iterate({direction:"previous"}))s.push(n.name);return{success:!0,message:"iterate() - Memory-efficient async generator",data:{names:t,reversedNames:s},code:`
// Simple iteration
for await (const user of store.iterate()) {
  console.log(user.name)
}

// With options
for await (const user of store.iterate({
  direction: 'previous',  // Reverse order
  query: IDBKeyRange.bound('a', 'm')  // Filter by key range
})) {
  console.log(user.name)
}

// Early termination is clean
for await (const user of store.iterate()) {
  if (found) break  // Resources properly cleaned up
}
`.trim()}}async function vt(r){const e=r.store("users"),t=[];for await(const s of e.iterateKeys())t.push(JSON.stringify(s));return{success:!0,message:"iterateKeys() - Efficient key-only iteration",data:{keys:t},code:`
// Key-only iteration - more efficient than full records
for await (const key of store.iterateKeys()) {
  console.log(key)
}

// Use when you only need keys, not full records
// Doesn't load record data = less memory, faster
`.trim()}}async function xt(r){const e=r.store("users"),t=[];let s=await e.openCursor();for(;s;)t.push({key:s.getKey(),name:s.getValue().name}),s=await s.continue();return{success:!0,message:"openCursor() - Manual cursor control",data:{recordCount:t.length,records:t},code:`
// Manual cursor for full control
let cursor = await store.openCursor()

while (cursor) {
  const key = cursor.getKey()
  const primaryKey = cursor.getPrimaryKey()
  const value = cursor.getValue()
  const direction = cursor.getDirection()

  console.log(\`\${key}: \${value.name}\`)

  cursor = await cursor.continue()
}
`.trim()}}async function Et(r){await r.store("users").set({id:"cursor-test-1",name:"Cursor Test User 1",email:"cursor1@test.com",age:99,status:"inactive",role:"guest",tags:["test"],createdAt:Date.now()}),await r.store("users").set({id:"cursor-test-2",name:"Cursor Test User 2",email:"cursor2@test.com",age:98,status:"inactive",role:"guest",tags:["test"],createdAt:Date.now()});let e=0,t=0;return await r.write(["users"],async s=>{let n=await s.store("users").openCursor();for(;n;){const o=n.getValue();o.id==="cursor-test-1"?(await n.update({...o,name:"Updated via Cursor"}),e++):o.id==="cursor-test-2"&&(await n.delete(),t++),n=await n.continue()}}),await r.store("users").remove("cursor-test-1"),{success:!0,message:"Cursor mutation - Update and delete during iteration",data:{updated:e,deleted:t},code:`
// Use write transaction for cursor mutations
await db.write(['users'], async (tx) => {
  let cursor = await tx.store('users').openCursor()

  while (cursor) {
    const user = cursor.getValue()

    if (user.status === 'inactive') {
      // Delete during iteration
      await cursor.delete()
    } else if (user.needsUpdate) {
      // Update during iteration
      await cursor.update({ ...user, updatedAt: Date.now() })
    }

    cursor = await cursor.continue()
  }
})
`.trim()}}async function At(r){const e=r.store("users"),t=[];let s=await e.openCursor();s&&(t.push(s.getValue().name),s=await s.continue(),s&&t.push(s.getValue().name));const n=[];return s=await e.openCursor(),s&&(n.push(s.getValue().name),s=await s.advance(2),s&&n.push(`(after skip 2) ${s.getValue().name}`)),{success:!0,message:"Cursor navigation methods",data:{continued:t,advanced:n},code:`
let cursor = await store.openCursor()

// Continue to next record
cursor = await cursor.continue()

// Continue to specific key
cursor = await cursor.continue('u5')

// Skip N records
cursor = await cursor.advance(5)

// For index cursors: continue to specific primary key
// cursor = await cursor.continuePrimaryKey(indexKey, primaryKey)
`.trim()}}async function Ct(r){const e=r.store("users"),t=[];for await(const n of e.iterate({direction:"next"}))t.push(n.name);const s=[];for await(const n of e.iterate({direction:"previous"}))s.push(n.name);return{success:!0,message:"Cursor directions",data:{forward:t,backward:s,directions:["next","nextunique","previous","previousunique"]},code:`
// Direction options:
// 'next'           - Ascending, include duplicates (default)
// 'nextunique'     - Ascending, skip duplicates
// 'previous'       - Descending, include duplicates
// 'previousunique' - Descending, skip duplicates

for await (const user of store.iterate({ direction: 'previous' })) {
  console.log(user.name)  // Reverse order
}
`.trim()}}async function St(r){const e=r.store("users"),t=[];let s=await e.openKeyCursor();for(;s;)t.push(JSON.stringify(s.getKey())),s=await s.continue();return{success:!0,message:"Key cursor - Efficient key-only access",data:{keys:t},code:`
// Key cursor doesn't load record values
// More efficient when you only need keys

let keyCursor = await store.openKeyCursor()

while (keyCursor) {
  const key = keyCursor.getKey()
  const primaryKey = keyCursor.getPrimaryKey()
  const direction = keyCursor.getDirection()

  console.log(key)

  keyCursor = await keyCursor.continue()
}
`.trim()}}async function Tt(r){const t=r.store("users").index("byStatus"),s=[];for await(const n of t.iterate({query:IDBKeyRange.only("active")}))s.push({indexKey:"active",primaryKey:n.id,name:n.name});return{success:!0,message:"Index cursors - Iterate through index",data:{activeUsers:s},code:`
const statusIndex = store.index('byStatus')

// Iterate through index
for await (const user of statusIndex.iterate({
  query: IDBKeyRange.only('active')
})) {
  console.log(user.name)
}

// Manual index cursor
let cursor = await statusIndex.openCursor()
while (cursor) {
  // cursor.getKey() returns index key
  // cursor.getPrimaryKey() returns primary key
  // cursor.getValue() returns full record
  cursor = await cursor.continue()
}
`.trim()}}const B=[];async function kt(r){B.length=0;const e=[],t=r.onChange(s=>{B.push({...s,timestamp:Date.now()})});return e.push(t),await r.store("settings").set({id:"event-test",key:"test",value:"trigger-change",updatedAt:Date.now()}),await r.store("settings").remove("event-test"),await new Promise(s=>setTimeout(s,50)),e.forEach(s=>s()),{success:!0,message:"db.onChange() - Database-level change events",data:{events:B.map(s=>({storeName:s.storeName,type:s.type,keys:s.keys,source:s.source}))},code:`
// Subscribe to all changes across all stores
const unsubscribe = db.onChange((event) => {
  console.log(\`\${event.storeName}: \${event.type}\`, event.keys)

  if (event.source === 'remote') {
    // Change from another tab
    refreshUI()
  }
})

// Event structure:
// {
//   storeName: string,      // Store that changed
//   type: 'set' | 'add' | 'remove' | 'clear',
//   keys: ValidKey[],       // Affected keys
//   source: 'local' | 'remote'  // Origin
// }

// Cleanup when done
unsubscribe()
`.trim()}}async function Nt(r){B.length=0;const e=[],t=r.store("settings").onChange(s=>{B.push({...s,timestamp:Date.now()})});return e.push(t),await r.store("settings").set({id:"store-event-test",key:"test",value:"store-level",updatedAt:Date.now()}),await r.store("users").set({id:"no-trigger",name:"No Trigger",email:"no@trigger.com",age:0,status:"inactive",role:"guest",tags:[],createdAt:Date.now()}),await new Promise(s=>setTimeout(s,50)),await r.store("settings").remove("store-event-test"),await r.store("users").remove("no-trigger"),e.forEach(s=>s()),{success:!0,message:"store.onChange() - Store-level change events",data:{settingsEvents:B.length,events:B.map(s=>({type:s.type,keys:s.keys}))},code:`
// Subscribe to specific store changes only
const unsubscribe = db.store('users').onChange((event) => {
  if (event.type === 'set') {
    invalidateCache(event.keys)
  }
})

// Only triggers for changes to this store
// More efficient than database-level when targeting one store

unsubscribe()
`.trim()}}function Dt(r){return{success:!0,message:"Cross-tab synchronization via BroadcastChannel",data:{crossTabSyncEnabled:!0,howToTest:"Open this page in another tab and make changes"},code:`
// Cross-tab sync is enabled by default
const db = createDatabase<AppSchema>({
  name: 'myApp',
  version: 1,
  stores: { users: {} },
  crossTabSync: true  // Default: true
})

// Changes in Tab 1
await db.store('users').set({ id: 'u1', name: 'Alice' })

// Tab 2 receives change event with source: 'remote'
db.onChange((event) => {
  if (event.source === 'remote') {
    console.log('Another tab made changes:', event)
    refreshUI()
  }
})

// Disable if not needed (saves resources)
const db = createDatabase({
  // ...
  crossTabSync: false
})
`.trim()}}function It(r){const e=[];return r.onError(s=>{e.push(s.message)})(),{success:!0,message:"db.onError() - Error event handling",data:{subscribedToErrors:!0,note:"Errors are captured for logging/analytics"},code:`
// Subscribe to error events
const unsubscribe = db.onError((error) => {
  console.error('Database error:', error)
  reportToAnalytics(error)
})

// Useful for:
// - Centralized error logging
// - Analytics
// - User notifications
// - Error recovery strategies

unsubscribe()
`.trim()}}function qt(r){let e=!1;return r.onVersionChange(()=>{e=!0})(),{success:!0,message:"db.onVersionChange() - Handle version upgrades",data:{subscribedToVersionChange:!0,versionChangeReceived:e},code:`
// Triggered when another tab wants to upgrade the database
const unsubscribe = db.onVersionChange((event) => {
  console.log(\`Upgrade requested: v\${event.oldVersion} -> v\${event.newVersion}\`)

  // Typically close connection to allow upgrade
  showNotification('Updating app, please wait...')
  db.close()
})

// Important for:
// - Graceful handling of database upgrades
// - User communication during upgrades
// - Preventing upgrade blocking

unsubscribe()
`.trim()}}function Ot(r){let e=!1;return r.onClose(()=>{e=!0})(),{success:!0,message:"db.onClose() - Handle connection close",data:{subscribedToClose:!0,closeReceived:e},code:`
// Triggered when database connection closes
const unsubscribe = db.onClose(() => {
  console.log('Database connection closed')

  // Reconnect or show offline message
  showOfflineMessage()
})

// Useful for:
// - Cleanup resources
// - Show offline indicators
// - Reconnection logic

unsubscribe()
`.trim()}}function Pt(){return{success:!0,message:"Event hooks in database options",data:{availableHooks:["onChange","onError","onBlocked","onVersionChange","onClose"]},code:`
// Set up event handlers at creation time
const db = createDatabase<AppSchema>({
  name: 'myApp',
  version: 1,
  stores: { users: {} },

  // Event hooks
  onChange: (event) => {
    console.log('Change:', event)
    syncToUI()
  },

  onError: (error) => {
    console.error('Error:', error)
    reportError(error)
  },

  onBlocked: () => {
    console.warn('Upgrade blocked by other tabs')
    showCloseTabsMessage()
  },

  onVersionChange: (event) => {
    console.log('Version change:', event)
    prepareForUpgrade()
  },

  onClose: () => {
    console.log('Connection closed')
    showOfflineStatus()
  }
})
`.trim()}}async function Rt(r){const e=r.store("users");let t=null;try{await e.resolve("nonexistent-user")}catch(s){s instanceof R&&(t={name:s.name,code:s.code,key:JSON.stringify(s.key),storeName:s.storeName})}return{success:!0,message:"NotFoundError - Thrown by resolve() for missing records",data:{errorDetails:t},code:`
try {
  const user = await store.resolve('nonexistent')
} catch (error) {
  if (error instanceof NotFoundError) {
    console.log(\`Key: \${error.key}\`)
    console.log(\`Store: \${error.storeName}\`)
    console.log(\`Code: \${error.code}\`)  // 'NOT_FOUND'
  }
}

// NotFoundError properties:
// - code: 'NOT_FOUND'
// - key: ValidKey - The missing key
// - storeName: string - The store name
`.trim()}}async function $t(r){const e=r.store("users");let t=null;await e.set({id:"constraint-test",name:"Constraint Test",email:"constraint@test.com",age:30,status:"active",role:"user",tags:[],createdAt:Date.now()});try{await e.add({id:"constraint-test",name:"Duplicate",email:"dupe@test.com",age:25,status:"active",role:"user",tags:[],createdAt:Date.now()})}catch(s){s instanceof Z&&(t={name:s.name,code:s.code,key:JSON.stringify(s.key)})}return await e.remove("constraint-test"),{success:!0,message:"ConstraintError - Thrown by add() for duplicate keys",data:{errorDetails:t},code:`
try {
  await store.add({ id: 'existing', name: 'Duplicate' })
} catch (error) {
  if (error instanceof ConstraintError) {
    console.log('Key already exists:', error.key)

    // Common pattern: fallback to set() for upsert
    await store.set({ id: 'existing', name: 'Updated' })
  }
}

// ConstraintError properties:
// - code: 'CONSTRAINT_ERROR'
// - key: ValidKey - The conflicting key
// - storeName: string - The store name
`.trim()}}function Ut(){return{success:!0,message:"Error codes for different failure modes",data:{errorCodes:["NOT_FOUND","CONSTRAINT_ERROR","QUOTA_EXCEEDED","TRANSACTION_ABORTED","TRANSACTION_INACTIVE","OPEN_FAILED","UPGRADE_FAILED","UPGRADE_BLOCKED","DATA_ERROR","READ_ONLY","VERSION_ERROR","INVALID_STATE","TIMEOUT","UNKNOWN_ERROR"]},code:`
// All database errors have a code property
type DatabaseErrorCode =
  | 'OPEN_FAILED'           // Database failed to open
  | 'UPGRADE_FAILED'        // Migration or store creation failed
  | 'UPGRADE_BLOCKED'       // Other connections prevent upgrade
  | 'TRANSACTION_ABORTED'   // Transaction was aborted
  | 'TRANSACTION_INACTIVE'  // Operation on inactive transaction
  | 'CONSTRAINT_ERROR'      // Key/uniqueness constraint violated
  | 'QUOTA_EXCEEDED'        // Storage quota exceeded
  | 'NOT_FOUND'             // Record not found (resolve())
  | 'DATA_ERROR'            // Invalid data format
  | 'READ_ONLY'             // Write attempted on readonly transaction
  | 'VERSION_ERROR'         // Version conflict
  | 'INVALID_STATE'         // Database in invalid state
  | 'TIMEOUT'               // Operation timed out
  | 'UNKNOWN_ERROR'         // Unrecognized error
`.trim()}}async function Mt(r){const e=r.store("users");let t=!1,s=!1,n=!1,o=!1;try{await e.resolve("nonexistent")}catch(a){t=ee(a),n=Ae(a),o=Ce(a,"NOT_FOUND")}await e.set({id:"guard-test",name:"Guard Test",email:"guard@test.com",age:30,status:"active",role:"user",tags:[],createdAt:Date.now()});try{await e.add({id:"guard-test",name:"Duplicate",email:"dupe@test.com",age:25,status:"active",role:"user",tags:[],createdAt:Date.now()})}catch(a){s=te(a)}return await e.remove("guard-test"),{success:!0,message:"Type guards for safe error handling",data:{isNotFoundError:t,isConstraintError:s,isDatabaseError:n,hasErrorCode:o},code:`
import {
  isDatabaseError,
  isNotFoundError,
  isConstraintError,
  isQuotaExceededError,
  isTransactionError,
  hasErrorCode
} from '@mikesaintsg/indexeddb'

try {
  await store.resolve('u1')
} catch (error) {
  if (isNotFoundError(error)) {
    // error is typed as NotFoundError
    console.log(error.key, error.storeName)
  } else if (isConstraintError(error)) {
    // error is typed as ConstraintError
    console.log(error.key)
  } else if (isDatabaseError(error)) {
    // error is typed as DatabaseError
    console.log(error.code, error.message)
  }

  // Check for specific error code
  if (hasErrorCode(error, 'QUOTA_EXCEEDED')) {
    showStorageFullMessage()
  }
}
`.trim()}}function Bt(){return{success:!0,message:"Error class hierarchy",data:{hierarchy:["DatabaseError (base)","  ââ NotFoundError","  ââ ConstraintError","  ââ QuotaExceededError","  ââ TransactionError","  ââ UpgradeError","  ââ OpenError","  ââ DataError","  ââ ReadOnlyError","  ââ VersionError","  ââ InvalidStateError","  ââ TimeoutError"]},code:`
// Error class hierarchy:
// DatabaseError (base) â all database errors
//   ââ NotFoundError â resolve() when record missing
//   ââ ConstraintError â add() when key exists
//   ââ QuotaExceededError â storage quota exceeded
//   ââ TransactionError â transaction aborted or inactive
//   ââ UpgradeError â database upgrade failed or blocked
//   ââ OpenError â database failed to open
//   ââ DataError â invalid data format
//   ââ ReadOnlyError â write on readonly transaction
//   ââ VersionError â version conflict
//   ââ InvalidStateError â invalid database state
//   ââ TimeoutError â operation timed out

// All errors extend DatabaseError
if (error instanceof DatabaseError) {
  console.log(error.code)     // Error code
  console.log(error.message)  // Error message
  console.log(error.cause)    // Original error (if wrapped)
}
`.trim()}}async function Lt(r){const e=r.store("users"),t=[],s=await e.get("nonexistent");t.push(`get() returns: ${s===void 0?"undefined":"value"}`);try{await e.resolve("nonexistent")}catch(n){ee(n)&&t.push("resolve() throws NotFoundError")}await e.set({id:"error-demo",name:"Demo",email:"demo@test.com",age:30,status:"active",role:"user",tags:[],createdAt:Date.now()});try{await e.add({id:"error-demo",name:"Duplicate",email:"dupe@test.com",age:25,status:"active",role:"user",tags:[],createdAt:Date.now()})}catch(n){te(n)&&t.push("add() throws ConstraintError")}return await e.remove("error-demo"),{success:!0,message:"Comprehensive error handling patterns",data:{results:t},code:`
// Comprehensive error handling pattern
async function safeOperation() {
  try {
    const user = await store.resolve('u1')
    await store.add(newRecord)
  } catch (error) {
    if (isNotFoundError(error)) {
      // Handle missing record
      return createDefault()
    }

    if (isConstraintError(error)) {
      // Handle duplicate key
      return store.set(record)  // Fallback to upsert
    }

    if (isQuotaExceededError(error)) {
      // Handle storage full
      await clearOldData()
      return retry()
    }

    if (isTransactionError(error)) {
      // Handle transaction failure
      await retry()
    }

    // Unknown error - rethrow
    throw error
  }
}
`.trim()}}function y(r,e){const t=r.querySelector(e);if(!t){const s=r.id?`#${r.id}`:"";throw new Error(`Element not found: ${e} in ${r.tagName.toLowerCase()}${s}`)}return t}const _=["Alice","Bob","Carol","David","Emma","Frank","Grace","Henry","Ivy","Jack","Kate","Leo","Maya","Noah","Olivia","Peter","Quinn","Rose","Sam","Tara"],V=["Anderson","Brown","Clark","Davis","Evans","Foster","Garcia","Harris","Ivanov","Jones","Kim","Lee","Miller","Nelson","Ortiz","Park","Quinn","Roberts","Smith","Taylor"],H=["gmail.com","outlook.com","yahoo.com","proton.me","icloud.com"],ae=["admin","user","user","user","guest"],ie=["active","active","active","inactive"],ce=["developer","designer","manager","marketing","sales","support","hr","finance","ops","engineering"];function me(r){const e=_[Math.floor(Math.random()*_.length)]??"User",t=V[Math.floor(Math.random()*V.length)]??"Unknown",s=H[Math.floor(Math.random()*H.length)]??"example.com",n=ae[Math.floor(Math.random()*ae.length)]??"user",o=ie[Math.floor(Math.random()*ie.length)]??"active",a=Math.floor(Math.random()*4),i=[];for(let c=0;c<a;c++){const l=ce[Math.floor(Math.random()*ce.length)];l&&!i.includes(l)&&i.push(l)}return{id:`bulk-${r}-${Date.now()}`,name:`${e} ${t}`,email:`${e.toLowerCase()}.${t.toLowerCase()}${r}@${s}`,age:18+Math.floor(Math.random()*50),status:o,role:n,tags:i,createdAt:Date.now()-Math.floor(Math.random()*365*24*60*60*1e3)}}async function Kt(r){await r.store("users").set([...X]),await r.store("posts").set([...Y]),await r.store("settings").set([...le]);const e=[];for(let t=0;t<100;t++)e.push(me(t));await r.store("users").set(e)}function Ft(){let r;return{html:`
			<div class="demo-app bulk-performance">
				<h4>â¡ Bulk Performance Demo</h4>
				<p class="demo-desc">Insert and query <strong>10,000+ records</strong> with real-time performance metrics. Shows the power of IndexedDB for large datasets.</p>

				<div class="performance-panel">
					<div class="perf-controls">
						<div class="perf-row">
							<label>Records to insert:</label>
							<select id="bulk-count" class="demo-select">
								<option value="1000">1,000</option>
								<option value="5000">5,000</option>
								<option value="10000" selected>10,000</option>
								<option value="25000">25,000</option>
								<option value="50000">50,000</option>
							</select>
							<button id="bulk-insert-btn" class="btn primary">ð Bulk Insert</button>
							<button id="bulk-clear-btn" class="btn danger">ðï¸ Clear All</button>
						</div>
					</div>

					<div class="perf-stats">
						<div class="perf-stat-card">
							<span class="perf-label">Total Records</span>
							<span class="perf-value" id="total-records">0</span>
						</div>
						<div class="perf-stat-card">
							<span class="perf-label">Insert Time</span>
							<span class="perf-value" id="insert-time">â</span>
						</div>
						<div class="perf-stat-card">
							<span class="perf-label">Records/sec</span>
							<span class="perf-value" id="insert-rate">â</span>
						</div>
						<div class="perf-stat-card">
							<span class="perf-label">Query Time</span>
							<span class="perf-value" id="query-time">â</span>
						</div>
					</div>

					<div class="perf-progress" id="perf-progress" style="display: none;">
						<div class="progress-bar">
							<div class="progress-fill" id="perf-progress-fill" style="width: 0%"></div>
						</div>
						<span id="perf-progress-text">Preparing...</span>
					</div>
				</div>

				<div class="query-section">
					<h5>ð Query Performance</h5>
					<div class="query-row">
						<select id="query-type" class="demo-select">
							<option value="all">all() - Get all records</option>
							<option value="count">count() - Count records</option>
							<option value="status">where(status).equals('active')</option>
							<option value="age-range">where(age).between(25, 40)</option>
							<option value="role">where(role).equals('admin')</option>
							<option value="filter">filter(age > 30 AND role='user')</option>
						</select>
						<button id="run-query-btn" class="btn primary">â¶ Run Query</button>
					</div>
					<div class="query-results" id="query-results">
						<p class="placeholder">Select a query and click Run</p>
					</div>
				</div>

				<div class="demo-log" id="bulk-log"></div>
			</div>
		`,init:async(e,t)=>{const s=t.store("users"),n=y(e,"#total-records"),o=y(e,"#insert-time"),a=y(e,"#insert-rate"),i=y(e,"#query-time"),c=y(e,"#perf-progress"),l=y(e,"#perf-progress-fill"),u=y(e,"#perf-progress-text"),h=y(e,"#bulk-count"),d=y(e,"#bulk-insert-btn"),m=y(e,"#bulk-clear-btn"),f=y(e,"#query-type"),w=y(e,"#run-query-btn"),A=y(e,"#query-results"),C=y(e,"#bulk-log");function g(v,E="info"){const k=document.createElement("div");k.className=`log-entry ${E}`,k.textContent=`${new Date().toLocaleTimeString()} - ${v}`,C.insertBefore(k,C.firstChild),C.children.length>8&&C.lastChild&&C.removeChild(C.lastChild)}async function b(){const v=await s.count();n.textContent=v.toLocaleString()}d.onclick=()=>{const v=parseInt(h.value,10);d.disabled=!0,m.disabled=!0,c.style.display="block",l.style.width="0%",u.textContent=`Generating ${v.toLocaleString()} records...`,g(`Starting bulk insert of ${v.toLocaleString()} records...`,"info"),(async()=>{try{const E=[];for(let q=0;q<v;q++)E.push(me(q));u.textContent="Inserting into IndexedDB...";const k=performance.now();await s.set(E,{onProgress:(q,T)=>{const L=Math.round(q/T*100);l.style.width=`${L}%`,(q%Math.ceil(T/20)===0||q===T)&&(u.textContent=`Inserted ${q.toLocaleString()} of ${T.toLocaleString()} (${L}%)...`)}});const D=performance.now()-k,P=Math.round(v/(D/1e3));o.textContent=`${D.toFixed(0)}ms`,a.textContent=P.toLocaleString(),g(`â Inserted ${v.toLocaleString()} records in ${D.toFixed(0)}ms (${P.toLocaleString()}/sec)`,"success"),await b(),c.style.display="none"}catch(E){g(`Error: ${E instanceof Error?E.message:"Unknown"}`,"error"),c.style.display="none"}finally{d.disabled=!1,m.disabled=!1}})()},m.onclick=()=>{(async()=>{try{const v=await s.count();await s.clear(),g(`Cleared ${v.toLocaleString()} records`,"info"),g("Restoring sample data for other demos...","info"),await Kt(t),g("Restored 100+ sample records","success"),await b(),o.textContent="â",a.textContent="â",i.textContent="â"}catch(v){g(`Error during clear: ${v instanceof Error?v.message:"Unknown"}`,"error")}})()},w.onclick=()=>{const v=f.value;w.disabled=!0,(async()=>{try{const E=performance.now();let k,D=0,P="";switch(v){case"all":{const T=await s.all();D=T.length,k=T.slice(0,5),P="await store.all()";break}case"count":{D=await s.count(),k=D,P="await store.count()";break}case"status":{const T=await s.query().where("byStatus").equals("active").toArray();D=T.length,k=T.slice(0,5),P="await store.query().where('byStatus').equals('active').toArray()";break}case"age-range":{const T=await s.query().where("byAge").between(25,40).toArray();D=T.length,k=T.slice(0,5),P="await store.query().where('byAge').between(25, 40).toArray()";break}case"role":{const T=await s.query().where("byRole").equals("admin").toArray();D=T.length,k=T.slice(0,5),P="await store.query().where('byRole').equals('admin').toArray()";break}case"filter":{const T=await s.query().filter(L=>L.age>30&&L.role==="user").toArray();D=T.length,k=T.slice(0,5),P="await store.query().filter(u => u.age > 30 && u.role === 'user').toArray()";break}}const q=performance.now()-E;i.textContent=`${q.toFixed(1)}ms`,A.innerHTML=`
							<div class="query-result-box">
								<div class="query-meta">
									<span class="query-count">Found: <strong>${D.toLocaleString()}</strong> records</span>
									<span class="query-elapsed">Time: <strong>${q.toFixed(1)}ms</strong></span>
								</div>
								<div class="query-code-block">
									<code class="syntax-highlight">${P}</code>
								</div>
								<div class="query-preview">
									<strong>Preview (first 5):</strong>
									<pre>${JSON.stringify(k,null,2)}</pre>
								</div>
							</div>
						`,g(`Query returned ${D.toLocaleString()} records in ${q.toFixed(1)}ms`,"success")}catch(E){g(`Query error: ${E instanceof Error?E.message:"Unknown"}`,"error")}finally{w.disabled=!1}})()},r=s.onChange(()=>{b()}),await b(),g("Bulk Performance Demo ready! Try inserting 10,000+ records.","info")},cleanup:()=>{r?.()}}}function jt(){return{html:`
			<div class="demo-app user-search">
				<h4>ð User Search</h4>
				<p class="demo-desc">Search and filter users with <code>where()</code>, <code>filter()</code>, and <code>orderBy()</code></p>

				<div class="demo-filters">
					<input type="text" id="search-name" placeholder="Search by name..." class="demo-input" />
					<select id="filter-status" class="demo-select">
						<option value="">All Statuses</option>
						<option value="active">Active</option>
						<option value="inactive">Inactive</option>
					</select>
					<select id="filter-role" class="demo-select">
						<option value="">All Roles</option>
						<option value="admin">Admin</option>
						<option value="user">User</option>
						<option value="guest">Guest</option>
					</select>
				</div>

				<div class="demo-stats">
					<span class="stat">Results: <strong id="search-count">0</strong></span>
					<span class="stat">Query time: <strong id="search-time">0</strong>ms</span>
				</div>

				<div class="query-display" id="query-display">
					<strong>Query:</strong> <code id="query-code">store.all()</code>
				</div>

				<div class="demo-list" id="search-results">
					<p class="placeholder">Enter search criteria above...</p>
				</div>
			</div>
		`,init:(r,e)=>{const t=e.store("users"),s=y(r,"#search-results"),n=y(r,"#search-count"),o=y(r,"#search-time"),a=y(r,"#query-code"),i=y(r,"#search-name"),c=y(r,"#filter-status"),l=y(r,"#filter-role");async function u(){const m=i.value.toLowerCase().trim(),f=c.value,w=l.value,A=performance.now();let C=t.query();const g=["store.query()"];f&&(C=C.where("byStatus").equals(f),g.push(`.where('byStatus').equals('${f}')`)),m&&(C=C.filter(E=>E.name.toLowerCase().includes(m)),g.push(`.filter(u => u.name.includes('${m}'))`)),w&&(C=C.filter(E=>E.role===w),g.push(`.filter(u => u.role === '${w}')`)),g.push(".toArray()");const b=await C.toArray(),v=Math.round(performance.now()-A);if(n.textContent=String(b.length),o.textContent=String(v),a.textContent=g.join(`
  `),b.length===0){s.innerHTML='<p class="placeholder">No users match your criteria</p>';return}s.innerHTML=b.map(E=>`
					<div class="list-item">
						<div class="item-info">
							<strong>${E.name}</strong>
							<span class="item-meta">${E.email} â¢ Age ${E.age} â¢ ${E.status} â¢ ${E.role}</span>
						</div>
					</div>
				`).join("")}let h;function d(){clearTimeout(h),h=setTimeout(()=>{u()},150)}i.oninput=d,c.onchange=d,l.onchange=d,u()}}}function _t(){return{html:`
			<div class="demo-app shopping-cart">
				<h4>ð Shopping Cart</h4>
				<p class="demo-desc">Atomic checkout with <code>write()</code> transaction - all operations succeed or all fail</p>

				<div class="cart-layout">
					<div class="cart-products">
						<h5>Products</h5>
						<div class="product-list">
							<div class="product-item" data-id="prod1">
								<span class="product-name">ð± Smartphone</span>
								<span class="product-price">$599</span>
								<button class="btn small add-to-cart" data-id="prod1" data-name="Smartphone" data-price="599">Add</button>
							</div>
							<div class="product-item" data-id="prod2">
								<span class="product-name">ð» Laptop</span>
								<span class="product-price">$1299</span>
								<button class="btn small add-to-cart" data-id="prod2" data-name="Laptop" data-price="1299">Add</button>
							</div>
							<div class="product-item" data-id="prod3">
								<span class="product-name">ð§ Headphones</span>
								<span class="product-price">$199</span>
								<button class="btn small add-to-cart" data-id="prod3" data-name="Headphones" data-price="199">Add</button>
							</div>
						</div>
					</div>

					<div class="cart-summary">
						<h5>Cart</h5>
						<div id="cart-items" class="cart-items">
							<p class="placeholder">Cart is empty</p>
						</div>
						<div class="cart-total">
							Total: <strong>$<span id="cart-total">0</span></strong>
						</div>
						<button id="checkout-btn" class="btn primary" disabled>â Checkout (Atomic)</button>
						<button id="checkout-fail-btn" class="btn danger" disabled>â Simulate Failure</button>
					</div>
				</div>

				<div class="demo-log" id="cart-log"></div>
			</div>
		`,init:(r,e)=>{const t=y(r,"#cart-items"),s=y(r,"#cart-total"),n=y(r,"#cart-log"),o=y(r,"#checkout-btn"),a=y(r,"#checkout-fail-btn"),i=new Map;function c(u,h="info"){const d=document.createElement("div");d.className=`log-entry ${h}`,d.textContent=`${new Date().toLocaleTimeString()} - ${u}`,n.insertBefore(d,n.firstChild),n.children.length>8&&n.lastChild&&n.removeChild(n.lastChild)}function l(){const u=Array.from(i.values()),h=u.reduce((d,m)=>d+m.price*m.quantity,0);if(s.textContent=String(h),o.disabled=u.length===0,a.disabled=u.length===0,u.length===0){t.innerHTML='<p class="placeholder">Cart is empty</p>';return}t.innerHTML=u.map(d=>`
					<div class="cart-item">
						<span>${d.name} x${d.quantity}</span>
						<span>$${d.price*d.quantity}</span>
						<button class="btn small danger remove-item" data-id="${d.id}">Ã</button>
					</div>
				`).join(""),t.querySelectorAll(".remove-item").forEach(d=>{const m=d;m.onclick=()=>{const f=m.dataset.id??"",w=i.get(f);w&&w.quantity>1?i.set(f,{...w,quantity:w.quantity-1}):i.delete(f),l(),c(`Removed ${w?.name??"item"} from cart`)}})}r.querySelectorAll(".add-to-cart").forEach(u=>{const h=u;h.onclick=()=>{const d=h.dataset.id??"",m=h.dataset.name??"",f=parseInt(h.dataset.price??"0",10),w=i.get(d);w?i.set(d,{...w,quantity:w.quantity+1}):i.set(d,{id:d,name:m,price:f,quantity:1}),l(),c(`Added ${m} to cart`)}}),o.onclick=()=>{c("Starting atomic transaction...","info"),e.write(["settings"],async u=>{const h=u.store("settings"),d=Array.from(i.values()),m=`order-${Date.now()}`,f={id:m,key:"lastOrder",value:JSON.stringify({items:d.map(w=>({name:w.name,qty:w.quantity})),total:d.reduce((w,A)=>w+A.price*A.quantity,0)}),updatedAt:Date.now()};await h.set(f),c(`TX: Created order ${m}`,"info")}).then(()=>{c("â Transaction committed!","success"),i.clear(),l()}).catch(u=>{const h=u instanceof Error?u.message:"Unknown error";c(`â Transaction failed: ${h}`,"error")})},a.onclick=()=>{c("Starting transaction with failure...","info"),e.write(["settings"],async u=>{const h=u.store("settings"),d={id:"temp-checkout",key:"checkoutInProgress",value:"true",updatedAt:Date.now()};await h.set(d),c("TX: First operation succeeded","info"),c("TX: Aborting...","error"),u.abort()}).catch(()=>{c("â Transaction aborted! All changes rolled back.","error")})},l(),c("Shopping Cart ready!","info")}}}function Vt(){let r;return{html:`
			<div class="demo-app cross-tab-sync featured-demo">
				<div class="featured-banner">
					<span class="featured-icon">ð</span>
					<span class="featured-text">REAL-TIME CROSS-TAB SYNC</span>
				</div>

				<h4>ð¡ Cross-Tab Synchronization Demo</h4>
				<p class="demo-desc">
					<strong>The most powerful browser storage feature!</strong> Changes made in one tab are <strong>instantly synchronized</strong>
					to all other open tabs via <code>BroadcastChannel</code>. Try it now:
				</p>

				<div class="cross-tab-instruction">
					<div class="instruction-step">
						<span class="step-number">1</span>
						<span class="step-text">Open this page in <strong>2+ browser tabs</strong></span>
						<button id="open-new-tab" class="btn small">ð Open New Tab</button>
					</div>
					<div class="instruction-step">
						<span class="step-number">2</span>
						<span class="step-text">Click a button below in <strong>this tab</strong></span>
					</div>
					<div class="instruction-step">
						<span class="step-number">3</span>
						<span class="step-text">Watch the event appear in the <strong>other tab</strong> instantly!</span>
					</div>
				</div>

				<div class="sync-controls">
					<button id="sync-add-btn" class="btn primary large-btn">â Add User (triggers cross-tab event)</button>
					<button id="sync-update-btn" class="btn large-btn">âï¸ Update Random User</button>
					<button id="sync-delete-btn" class="btn danger large-btn">ðï¸ Delete Random User</button>
				</div>

				<div class="sync-stats">
					<div class="sync-stat-card local">
						<span class="sync-stat-label">Local Events</span>
						<span class="sync-stat-value" id="local-event-count">0</span>
						<span class="sync-stat-desc">Changes made in this tab</span>
					</div>
					<div class="sync-stat-card remote">
						<span class="sync-stat-label">ð¡ Remote Events</span>
						<span class="sync-stat-value" id="remote-event-count">0</span>
						<span class="sync-stat-desc">Changes from other tabs</span>
					</div>
					<div class="sync-stat-card total">
						<span class="sync-stat-label">Total Events</span>
						<span class="sync-stat-value" id="total-event-count">0</span>
						<span class="sync-stat-desc">All synchronized changes</span>
					</div>
				</div>

				<h5>ð Live Event Feed</h5>
				<div class="event-feed enhanced-feed" id="sync-event-feed">
					<p class="placeholder">Make a change or wait for events from other tabs...</p>
				</div>

				<div class="code-example-box">
					<h5>ð» How It Works</h5>
					<pre class="syntax-code"><code><span class="keyword">const</span> db = <span class="function">createDatabase</span>({
  name: <span class="string">'myApp'</span>,
  version: <span class="number">1</span>,
  stores: { users: {} }
})

<span class="comment">// Subscribe to ALL changes (local + remote)</span>
db.<span class="function">onChange</span>((event) =&gt; {
  <span class="keyword">if</span> (event.source === <span class="string">'remote'</span>) {
    <span class="comment">// This change came from another tab!</span>
    console.<span class="function">log</span>(<span class="string">'ð¡ Cross-tab:'</span>, event.type, event.keys)
  }
})</code></pre>
				</div>

				<div class="demo-log" id="sync-log"></div>
			</div>
		`,init:(e,t)=>{const s=y(e,"#sync-event-feed"),n=y(e,"#local-event-count"),o=y(e,"#remote-event-count"),a=y(e,"#total-event-count"),i=y(e,"#sync-add-btn"),c=y(e,"#sync-update-btn"),l=y(e,"#sync-delete-btn"),u=y(e,"#open-new-tab"),h=y(e,"#sync-log"),d=t.store("users");let m=0,f=0,w=!0;function A(g,b="info"){const v=document.createElement("div");v.className=`log-entry ${b}`,v.textContent=`${new Date().toLocaleTimeString()} - ${g}`,h.insertBefore(v,h.firstChild),h.children.length>6&&h.lastChild&&h.removeChild(h.lastChild)}function C(g){const b=g.source==="remote";b?(f++,o.textContent=String(f),o.parentElement?.classList.add("flash"),setTimeout(()=>o.parentElement?.classList.remove("flash"),500)):(m++,n.textContent=String(m)),a.textContent=String(m+f),w&&(s.innerHTML="",w=!1);const v=document.createElement("div");v.className=`event-entry enhanced ${b?"remote-event":"local-event"} event-${g.type}`;const E=b?'<span class="source-badge remote">ð¡ FROM OTHER TAB</span>':'<span class="source-badge local">ð  This Tab</span>',D={set:'<span class="type-badge set">SET</span>',add:'<span class="type-badge add">ADD</span>',remove:'<span class="type-badge remove">DELETE</span>'}[g.type]??`<span class="type-badge">${g.type.toUpperCase()}</span>`;for(v.innerHTML=`
					<div class="event-header">
						${E}
						${D}
						<span class="event-time">${new Date().toLocaleTimeString()}</span>
					</div>
					<div class="event-details">
						<span class="event-store">Store: <strong>${g.storeName}</strong></span>
						<span class="event-keys">Keys: <code>${JSON.stringify(g.keys)}</code></span>
					</div>
				`,v.classList.add("slide-in"),s.insertBefore(v,s.firstChild);s.children.length>15&&s.lastChild;)s.removeChild(s.lastChild);b&&A(`ð¡ CROSS-TAB: ${g.type} on ${g.storeName}`,"success")}r=t.onChange(g=>{C(g)}),u.onclick=()=>{window.open(window.location.href,"_blank"),A("Opened new tab - try making changes there!","info")},i.onclick=()=>{const g=_[Math.floor(Math.random()*_.length)]??"User",b=V[Math.floor(Math.random()*V.length)]??"Test",v=H[Math.floor(Math.random()*H.length)]??"example.com",E=`${g} ${b}`,k={id:`sync-${Date.now()}`,name:E,email:`${g.toLowerCase()}.${b.toLowerCase()}@${v}`,age:20+Math.floor(Math.random()*40),status:"active",role:"user",tags:[],createdAt:Date.now()};d.set(k).then(()=>{A(`Added "${E}" - check other tabs!`,"success")}).catch(()=>{})},c.onclick=()=>{d.all().then(async g=>{if(g.length===0){A("No users to update. Add some first!","error");return}const b=g[Math.floor(Math.random()*g.length)];if(b){const v={...b,age:b.age+1};await d.set(v),A(`Updated "${b.name}" age to ${v.age}`,"success")}}).catch(()=>{})},l.onclick=()=>{d.all().then(async g=>{if(g.length===0){A("No users to delete. Add some first!","error");return}const b=g[Math.floor(Math.random()*g.length)];b&&(await d.remove(b.id),A(`Deleted "${b.name}"`,"success"))}).catch(()=>{})},A("Cross-Tab Sync Demo ready! Open another tab to test.","info")},cleanup:()=>{r?.()}}}function Ht(){return{html:`
			<div class="demo-app data-export">
				<h4>ð Data Export Tool</h4>
				<p class="demo-desc">Stream records with <code>iterate()</code> - memory efficient</p>

				<div class="export-controls">
					<select id="export-store" class="demo-select">
						<option value="users">Users</option>
						<option value="posts">Posts</option>
						<option value="settings">Settings</option>
					</select>
					<select id="export-format" class="demo-select">
						<option value="json">JSON</option>
						<option value="csv">CSV</option>
					</select>
					<button id="export-btn" class="btn primary">ð¤ Export</button>
				</div>

				<div class="export-progress" id="export-progress" style="display: none;">
					<div class="progress-bar">
						<div class="progress-fill" id="progress-fill" style="width: 0%"></div>
					</div>
					<span id="progress-text">0 records</span>
				</div>

				<div class="export-output">
					<h5>Preview</h5>
					<pre id="export-preview" class="code-preview"><code>Click Export to generate...</code></pre>
				</div>

				<div class="demo-log" id="export-log"></div>
			</div>
		`,init:(r,e)=>{const t=y(r,"#export-store"),s=y(r,"#export-format"),n=y(r,"#export-btn"),o=y(r,"#export-progress"),a=y(r,"#progress-fill"),i=y(r,"#progress-text"),c=y(r,"#export-preview code"),l=y(r,"#export-log");function u(h,d="info"){const m=document.createElement("div");m.className=`log-entry ${d}`,m.textContent=`${new Date().toLocaleTimeString()} - ${h}`,l.insertBefore(m,l.firstChild),l.children.length>5&&l.lastChild&&l.removeChild(l.lastChild)}n.onclick=()=>{const h=t.value,d=s.value;n.disabled=!0,o.style.display="block",a.style.width="0%";const m=e.store(h);(async()=>{try{const f=await m.count();u(`Exporting ${f} records from "${h}"...`);const w=performance.now(),A=await m.all(),C=A.length;a.style.width="100%",i.textContent=`${C} / ${f}`;const g=Math.round(performance.now()-w);u(`Completed: ${C} records in ${g}ms`,"success");let b;if(d==="json")b=JSON.stringify(A,null,2);else if(A.length===0)b="(no data)";else{const v=A[0],E=Object.keys(v),k=A.map(D=>{const P=D;return E.map(q=>JSON.stringify(P[q]??"")).join(",")});b=[E.join(","),...k].join(`
`)}c.textContent=b.length>1500?b.substring(0,1500)+`
... (truncated)`:b,n.disabled=!1}catch(f){u(`Export failed: ${f instanceof Error?f.message:"Unknown"}`,"error"),n.disabled=!1}})()}}}}function Gt(){return{html:`
			<div class="demo-app email-lookup">
				<h4>ð§ Email Lookup</h4>
				<p class="demo-desc">Fast O(1) lookups with <code>index().get()</code></p>

				<div class="lookup-form">
					<input type="email" id="lookup-email" placeholder="Enter email..." class="demo-input" list="email-suggestions" />
					<datalist id="email-suggestions">
						<option value="alice@example.com">
						<option value="bob@example.com">
						<option value="carol@example.com">
					</datalist>
					<button id="lookup-btn" class="btn primary">ð Lookup</button>
				</div>

				<div class="lookup-stats" id="lookup-stats" style="display: none;">
					<span class="stat">Time: <strong id="lookup-time">0</strong>ms</span>
				</div>

				<div class="lookup-result" id="lookup-result">
					<p class="placeholder">Enter an email to search...</p>
				</div>

				<div class="lookup-code">
					<h5>ð» Code</h5>
					<pre><code>// O(1) index lookup
const user = await store.index('byEmail').get('alice@example.com')</code></pre>
				</div>
			</div>
		`,init:(r,e)=>{const t=y(r,"#lookup-email"),s=y(r,"#lookup-btn"),n=y(r,"#lookup-result"),o=y(r,"#lookup-stats"),a=y(r,"#lookup-time"),i=y(r,"#email-suggestions"),c=e.store("users"),l=c.index("byEmail");c.all().then(h=>{const d=h.slice(0,10).map(m=>m.email);i.innerHTML=d.map(m=>`<option value="${m}">`).join("")}).catch(()=>{});function u(){const h=t.value.trim();if(!h){n.innerHTML='<p class="placeholder">Enter an email to search...</p>',o.style.display="none";return}const d=performance.now();l.get(h).then(m=>{const f=performance.now()-d;o.style.display="flex",a.textContent=f.toFixed(2),m?n.innerHTML=`
							<div class="user-card found">
								<h5>â User Found</h5>
								<div class="user-details">
									<p><strong>Name:</strong> ${m.name}</p>
									<p><strong>Email:</strong> ${m.email}</p>
									<p><strong>Age:</strong> ${m.age}</p>
									<p><strong>Status:</strong> ${m.status}</p>
								</div>
							</div>
						`:n.innerHTML=`
							<div class="user-card not-found">
								<h5>â Not Found</h5>
								<p>No user with email "${h}"</p>
							</div>
						`}).catch(()=>{})}s.onclick=u,t.onkeypress=h=>{h.key==="Enter"&&u()}}}}function Qt(){return{html:`
			<div class="demo-app registration">
				<h4>ð User Registration</h4>
				<p class="demo-desc">Handle <code>ConstraintError</code> and <code>NotFoundError</code></p>

				<div class="registration-form">
					<input type="text" id="reg-name" placeholder="Full Name" class="demo-input" />
					<input type="email" id="reg-email" placeholder="Email (try alice@example.com)" class="demo-input" />
					<button id="reg-submit" class="btn primary">Create Account</button>
				</div>

				<div class="registration-result" id="reg-result"></div>

				<div class="error-demo-section">
					<h5>Try These Scenarios:</h5>
					<button class="btn small scenario-btn" data-scenario="duplicate">1. Duplicate Email</button>
					<button class="btn small scenario-btn" data-scenario="notfound">2. Missing User</button>
					<button class="btn small scenario-btn" data-scenario="success">3. Success</button>
				</div>

				<div class="demo-log" id="reg-log"></div>
			</div>
		`,init:(r,e)=>{const t=y(r,"#reg-name"),s=y(r,"#reg-email"),n=y(r,"#reg-submit"),o=y(r,"#reg-result"),a=y(r,"#reg-log"),i=e.store("users");function c(h,d="info"){const m=document.createElement("div");m.className=`log-entry ${d}`,m.textContent=`${new Date().toLocaleTimeString()} - ${h}`,a.insertBefore(m,a.firstChild),a.children.length>6&&a.lastChild&&a.removeChild(a.lastChild)}function l(h,d){o.innerHTML=`<div class="result-box ${d?"success":"error"}">${h}</div>`}async function u(h,d){try{await i.index("byEmail").get(d)&&c(`Email "${d}" already registered`,"error");const f={id:`u-${Date.now()}`,name:h,email:d,age:25,status:"active",role:"user",tags:[],createdAt:Date.now()};await i.add(f),c(`User "${h}" registered!`,"success"),l(`<h5>â Success!</h5><p>Welcome, ${h}!</p>`,!0)}catch(m){if(m instanceof Error&&m.name==="ConstraintError")c("ConstraintError: Duplicate key","error"),l(`<h5>â Failed</h5><p>Email "${d}" already exists.</p>`,!1);else{const f=m instanceof Error?m.message:"Unknown";c(`Error: ${f}`,"error"),l(`<h5>â Error</h5><p>${f}</p>`,!1)}}}n.onclick=()=>{const h=t.value.trim(),d=s.value.trim();if(!h||!d){c("Please fill all fields","error");return}u(h,d)},r.querySelectorAll(".scenario-btn").forEach(h=>{const d=h;d.onclick=()=>{switch(d.dataset.scenario){case"duplicate":t.value="Test User",s.value="alice@example.com",u("Test User","alice@example.com");break;case"notfound":c("Calling resolve() for missing user...","info"),i.resolve("nonexistent-id").catch(f=>{f instanceof Error&&f.name==="NotFoundError"&&(c("NotFoundError: User not found","error"),l("<h5>â NotFoundError</h5><p>User not found.</p>",!1))});break;case"success":{const f=`user-${Date.now()}@example.com`;t.value="New User",s.value=f,u("New User",f);break}}}}),c("Registration demo ready!","info")}}}let p,G="store";const J=[],pe=[],z=[],ye=[{id:"store",emoji:"â¡",label:"Bulk Performance",description:"Insert 10,000+ records with real-time metrics, query performance benchmarks",demo:Ft},{id:"index",emoji:"ð",label:"Index Operations",description:"O(1) lookups, multi-entry indexes, unique constraints",demo:Gt},{id:"query",emoji:"ð",label:"Query Builder",description:"where, filter, orderBy, limit, offset, terminal operations",demo:jt},{id:"transactions",emoji:"ð³",label:"Transactions",description:"Atomic multi-store operations, durability options, abort/rollback",demo:_t},{id:"cursors",emoji:"ð",label:"Cursors",description:"Memory-efficient streaming, iterate, iterateKeys, navigation",demo:Ht},{id:"events",emoji:"ð",label:"Cross-Tab Sync",description:"FEATURED: Real-time synchronization between browser tabs",demo:Vt},{id:"errors",emoji:"â ï¸",label:"Error Handling",description:"Error classes, type guards, comprehensive patterns",demo:Qt}];function Wt(r){switch(r){case"store":return[{id:"get",title:"get() - Optional Lookup",description:"Returns undefined for missing records",run:()=>Be(p)},{id:"resolve",title:"resolve() - Required Lookup",description:"Throws NotFoundError for missing records",run:()=>Le(p)},{id:"set",title:"set() - Upsert (single or batch)",description:"Insert or update records, supports arrays",run:()=>Ke(p)},{id:"add",title:"add() - Insert Only",description:"Throws ConstraintError if key exists",run:()=>Fe(p)},{id:"remove",title:"remove() - Delete",description:"Silently succeeds for missing keys",run:()=>je(p)},{id:"has",title:"has() - Existence Check",description:"Check if records exist",run:()=>_e(p)},{id:"bulk",title:"Bulk Operations",description:"all(), keys(), count(), clear()",run:()=>Ve(p)},{id:"progress",title:"Progress Callbacks",description:"Track progress during bulk set/add",run:()=>Je(p)},{id:"export",title:"export() - Backup Data",description:"Export all database data",run:()=>Ge(p)},{id:"import",title:"import() - Restore Data",description:"Import data with progress tracking",run:()=>Qe(p)},{id:"storage",title:"Storage Quota",description:"Get storage usage and quota info",run:()=>We(p)},{id:"accessors",title:"Store Accessors",description:"getName, getKeyPath, getIndexNames",run:()=>He(p)}];case"index":return[{id:"accessors",title:"Index Accessors",description:"getName, getKeyPath, isUnique, isMultiEntry",run:()=>ze(p)},{id:"lookup",title:"Index Lookup",description:"get, resolve, getKey by index",run:()=>Xe(p)},{id:"has",title:"Index has() - Existence",description:"Check if record exists by index key",run:()=>tt(p)},{id:"nonunique",title:"Non-Unique Index",description:"Query non-unique index values",run:()=>Ye(p)},{id:"multientry",title:"Multi-Entry Index",description:"Index array elements separately",run:()=>Ze(p)},{id:"range",title:"Range Queries",description:"Numeric range queries on index",run:()=>et(p)},{id:"native",title:"Native Access",description:"Access native IDBIndex",run:()=>st(p)}];case"query":return[{id:"equals",title:"where().equals()",description:"Fast indexed equality query",run:()=>rt(p)},{id:"comparison",title:"Comparison Queries",description:"greaterThan, lessThan, between",run:()=>nt(p)},{id:"startswith",title:"startsWith()",description:"String prefix queries",run:()=>ot(p)},{id:"anyof",title:"anyOf()",description:"Multiple value queries",run:()=>at(p)},{id:"filter",title:"filter()",description:"Post-cursor filtering",run:()=>it(p)},{id:"combined",title:"Combined Query",description:"where() + filter() for optimal performance",run:()=>ct(p)},{id:"ordering",title:"Ordering & Pagination",description:"orderBy, limit, offset",run:()=>lt(p)},{id:"terminal",title:"Terminal Operations",description:"toArray, first, count, keys, iterate",run:()=>ut(p)},{id:"iterate",title:"iterate()",description:"Memory-efficient async generator",run:()=>dt(p)},{id:"boolean",title:"Boolean Queries",description:"Automatic fallback for non-indexable types",run:()=>ht(p)}];case"transactions":return[{id:"read",title:"Read Transaction",description:"Consistent reads across stores",run:()=>mt(p)},{id:"write",title:"Write Transaction",description:"Atomic multi-store modifications",run:()=>pt(p)},{id:"durability",title:"Durability Options",description:"default, strict, relaxed",run:()=>yt(p)},{id:"accessors",title:"Transaction Accessors",description:"getMode, getStoreNames, isActive",run:()=>gt(p)},{id:"abort",title:"Transaction Abort",description:"Roll back all changes",run:()=>ft(p)},{id:"native",title:"Native Access",description:"Access native IDBTransaction",run:()=>wt(p)}];case"cursors":return[{id:"iterate",title:"iterate()",description:"Async generator for records",run:()=>bt(p)},{id:"iteratekeys",title:"iterateKeys()",description:"Key-only iteration",run:()=>vt(p)},{id:"manual",title:"Manual Cursor",description:"openCursor() for full control",run:()=>xt(p)},{id:"mutation",title:"Cursor Mutation",description:"Update and delete during iteration",run:()=>Et(p)},{id:"navigation",title:"Cursor Navigation",description:"continue, advance methods",run:()=>At(p)},{id:"directions",title:"Cursor Directions",description:"next, previous, unique variants",run:()=>Ct(p)},{id:"keycursor",title:"Key Cursor",description:"Efficient key-only cursor",run:()=>St(p)},{id:"indexcursor",title:"Index Cursor",description:"Iterate through index",run:()=>Tt(p)}];case"events":return[{id:"dbchange",title:"Database onChange",description:"All store changes",run:()=>kt(p)},{id:"storechange",title:"Store onChange",description:"Specific store changes",run:()=>Nt(p)},{id:"crosstab",title:"Cross-Tab Sync",description:"BroadcastChannel synchronization",run:()=>Dt()},{id:"onerror",title:"onError",description:"Error event handling",run:()=>It(p)},{id:"versionchange",title:"onVersionChange",description:"Handle version upgrades",run:()=>qt(p)},{id:"onclose",title:"onClose",description:"Handle connection close",run:()=>Ot(p)},{id:"hooks",title:"Event Hooks",description:"Configure hooks at creation",run:()=>Pt()}];case"errors":return[{id:"notfound",title:"NotFoundError",description:"resolve() for missing records",run:()=>Rt(p)},{id:"constraint",title:"ConstraintError",description:"add() for duplicate keys",run:()=>$t(p)},{id:"codes",title:"Error Codes",description:"All error code enumeration",run:()=>Ut()},{id:"guards",title:"Type Guards",description:"Safe error type checking",run:()=>Mt(p)},{id:"hierarchy",title:"Error Hierarchy",description:"Error class structure",run:()=>Bt()},{id:"comprehensive",title:"Comprehensive Handling",description:"Best practices pattern",run:()=>Lt(p)}]}}function x(r,e){const t=document.createElement(r);return e?.className&&(t.className=e.className),e?.textContent&&(t.textContent=e.textContent),e?.id&&(t.id=e.id),t}function Jt(r){if(r===void 0)return"undefined";if(r===null)return"null";try{return JSON.stringify(r,null,2)}catch{return typeof r=="object"&&r!==null?"[Object]":typeof r=="string"?r:"[Unknown]"}}function ge(){z.forEach(l=>l()),z.length=0;const r=document.getElementById("app");if(!r)return;r.innerHTML="";const e=x("div",{className:"container"}),t=x("header"),s=x("h1",{textContent:"ðï¸ IndexedDB Showcase"}),n=x("p",{textContent:"Comprehensive demonstration of ALL @mikesaintsg/indexeddb features"});t.append(s,n);const o=x("nav",{className:"tabs"});ye.forEach(l=>{const u=x("button",{className:`tab ${G===l.id?"active":""}`,textContent:`${l.emoji} ${l.label}`});u.title=l.description,u.addEventListener("click",()=>{G=l.id,ge()}),o.appendChild(u)});const a=x("main",{id:"content"});zt(a);const i=x("footer"),c=x("p");c.innerHTML="ð¡ <strong>Open this page in another tab</strong> to see cross-tab sync in action!",i.appendChild(c),e.append(t,o,a,i),r.appendChild(e)}async function zt(r){const e=ye.find(i=>i.id===G);if(!e)return;const t=x("section",{className:"card"}),s=x("h2",{textContent:`${e.emoji} ${e.label}`}),n=x("p",{className:"subtitle",textContent:e.description});if(t.append(s,n),e.demo){const i=e.demo(),c=x("div",{className:"interactive-demo-container"});if(c.innerHTML=i.html,t.appendChild(c),i.init)try{await i.init(c,p)}catch(u){console.error("Demo init error:",u)}i.cleanup&&z.push(i.cleanup);const l=x("div",{className:"demo-separator"});l.innerHTML='<h3 style="margin: 24px 0 16px; color: #6b7280; font-size: 0.95rem;">ð API Reference Examples</h3>',t.appendChild(l)}const o=Wt(G),a=x("div",{className:"examples-container"});o.forEach(i=>{const c=Xt(i);a.appendChild(c)}),t.appendChild(a),r.appendChild(t)}function Xt(r){const e=x("div",{className:"example-card"}),t=x("div",{className:"example-header"}),s=x("h3",{textContent:r.title}),n=x("p",{className:"example-desc",textContent:r.description});t.append(s,n);const o=x("button",{className:"btn primary",textContent:"â¶ Run Example"}),a=x("div",{className:"example-result"});return a.style.display="none",o.addEventListener("click",()=>{Yt(r,o,a)}),e.append(t,o,a),e}async function Yt(r,e,t){e.disabled=!0,e.textContent="â³ Running...",t.style.display="block",t.innerHTML='<p class="loading">Running example...</p>';try{const s=await r.run();t.innerHTML="";const n=s.success?"success":"error",o=s.success?"â":"â",a=x("p",{className:`result-message ${n}`,textContent:`${o} ${s.message}`});if(t.appendChild(a),s.data!==void 0){const i=x("div",{className:"result-data"}),c=x("h4",{textContent:"ð Result Data"}),l=x("pre"),u=x("code",{textContent:Jt(s.data)});l.appendChild(u),i.append(c,l),t.appendChild(i)}if(s.code){const i=x("div",{className:"result-code"}),c=x("h4",{textContent:"ð» Code Example"}),l=x("div",{className:"code-block"}),u=x("pre"),h=x("code",{textContent:s.code});u.appendChild(h),l.appendChild(u),i.append(c,l),t.appendChild(i)}}catch(s){t.innerHTML="";const n=x("p",{className:"result-message error",textContent:`â Error: ${s instanceof Error?s.message:String(s)}`});t.appendChild(n)}finally{e.disabled=!1,e.textContent="â¶ Run Example"}}function Zt(r){const e=["Alice","Bob","Carol","David","Emma","Frank","Grace","Henry","Ivy","Jack","Kate","Leo","Maya","Noah","Olivia","Peter","Quinn","Rose","Sam","Tara"],t=["Anderson","Brown","Clark","Davis","Evans","Foster","Garcia","Harris","Ivanov","Jones","Kim","Lee","Miller","Nelson","Ortiz","Park","Quinn","Roberts","Smith","Taylor"],s=["gmail.com","outlook.com","yahoo.com","proton.me","icloud.com"],n=["admin","user","user","user","guest"],o=["active","active","active","inactive"],a=["developer","designer","manager","marketing","sales","support","hr","finance","ops","engineering"],i=[];for(let c=0;c<r;c++){const l=e[Math.floor(Math.random()*e.length)]??"User",u=t[Math.floor(Math.random()*t.length)]??"Unknown",h=s[Math.floor(Math.random()*s.length)]??"example.com",d=n[Math.floor(Math.random()*n.length)]??"user",m=o[Math.floor(Math.random()*o.length)]??"active",f=Math.floor(Math.random()*4),w=[];for(let A=0;A<f;A++){const C=a[Math.floor(Math.random()*a.length)];C&&!w.includes(C)&&w.push(C)}i.push({id:`sample-${c}-${Date.now()}`,name:`${l} ${u}`,email:`${l.toLowerCase()}.${u.toLowerCase()}${c}@${h}`,age:18+Math.floor(Math.random()*50),status:m,role:d,tags:w,createdAt:Date.now()-Math.floor(Math.random()*365*24*60*60*1e3)})}return i}async function es(){try{p=Me(),await p.store("users").count()<50&&await ts();const e=p.onChange(t=>{J.unshift({...t,timestamp:Date.now()}),J.length>100&&J.pop()});pe.push(e)}catch(r){console.error("Failed to initialize database:",r);const e=document.getElementById("app");throw e&&(e.innerHTML=`
				<div style="max-width: 600px; margin: 50px auto; padding: 20px; background: #fee2e2; border-radius: 8px; text-align: center;">
					<h2 style="color: #dc2626;">â ï¸ Database Error</h2>
					<p style="color: #991b1b;">Failed to initialize IndexedDB. This might happen if you're in private browsing mode or storage is full.</p>
					<p style="color: #991b1b; font-size: 0.9rem;">${r instanceof Error?r.message:"Unknown error"}</p>
					<button onclick="window.location.reload()" style="margin-top: 16px; padding: 8px 24px; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer;">
						ð Retry
					</button>
				</div>
			`),r}}async function ts(){await p.store("users").set([...X]),await p.store("posts").set([...Y]),await p.store("settings").set([...le]);const r=Zt(100);await p.store("users").set(r)}es().then(()=>{ge()});window.addEventListener("beforeunload",()=>{pe.forEach(r=>r())});</script>
  <style rel="stylesheet" crossorigin>*{box-sizing:border-box;margin:0;padding:0}:root{--primary: #4f46e5;--primary-hover: #4338ca;--danger: #dc2626;--danger-hover: #b91c1c;--warning: #f59e0b;--warning-hover: #d97706;--secondary: #6b7280;--secondary-hover: #4b5563;--success: #10b981;--bg: #f3f4f6;--card-bg: #ffffff;--text: #1f2937;--text-muted: #6b7280;--border: #e5e7eb;--radius: 8px;--shadow: 0 1px 3px rgba(0, 0, 0, .1);--shadow-lg: 0 4px 6px -1px rgba(0, 0, 0, .1)}body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,sans-serif;background:var(--bg);color:var(--text);line-height:1.5;min-height:100vh}.container{max-width:900px;margin:0 auto;padding:20px}header{text-align:center;margin-bottom:24px}header h1{font-size:2rem;margin-bottom:8px;color:var(--primary)}header p{color:var(--text-muted)}footer{text-align:center;margin-top:32px;padding:16px;color:var(--text-muted);font-size:.875rem;background:#e0e7ff;border-radius:var(--radius)}.tabs{display:flex;gap:8px;margin-bottom:20px;flex-wrap:wrap}.tab{padding:10px 20px;border:none;background:var(--card-bg);border-radius:var(--radius);cursor:pointer;font-size:.95rem;font-weight:500;transition:all .2s;box-shadow:var(--shadow)}.tab:hover{background:var(--border)}.tab.active{background:var(--primary);color:#fff}.card{background:var(--card-bg);border-radius:var(--radius);padding:24px;box-shadow:var(--shadow-lg)}.card h2{margin-bottom:4px;font-size:1.5rem}.card .subtitle{color:var(--text-muted);margin-bottom:20px;font-size:.875rem}.card code{background:#f1f5f9;padding:2px 6px;border-radius:4px;font-size:.85rem;color:var(--primary)}.form-row,.action-row{display:flex;gap:10px;margin-bottom:16px;flex-wrap:wrap}input[type=text],input[type=number],select{padding:10px 14px;border:1px solid var(--border);border-radius:var(--radius);font-size:.95rem;background:#fff;flex:1;min-width:120px}input[type=text]:focus,input[type=number]:focus,select:focus{outline:none;border-color:var(--primary);box-shadow:0 0 0 3px #4f46e51a}input[type=number]{width:80px;flex:none}.btn{padding:10px 18px;border:none;border-radius:var(--radius);font-size:.95rem;font-weight:500;cursor:pointer;transition:all .2s;white-space:nowrap}.btn.small{padding:6px 12px;font-size:.85rem}.btn.primary{background:var(--primary);color:#fff}.btn.primary:hover{background:var(--primary-hover)}.btn.secondary{background:var(--secondary);color:#fff}.btn.secondary:hover{background:var(--secondary-hover)}.btn.warning{background:var(--warning);color:#fff}.btn.warning:hover{background:var(--warning-hover)}.btn.danger{background:var(--danger);color:#fff}.btn.danger:hover{background:var(--danger-hover)}.filter-row{display:flex;gap:8px;margin-bottom:20px;flex-wrap:wrap;align-items:center}.filter-btn{padding:6px 14px;border:1px solid var(--border);background:#fff;border-radius:20px;cursor:pointer;font-size:.875rem;transition:all .2s}.filter-btn:hover{background:var(--border)}.filter-btn.active{background:var(--primary);color:#fff;border-color:var(--primary)}.todo-list{max-height:400px;overflow-y:auto;border:1px solid var(--border);border-radius:var(--radius)}.todo-item{display:flex;align-items:center;gap:12px;padding:12px 16px;border-bottom:1px solid var(--border);transition:background .2s}.todo-item:last-child{border-bottom:none}.todo-item:hover{background:#f9fafb}.todo-item.completed .todo-title{text-decoration:line-through;color:var(--text-muted)}.todo-toggle{width:20px;height:20px;cursor:pointer;flex-shrink:0}.priority{font-size:1rem;flex-shrink:0}.todo-title{flex:1;font-size:.95rem}.todo-date{font-size:.75rem;color:var(--text-muted);flex-shrink:0}.delete-btn{width:28px;height:28px;border:none;background:transparent;color:var(--text-muted);font-size:1.2rem;cursor:pointer;border-radius:50%;transition:all .2s;flex-shrink:0}.delete-btn:hover{background:var(--danger);color:#fff}.stats{display:flex;gap:24px;padding-top:16px;border-top:1px solid var(--border);margin-top:16px;font-size:.875rem;color:var(--text-muted)}.stats strong{color:var(--text)}.notes-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:16px;margin-top:16px}.note-card{padding:16px;border-radius:var(--radius);box-shadow:var(--shadow);transition:transform .2s,box-shadow .2s}.note-card:hover{transform:translateY(-2px);box-shadow:var(--shadow-lg)}.note-card h3{font-size:1rem;margin-bottom:8px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.note-card p{font-size:.875rem;color:#374151;margin-bottom:12px;max-height:60px;overflow:hidden}.note-footer{display:flex;justify-content:space-between;align-items:center;font-size:.75rem;color:var(--text-muted)}.delete-note-btn{width:24px;height:24px;border:none;background:#0000001a;border-radius:50%;cursor:pointer;font-size:1rem;line-height:1}.delete-note-btn:hover{background:var(--danger);color:#fff}.query-builder{background:#f8fafc;padding:20px;border-radius:var(--radius);margin-bottom:20px}.query-row{display:flex;align-items:center;gap:12px;margin-bottom:12px;flex-wrap:wrap}.query-row label{width:140px;font-weight:500;font-size:.875rem;flex-shrink:0}.query-row select{flex:none;width:180px}.query-results{min-height:100px;margin-bottom:20px}.query-results table{width:100%;border-collapse:collapse}.query-results th,.query-results td{padding:10px 12px;text-align:left;border-bottom:1px solid var(--border)}.query-results th{background:#f8fafc;font-weight:600;font-size:.875rem}.query-results td{font-size:.875rem}.query-results tr.completed td{color:var(--text-muted)}.result-count{margin-top:12px;font-size:.875rem;color:var(--text-muted)}.code-section h3{font-size:.95rem;margin-bottom:8px;color:var(--text-muted)}.code-block{background:#1e293b;color:#e2e8f0;padding:16px;border-radius:var(--radius);overflow-x:auto}.code-block pre{margin:0;font-family:Fira Code,Monaco,Consolas,monospace;font-size:.85rem;line-height:1.6}.info-box{background:#dbeafe;border:1px solid #93c5fd;padding:16px;border-radius:var(--radius);margin-bottom:20px}.info-box p{color:#1e40af;margin:0 0 8px}.info-box p:last-child{margin-bottom:0}.event-log{background:#1e293b;color:#e2e8f0;padding:16px;border-radius:var(--radius);max-height:400px;overflow-y:auto;font-family:Fira Code,Monaco,Consolas,monospace;font-size:.85rem}.event-list{list-style:none}.event-list li{padding:8px 12px;border-bottom:1px solid #334155;display:flex;gap:12px;align-items:center}.event-list li:last-child{border-bottom:none}.event-list li.local{border-left:3px solid #3b82f6}.event-list li.remote{border-left:3px solid #f59e0b;background:#f59e0b1a}.event-time{color:#94a3b8;font-size:.75rem}.event-source{font-weight:600;font-size:.75rem;padding:2px 6px;border-radius:4px}.event-list li.local .event-source{background:#3b82f6;color:#fff}.event-list li.remote .event-source{background:#f59e0b;color:#fff}.event-type{color:#22c55e}.event-store{color:#a78bfa}.event-keys{color:#94a3b8;font-size:.75rem}.loading{text-align:center;padding:40px;color:var(--text-muted)}.empty,.placeholder{text-align:center;padding:40px;color:var(--text-muted);font-style:italic}.error{color:var(--danger);text-align:center;padding:20px}.examples-container{display:flex;flex-direction:column;gap:16px}.example-card{border:1px solid var(--border);border-radius:var(--radius);padding:16px;background:#fafafa}.example-header{margin-bottom:12px}.example-header h3{font-size:1rem;margin-bottom:4px;color:var(--primary)}.example-desc{font-size:.85rem;color:var(--text-muted);margin:0 0 8px}.example-usecase{font-size:.85rem;color:#1e40af;background:#dbeafe;padding:8px 12px;border-radius:var(--radius);margin:0;border-left:3px solid var(--primary)}.example-result{margin-top:16px;padding-top:16px;border-top:1px solid var(--border)}.result-message{font-weight:500;padding:8px 12px;border-radius:var(--radius);margin:0 0 12px}.result-message.success{background:#d4edda;color:#155724}.result-message.error{background:#f8d7da;color:#721c24}.result-data,.result-code{margin-top:12px}.result-data h4,.result-code h4{font-size:.85rem;color:var(--text-muted);margin-bottom:8px}.result-data pre{background:#f1f5f9;padding:12px;border-radius:var(--radius);overflow-x:auto;font-size:.8rem;line-height:1.4;max-height:300px;overflow-y:auto}.result-data code{font-family:Fira Code,Monaco,Consolas,monospace}.demo-app{background:#fff;border:2px solid var(--primary);border-radius:var(--radius);padding:20px;margin-bottom:24px}.demo-app h4{font-size:1.1rem;color:var(--primary);margin-bottom:8px}.demo-app .demo-desc{font-size:.85rem;color:var(--text-muted);margin-bottom:16px}.demo-form{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px}.demo-input{padding:10px 14px;border:1px solid var(--border);border-radius:var(--radius);font-size:.9rem;flex:1;min-width:120px}.demo-input:focus{outline:none;border-color:var(--primary);box-shadow:0 0 0 3px #4f46e51a}.demo-input.small{flex:none;width:80px}.demo-select{padding:10px 14px;border:1px solid var(--border);border-radius:var(--radius);font-size:.9rem;background:#fff;cursor:pointer}.demo-stats{display:flex;gap:16px;margin-bottom:16px;flex-wrap:wrap}.demo-stats .stat{font-size:.85rem;color:var(--text-muted)}.demo-stats .stat strong{color:var(--primary)}.demo-list{border:1px solid var(--border);border-radius:var(--radius);max-height:300px;overflow-y:auto;margin-bottom:16px}.demo-list .placeholder{padding:24px;text-align:center;color:var(--text-muted);font-style:italic}.list-item{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid var(--border);gap:12px}.list-item:last-child{border-bottom:none}.list-item:hover{background:#f9fafb}.item-info{flex:1;min-width:0}.item-info strong{display:block;font-size:.95rem;margin-bottom:2px}.item-meta{font-size:.8rem;color:var(--text-muted)}.item-actions{display:flex;gap:6px;flex-shrink:0}.demo-log{background:#1e293b;color:#e2e8f0;padding:12px;border-radius:var(--radius);font-family:Fira Code,Monaco,Consolas,monospace;font-size:.8rem;max-height:150px;overflow-y:auto}.log-entry{padding:4px 0;border-bottom:1px solid #334155}.log-entry:last-child{border-bottom:none}.log-entry.info{color:#94a3b8}.log-entry.success{color:#22c55e}.log-entry.error{color:#f87171}.query-display{background:#f8fafc;padding:12px;border-radius:var(--radius);margin-bottom:16px;font-size:.85rem}.query-display code{display:block;margin-top:8px;white-space:pre-wrap;word-break:break-all;color:var(--primary)}.cart-layout{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:16px}@media(max-width:700px){.cart-layout{grid-template-columns:1fr}}.cart-products,.cart-summary{background:#f8fafc;padding:16px;border-radius:var(--radius)}.cart-products h5,.cart-summary h5{font-size:.95rem;margin-bottom:12px;color:var(--text)}.product-list{display:flex;flex-direction:column;gap:8px}.product-item{display:flex;justify-content:space-between;align-items:center;padding:8px 12px;background:#fff;border-radius:var(--radius);gap:8px}.product-name{flex:1;font-size:.9rem}.product-price{font-weight:600;color:var(--primary)}.cart-items{min-height:100px;margin-bottom:12px}.cart-item{display:flex;justify-content:space-between;align-items:center;padding:8px;background:#fff;border-radius:4px;margin-bottom:6px;font-size:.85rem}.cart-total{padding:12px;background:#fff;border-radius:var(--radius);text-align:right;font-size:1.1rem;margin-bottom:12px}.cart-total strong{color:var(--primary)}.monitor-controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px}.monitor-stats{display:flex;gap:20px;margin-bottom:16px}.event-feed{border:1px solid var(--border);border-radius:var(--radius);max-height:250px;overflow-y:auto;margin-bottom:16px}.event-entry{display:flex;gap:10px;padding:10px 12px;border-bottom:1px solid var(--border);font-size:.85rem;align-items:center;flex-wrap:wrap}.event-entry:last-child{border-bottom:none}.event-time{color:var(--text-muted);font-size:.75rem}.event-badge{padding:2px 8px;border-radius:4px;font-size:.7rem;font-weight:600;text-transform:uppercase}.event-badge.set{background:#dbeafe;color:#1e40af}.event-badge.add{background:#d1fae5;color:#065f46}.event-badge.remove{background:#fee2e2;color:#991b1b}.event-store{color:var(--primary);font-weight:500}.event-keys{color:var(--text-muted);font-size:.8rem}.event-cross-tab{background:#fef3c7;color:#92400e;padding:2px 6px;border-radius:4px;font-size:.7rem}.demo-tip{font-size:.85rem;color:var(--text-muted);font-style:italic;margin-top:12px}.export-controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px}.export-progress{margin-bottom:16px}.progress-bar{height:8px;background:var(--border);border-radius:4px;overflow:hidden;margin-bottom:8px}.progress-fill{height:100%;background:var(--primary);transition:width .1s}#progress-text{font-size:.8rem;color:var(--text-muted)}.export-output h5{font-size:.9rem;margin-bottom:8px}.code-preview{background:#1e293b;color:#e2e8f0;padding:16px;border-radius:var(--radius);max-height:200px;overflow:auto;font-size:.8rem}.lookup-form{display:flex;gap:8px;margin-bottom:16px}.lookup-stats{display:flex;gap:16px;margin-bottom:16px;font-size:.85rem}.lookup-result{margin-bottom:16px}.user-card{padding:16px;border-radius:var(--radius)}.user-card.found{background:#d1fae5;border:1px solid #10b981}.user-card.not-found{background:#fee2e2;border:1px solid #ef4444}.user-card h5{margin-bottom:8px}.user-details p{font-size:.9rem;margin:4px 0}.lookup-code{background:#f8fafc;padding:16px;border-radius:var(--radius)}.lookup-code h5{margin-bottom:8px;font-size:.9rem}.lookup-code pre{background:#1e293b;color:#e2e8f0;padding:12px;border-radius:var(--radius);font-size:.8rem;overflow-x:auto}.registration-form{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px}.registration-result{margin-bottom:16px}.result-box{padding:16px;border-radius:var(--radius)}.result-box.success{background:#d1fae5;border:1px solid #10b981}.result-box.error{background:#fee2e2;border:1px solid #ef4444}.result-box h5{margin-bottom:8px}.result-box pre{background:#1e293b;color:#e2e8f0;padding:12px;border-radius:var(--radius);font-size:.8rem;margin-top:12px;overflow-x:auto}.error-demo-section{background:#f8fafc;padding:16px;border-radius:var(--radius);margin-bottom:16px}.error-demo-section h5{margin-bottom:12px;font-size:.9rem}.scenario-btn{margin:4px}.demo-filters{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px}.syntax-code{background:#1e1e2e;color:#cdd6f4;padding:16px 20px;border-radius:var(--radius);overflow-x:auto;font-family:Fira Code,Monaco,Consolas,Courier New,monospace;font-size:.85rem;line-height:1.7;border:1px solid #313244}.syntax-code .keyword{color:#cba6f7;font-weight:500}.syntax-code .function{color:#89b4fa}.syntax-code .string{color:#a6e3a1}.syntax-code .number{color:#fab387}.syntax-code .comment{color:#6c7086;font-style:italic}.syntax-code .property{color:#89dceb}.syntax-highlight{display:block;background:#1e1e2e;color:#89b4fa;padding:12px 16px;border-radius:var(--radius);font-family:Fira Code,Monaco,Consolas,monospace;font-size:.85rem;border:1px solid #313244}.bulk-performance .performance-panel{background:linear-gradient(135deg,#1e1e2e,#313244);padding:20px;border-radius:var(--radius);margin-bottom:20px}.bulk-performance .perf-controls{margin-bottom:16px}.bulk-performance .perf-row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}.bulk-performance .perf-row label{color:#cdd6f4;font-weight:500}.bulk-performance .perf-stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;margin-bottom:16px}.perf-stat-card{background:#ffffff0d;border:1px solid rgba(255,255,255,.1);border-radius:var(--radius);padding:16px;text-align:center}.perf-stat-card .perf-label{display:block;color:#a6adc8;font-size:.75rem;text-transform:uppercase;letter-spacing:.5px;margin-bottom:8px}.perf-stat-card .perf-value{display:block;color:#89b4fa;font-size:1.5rem;font-weight:700;font-family:Fira Code,monospace}.bulk-performance .perf-progress{background:#0003;padding:16px;border-radius:var(--radius)}.bulk-performance .query-section{background:#f8fafc;padding:20px;border-radius:var(--radius);margin-bottom:16px}.bulk-performance .query-section h5{margin-bottom:12px;color:var(--text)}.bulk-performance .query-row{display:flex;gap:10px;margin-bottom:16px}.query-result-box{background:#fff;border:1px solid var(--border);border-radius:var(--radius);padding:16px}.query-result-box .query-meta{display:flex;gap:20px;margin-bottom:12px;font-size:.9rem}.query-result-box .query-code-block{margin-bottom:12px}.query-result-box .query-preview{background:#f1f5f9;padding:12px;border-radius:var(--radius)}.query-result-box .query-preview pre{margin:8px 0 0;font-size:.8rem;max-height:200px;overflow:auto}.cross-tab-sync.featured-demo{border:3px solid #f59e0b;background:linear-gradient(135deg,#fffbeb,#fef3c7)}.featured-banner{display:flex;align-items:center;justify-content:center;gap:10px;background:linear-gradient(90deg,#f59e0b,#d97706);color:#fff;padding:10px 20px;border-radius:var(--radius);margin-bottom:16px;font-weight:700;text-transform:uppercase;letter-spacing:1px;font-size:.85rem}.featured-banner .featured-icon{font-size:1.2rem}.cross-tab-instruction{background:#fff;border:2px dashed #f59e0b;border-radius:var(--radius);padding:16px;margin-bottom:20px}.instruction-step{display:flex;align-items:center;gap:12px;padding:10px 0;border-bottom:1px solid #fef3c7}.instruction-step:last-child{border-bottom:none}.step-number{width:28px;height:28px;background:#f59e0b;color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;flex-shrink:0}.step-text{flex:1;font-size:.95rem}.sync-controls{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:20px}.sync-controls .large-btn{padding:14px 20px;font-size:.95rem}.sync-stats{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-bottom:20px}@media(max-width:600px){.sync-stats{grid-template-columns:1fr}}.sync-stat-card{background:#fff;border-radius:var(--radius);padding:16px;text-align:center;border:2px solid var(--border);transition:all .3s ease}.sync-stat-card.local{border-color:#3b82f6}.sync-stat-card.remote{border-color:#f59e0b;background:#fffbeb}.sync-stat-card.total{border-color:#10b981}.sync-stat-card.flash{animation:flash-highlight .5s ease}@keyframes flash-highlight{0%,to{transform:scale(1)}50%{transform:scale(1.05);box-shadow:0 0 20px #f59e0b80}}.sync-stat-label{display:block;font-size:.8rem;color:var(--text-muted);text-transform:uppercase;letter-spacing:.5px;margin-bottom:8px}.sync-stat-value{display:block;font-size:2rem;font-weight:700;font-family:Fira Code,monospace;color:var(--primary)}.sync-stat-card.remote .sync-stat-value{color:#f59e0b}.sync-stat-card.total .sync-stat-value{color:#10b981}.sync-stat-desc{display:block;font-size:.75rem;color:var(--text-muted);margin-top:4px}.enhanced-feed{background:#1e1e2e;border:1px solid #313244;border-radius:var(--radius);max-height:350px;overflow-y:auto;margin-bottom:16px}.enhanced-feed .placeholder{color:#6c7086;padding:30px}.event-entry.enhanced{padding:12px 16px;border-bottom:1px solid #313244;animation:slide-in .3s ease}@keyframes slide-in{0%{opacity:0;transform:translate(-20px)}to{opacity:1;transform:translate(0)}}.event-entry.enhanced.local-event{background:#3b82f61a;border-left:4px solid #3b82f6}.event-entry.enhanced.remote-event{background:#f59e0b26;border-left:4px solid #f59e0b}.event-header{display:flex;gap:10px;align-items:center;margin-bottom:6px;flex-wrap:wrap}.source-badge{padding:3px 10px;border-radius:20px;font-size:.7rem;font-weight:700;text-transform:uppercase}.source-badge.local{background:#3b82f6;color:#fff}.source-badge.remote{background:#f59e0b;color:#fff;animation:pulse 1s ease}@keyframes pulse{0%,to{opacity:1}50%{opacity:.7}}.type-badge{padding:2px 8px;border-radius:4px;font-size:.7rem;font-weight:600}.type-badge.set{background:#dbeafe;color:#1e40af}.type-badge.add{background:#d1fae5;color:#065f46}.type-badge.remove{background:#fee2e2;color:#991b1b}.event-details{display:flex;gap:16px;font-size:.8rem;flex-wrap:wrap}.event-details .event-store{color:#a6adc8}.event-details .event-store strong{color:#89dceb}.event-details .event-keys{color:#6c7086}.event-details .event-keys code{background:#0000004d;padding:2px 6px;border-radius:4px;font-size:.75rem;color:#a6e3a1}.code-example-box{background:#fff;border:1px solid var(--border);border-radius:var(--radius);padding:16px;margin-bottom:16px}.code-example-box h5{margin-bottom:12px}@media(max-width:600px){.container{padding:12px}header h1{font-size:1.5rem}.tabs{gap:4px}.tab{padding:8px 12px;font-size:.85rem}.form-row{flex-direction:column}.form-row input,.form-row select{width:100%}.action-row{flex-direction:column}.action-row .btn{width:100%}.query-row{flex-direction:column;align-items:stretch}.query-row label,.query-row select{width:100%}.stats{flex-direction:column;gap:8px}.bulk-performance .perf-row{flex-direction:column;align-items:stretch}.bulk-performance .query-row,.sync-controls{flex-direction:column}.sync-controls .large-btn{width:100%}}</style>
</head>
<body>
<div id="app"></div>
</body>
</html>
